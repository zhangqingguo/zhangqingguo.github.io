<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot接入腾讯电子签</title>
      <link href="/2025/04/09/SpringBoot%E6%8E%A5%E5%85%A5%E8%85%BE%E8%AE%AF%E7%94%B5%E5%AD%90%E7%AD%BE/"/>
      <url>/2025/04/09/SpringBoot%E6%8E%A5%E5%85%A5%E8%85%BE%E8%AE%AF%E7%94%B5%E5%AD%90%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>项目中需要使用到电子签名的功能，经过调研决定使用腾讯电子签。官网：<a href="https://qian.tencent.com/">腾讯电子签-电子合同-腾讯在线合同签约平台</a></p><h2 id="2、接入流程"><a href="#2、接入流程" class="headerlink" title="2、接入流程"></a>2、接入流程</h2><p>2.1 结合业务需求确定接入方式，腾讯电子签产品很多，具体需要提前阅读官网或者联系售前客户之类的了解。本人在项目中接入方式是通过<strong>模板方式发起</strong>，其中模板是在腾讯的电子签工作台画好的。（也可以放在本地，通过文件上传的形式，然后发起）</p><p>2.2 首先登录腾讯电子签工作台，（以下以测试环境为例，正式环境需要企业认证注册，然后进入控制台。）</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> tencent </tag>
            
            <tag> 电子签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习</title>
      <link href="/2025/03/27/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/27/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1、前言">1、前言</h2><p>一直想学习python，于是在工作之余看免费的教程学习，但是因为工作忙或者自律性不够，总是断断续续，所以想记录一下学习笔记，方便复习和督促自己坚持学下去。视频教程来自：<a href="https://www.bilibili.com/video/BV1wD4y1o7AS/">https://www.bilibili.com/video/BV1wD4y1o7AS/</a></p><h2 id="2、学习内容">2、学习内容</h2><h3 id="1、python简介及开发环境">1、python简介及开发环境</h3>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot接入itext5生成pdf</title>
      <link href="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/"/>
      <url>/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot集成itext5，实现pdf生成"><a href="#SpringBoot集成itext5，实现pdf生成" class="headerlink" title="SpringBoot集成itext5，实现pdf生成"></a>SpringBoot集成itext5，实现pdf生成</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在项目开发中有需要生成pdf文件的功能，常见的方案如下：</p><ol><li>html作为模板，（Thymeleaf、freemaker等模板引擎）渲染数据，最后生成pdf</li><li>使用pdf模板（使用如：Adobe Acrobat编辑器，创建一个带有表单字段的PDF），填充数据，最后生成pdf</li><li>使用pdf模板（使用占位符，比如${name}），用数据替换占位符，最后生成pdf。比较复杂，不容易实现，不建议。</li></ol><p>如何得到pdf文件，主要有两种方法，一种是写代码生成，还有就是用pdf转换工具，比如wkhtmltopdf之类的。由于在项目中考虑到，使用html的方案，在修改模板时对用户不友好，所以采用了方案2：pdf模板+表单+填充数据。</p><p>工具使用<strong>itext5</strong>，因为itext7免费使用受到了某些限制，必须遵循 AGPL 开源协议，或购买商业许可证。还有其他免费的，如：<strong>Apache PDFBox</strong>，特点如下：</p><table><thead><tr><th align="left">技术</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>iText</strong></td><td align="left">功能强大，支持复杂 PDF 操作</td><td align="left">复杂 PDF 生成</td></tr><tr><td align="left"><strong>Apache PDFBox</strong></td><td align="left">免费，简单易用</td><td align="left">简单 PDF 生成</td></tr><tr><td align="left"><strong>Thymeleaf + Flying Saucer</strong></td><td align="left">基于 HTML 模板生成 PDF</td><td align="left">需要 HTML 模板的场景</td></tr><tr><td align="left"><strong>OpenPDF</strong></td><td align="left">iText 的免费分支，轻量级</td><td align="left">简单 PDF 生成</td></tr><tr><td align="left"><strong>JFreeReport + JFreeChart</strong></td><td align="left">支持生成带图表的 PDF</td><td align="left">需要图表的 PDF 生成</td></tr></tbody></table><h2 id="2、开发过程"><a href="#2、开发过程" class="headerlink" title="2、开发过程"></a>2、开发过程</h2><p>环境：SpringBoot 2.7.6、JDK1.8、itext 5.x</p><h3 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;    &lt;artifactId&gt;itextpdf&lt;/artifactId&gt;    &lt;version&gt;5.5.9&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--中文字体问题解决--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;    &lt;artifactId&gt;itext-asian&lt;/artifactId&gt;    &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="准备好pdf，并且设置好表单字段。"><a href="#准备好pdf，并且设置好表单字段。" class="headerlink" title="准备好pdf，并且设置好表单字段。"></a>准备好pdf，并且设置好表单字段。</h3><p>直接打卡Adobe Acrobat,创建一个空白pdf，然后在工具里面，点击准备表单。实际上，在创建pdf时，可以选择word文件，因为直接编辑pdf格式很难调整，而格式调整好的word转成pdf就好办多了，在相应对方添加表单域就可以了。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227155017718.png" alt="image-20250227155017718"></p><p>按钮一栏可以自行摸索，添加相应的域，这里就不多解释了。注意pic字段，我用的依然是文本域，而不是图片域，因为代码不一样，这个后面再说。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227162640729.png" alt="image-20250227162640729"></p><p>注意，复选框要设置选中显示的值，也就是图中的导出值，样式也可以设置。</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>PdfUtils的主要方法如下：</p><pre><code class="java">/** * 通过pdf模板输出到流 * * @param templateFile 模板 * @param dataMap      input数据 * @param picData      image图片 * @param checkboxMap  checkbox勾选框 * @param params       设置属性,字体大小、颜色 textfont/textcolor/textsize等 * @param outputStream 输出流 */public static void output(String templateFile, Map&lt;String, Object&gt; dataMap, Map&lt;String, byte[]&gt;picData,                          Map&lt;String, byte[]&gt; picData2,Map&lt;String, String&gt; checkboxMap,                           Map&lt;String,Object&gt; params,OutputStream outputStream) {    PdfStamper ps = null;    PdfReader reader = null;    try {        reader = new PdfReader(templateFile);        ps = new PdfStamper(reader, outputStream);        AcroFields form = ps.getAcroFields();        BaseFont bf = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);        form.addSubstitutionFont(bf);        if (ObjectUtils.isNotEmpty(dataMap)) {            for (String key : dataMap.keySet()) {                form.setField(key, String.valueOf(dataMap.getOrDefault(key, "")));            }        }        //不能编辑        ps.setFormFlattening(true);        if (ObjectUtils.isNotEmpty(checkboxMap)) {            for (String key : checkboxMap.keySet()) {                form.setField(key, checkboxMap.get(key), true);            }        }        PdfStamper stamper = ps;        if (ObjectUtils.isNotEmpty(picData)) {            picData.forEach((filedName, imgSrc) -&gt; {                List&lt;AcroFields.FieldPosition&gt; fieldPositions = form.getFieldPositions(filedName);                for (AcroFields.FieldPosition fieldPosition : fieldPositions) {                    int pageNo = fieldPosition.page;                    Rectangle signRect = fieldPosition.position;                    float x = signRect.getLeft();                    float y = signRect.getBottom();                    try {                        Image image = Image.getInstance(imgSrc);                        PdfContentByte under = stamper.getOverContent(pageNo);                        image.scaleToFit(signRect.getWidth(), signRect.getHeight());                        image.setAbsolutePosition(x, y);                        under.addImage(image);                    } catch (BadElementException e) {                        log.error("pdf模板，文档元素错误 ", e);                    } catch (IOException e) {                        log.error("pdf模板，IO错误 ", e);                    } catch (DocumentException e) {                        log.error("pdf模板，文档操作错误 ", e);                    }                }            });        }        if (!ObjectUtils.isEmpty(picData2)) {                picData2.forEach((filedName, imgSrc) -&gt; {                    List&lt;AcroFields.FieldPosition&gt; fieldPositions = form.getFieldPositions(filedName);                    for (AcroFields.FieldPosition fieldPosition : fieldPositions) {                        int pageNo = fieldPosition.page;                        Rectangle signRect = fieldPosition.position;                        float x = signRect.getLeft();                        float y = signRect.getBottom();                        try {                            URL url = new URL(imgSrc);                            Image image = Image.getInstance(url);                            PdfContentByte under = stamper.getOverContent(pageNo);                            image.scaleToFit(signRect.getWidth(), signRect.getHeight());                            image.setAbsolutePosition(x, y);                            under.addImage(image);                        } catch (BadElementException e) {                            e.printStackTrace();                        } catch (IOException e) {                            e.printStackTrace();                        } catch (DocumentException e) {                            e.printStackTrace();                        }                    }                });            }    } catch (Exception e) {        log.error("pdf模板填充数据异常 ", e);    } finally {        if (Objects.nonNull(ps)) {            try {                ps.close();            } catch (Exception e) {                log.error("pdf模板关闭异常 ", e);            }        }        if (Objects.nonNull(reader)) {            try {                reader.close();            } catch (Exception e) {                log.error("pdf模板关闭异常 ", e);            }        }    }}</code></pre><p>参数说明：</p><table><thead><tr><th>参数名称</th><th>参数类型</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>templateFile</td><td>String</td><td>/xx/xx/template.pdf</td><td>pdf模板,全路径</td></tr><tr><td>dataMap</td><td>Map&lt;String, Object&gt;</td><td>{  “name”: “John”,  “age”: 30,  “address”: “北京”}</td><td>文本字段数据的map</td></tr><tr><td>picData</td><td>Map&lt;String, byte[]&gt;</td><td>{“pic1”:”xxx”}</td><td>图片的数据map,其中byte[]是图片文件转成的字节数组</td></tr><tr><td>picData2</td><td>Map&lt;String, String&gt;</td><td>{“pic2”:”xxx”}</td><td>图片的数据map,其中值是图片的url地址</td></tr><tr><td>checkboxMap</td><td>Map&lt;String, String&gt;</td><td>{“checkbox1”:”1”}</td><td>复选框的数据map。1代表选中，这个是在编辑pdf模板时设置的。</td></tr><tr><td>params</td><td>Map&lt;String,Object&gt;</td><td>{“textsize”:”12f”}</td><td>设置属性,字体大小、颜色 textfont/textcolor/textsize等</td></tr><tr><td>outputStream</td><td>OutputStream</td><td></td><td>生成的pdf后，输出流</td></tr><tr><td>…</td><td></td><td></td><td></td></tr></tbody></table><p>接口代码：</p><pre><code class="java">@GetMapping("/previewPdf")public void previewPdf(HttpServletRequest request, HttpServletResponse response) throws IOException {    String templateFile = "D:\\workspace\\IdeaProjects\\pdfDemo\\src\\main\\resources\\static\\template.pdf";    Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;();    dataMap.put("name", "张小凡");    dataMap.put("age", "101");    dataMap.put("address", "上海市宛平南路600号");    dataMap.put("year", LocalDate.now().getYear());    dataMap.put("month", LocalDate.now().getMonthValue());    dataMap.put("day", LocalDate.now().getDayOfMonth());    response.setCharacterEncoding("utf-8");    response.setContentType("application/pdf");    Map&lt;String, byte[]&gt; picMap = new HashMap&lt;&gt;();    byte[] imageToBytes = ImageUtil.imageToBytes("D:\\workspace\\IdeaProjects\\pdfDemo\\src\\main\\resources\\static\\33981008.jpg");    picMap.put("pic", imageToBytes);    Map&lt;String, String&gt; picMap2 = new HashMap&lt;&gt;();    picMap2.put("pic2", "https://tse3-mm.cn.bing.net/th/id/OIP-C.jdP04yEoxG10mcywseQj7gAAAA?rs=1&amp;pid=ImgDetMain");    Map&lt;String, String&gt; checkboxMap = new HashMap&lt;&gt;();    checkboxMap.put("smoke", "1");    checkboxMap.put("drink", "1");    checkboxMap.put("hair", "0");    String fileName = new String("测试预览pdf文件".getBytes(), "ISO-8859-1");//避免中文乱码    response.setHeader("Content-Disposition", "inline;filename=".concat(String.valueOf(fileName) + ".pdf"));    PdfUtil.output(templateFile, dataMap, picMap, picMap2,checkboxMap, response.getOutputStream());}</code></pre><p>下载的接口只要修改一行代码：</p><pre><code class="java">response.setHeader("Content-Disposition", "attachment;filename=".concat(fileName + ".pdf"));</code></pre><h3 id="结果展示："><a href="#结果展示：" class="headerlink" title="结果展示："></a>结果展示：</h3><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227164234458.png" alt="image-20250227164234458"></p><p>ok，完美</p><h2 id="3、代码解释以及一些问题"><a href="#3、代码解释以及一些问题" class="headerlink" title="3、代码解释以及一些问题"></a>3、代码解释以及一些问题</h2><h3 id="获取表单的所有字段："><a href="#获取表单的所有字段：" class="headerlink" title="获取表单的所有字段："></a>获取表单的所有字段：</h3><pre><code class="java">AcroFields form = ps.getAcroFields();</code></pre><h3 id="创建BaseFont对象-用于加载字体"><a href="#创建BaseFont对象-用于加载字体" class="headerlink" title="创建BaseFont对象,用于加载字体"></a>创建BaseFont对象,用于加载字体</h3><pre><code class="java">BaseFont bf = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);</code></pre><p>第一个参数name，是字体名称。”STSongStd-Light” 来自iTextAsian.jar，iTextAsian.jar 里面预制了各种字体,用于中日韩等文字的显示问题。”UniGB-UCS2-H”是对应的字符编码。BaseFont.NOT_EMBEDDED 字体不会嵌入到PDF文件中（没有保存），可能会导致不同电脑显示不正确。BaseFont.EMBEDDED 使用的字体会嵌入（保存）到PDF文件中，这样文件会更大一些，这样PDF文件显示就是跨平台的</p><p><img src="https://img-blog.csdnimg.cn/20190825093623848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbWFkZWVl,size_16,color_FFFFFF,t_70" alt="aaa"></p><p>添加一个替代字体。这种方法用于指定一个或多个备用字体，当PDF中的字段需要显示的字符在原始字体中找不到时，iText将尝试使用这些备用字体显示字符.</p><pre><code class="java">form.addSubstitutionFont(bf);</code></pre><h3 id="设置字段值以及字体样式、大小等："><a href="#设置字段值以及字体样式、大小等：" class="headerlink" title="设置字段值以及字体样式、大小等："></a>设置字段值以及字体样式、大小等：</h3><pre><code class="java">form.setField(key, String.valueOf(dataMap.getOrDefault(key, "")));form.setFieldProperty(key, "textfont", bf,null);form.setFieldProperty(key, "textsize", 15.95f,null);//重新生成字段以应用属性更改form.regenerateField(key);</code></pre><p>注意：form.regenerateField(key)；这行代码是必须的，不然设置不会生效。</p><p>设置文本域不能编辑：</p><pre><code class="java">//不能编辑ps.setFormFlattening(true);</code></pre><h3 id="图片展示的两种实现："><a href="#图片展示的两种实现：" class="headerlink" title="图片展示的两种实现："></a>图片展示的两种实现：</h3><p>1、图片流的实现</p><pre><code class="java">Image image = Image.getInstance(imgSrc);PdfContentByte under = stamper.getOverContent(pageNo);image.scaleToFit(signRect.getWidth(), signRect.getHeight());image.setAbsolutePosition(x, y);under.addImage(image);</code></pre><p>2、图片url的实现:</p><pre><code class="java">URL url = new URL(imgSrc);Image image = Image.getInstance(url);PdfContentByte under = stamper.getOverContent(pageNo);image.scaleToFit(signRect.getWidth(), signRect.getHeight());image.setAbsolutePosition(x, y);under.addImage(image);</code></pre><h3 id="字体的问题："><a href="#字体的问题：" class="headerlink" title="字体的问题："></a>字体的问题：</h3><p>如果想使用iTextAsian不包含的字体怎么办？</p><h4 id="1、使用Windows系统下的字体"><a href="#1、使用Windows系统下的字体" class="headerlink" title="1、使用Windows系统下的字体"></a>1、使用Windows系统下的字体</h4><p>path是字体文件的全路径。</p><pre><code class="java"> String path = "C:\\Windows\\Fonts\\simhei.ttf"; BaseFont font = BaseFont.createFont(path, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</code></pre><p>Windows系统下的字体有的是.ttf类型，有的是.ttc类型。ttc类型的是组合字体，里面包含了几个字体的集合。若想使用ttc类型的文件，可以打开ttc文件，点击右上角下一个，看看你需要的是第几个字体，在声明字体的时候标注索引就好了。</p><pre><code class="java"> String path = "C:\\Windows\\Fonts\\simhei.ttf 0"; BaseFont font = BaseFont.createFont(path, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</code></pre><h4 id="2、使用外部的字体"><a href="#2、使用外部的字体" class="headerlink" title="2、使用外部的字体"></a>2、使用外部的字体</h4><p>自己从网上下载字体，然后放在项目的classpath路径下：比如我的黑体文件路径：src/main/resources/fonts/simhei.ttf</p><pre><code class="java">BaseFont bf = BaseFont.createFont("/fonts/simhei.ttf", BaseFont.IDENTITY_H, BaseFont.EMBEDDED);</code></pre><p>或者使用字体流的方式：</p><pre><code class="java">// 使用类加载器获取字体文件的输入流InputStream fontStream = PdfUtil.class.getResourceAsStream("/fonts/simsun.ttf");if (Objects.isNull(fontStream)) {    throw new RuntimeException("找不到字体文件");}byte[] fontBytes = IoUtil.readBytes(fontStream);// 使用输入流创建BaseFont对象BaseFont bf = BaseFont.createFont("simsun.ttf", BaseFont.IDENTITY_H, BaseFont.EMBEDDED, true, fontBytes, null);</code></pre><p>注意：这个时候name参数是字体的文件名称带后缀。</p><p>这种方式是比较推荐的，因为项目部署到不同平台，服务器自带的字体可能不支持，所以最好是放在项目中，然后嵌入pdf中。</p><h4 id="3、使用iTextAsian的字体，或者itext自带字体（不支持中文）"><a href="#3、使用iTextAsian的字体，或者itext自带字体（不支持中文）" class="headerlink" title="3、使用iTextAsian的字体，或者itext自带字体（不支持中文）"></a>3、使用iTextAsian的字体，或者itext自带字体（不支持中文）</h4><pre><code class="java">BaseFont bf = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);</code></pre><pre><code class="java">BaseFont bf = BaseFont.createFont(BaseFont.HELVETICA, "Cp1252", BaseFont.NOT_EMBEDDED);</code></pre><h3 id="浏览器预览时，标签页的问题："><a href="#浏览器预览时，标签页的问题：" class="headerlink" title="浏览器预览时，标签页的问题："></a>浏览器预览时，标签页的问题：</h3><pre><code class="java">String fileName = new String("测试预览pdf文件".getBytes(), "ISO-8859-1");//避免中文乱码response.setHeader("Content-Disposition", "inline;filename=".concat(String.valueOf(fileName) + ".pdf"));</code></pre><p>虽然代码中设置了fileName，但是标签页却无法展示。</p><p>原因是标签页默认展示的是文档属性里面的标题。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227180135113.png" alt="image-20250227180135113"></p><p>如果不想修改文档属性的标题，可以在代码中修改重新设置标题。</p><pre><code class="java">// 获取文档信息  Map&lt;String, String&gt; info = reader.getInfo();  if (info == null) {      info = new HashMap&lt;&gt;();  }  // 修改标题，默认显示在浏览器的标签页上，如果不设置，标签页会显示原先文档属性的标题（adobe，打开文件，属性，设置标题）  info.put("Title", "这是一个pdf");  // 设置文档信息  ps.setMoreInfo(info);</code></pre><p>效果：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250228142139535.png" alt="image-20250228142139535"></p><h2 id="4、使用itext5实现html转pdf"><a href="#4、使用itext5实现html转pdf" class="headerlink" title="4、使用itext5实现html转pdf"></a>4、使用itext5实现html转pdf</h2><p>由于pdf模板无法做到word那样根据内容大小自动换行，只能提前预估内容，设置文本域高度和宽度，特别是下划线上填充内容时，一行显示不下，不能自动换行，所以一些情况下，pdf模板填充内容无法满足需求。这时候考虑使用word模板然后转pdf，或者使用html转pdf。</p><p>itext5可以实现html转pdf。引入新的依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.itextpdf.tool&lt;/groupId&gt;    &lt;artifactId&gt;xmlworker&lt;/artifactId&gt;    &lt;version&gt;5.5.13.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>html可以是一个真实的文件，也可以是html字符串，还可以用模板引擎。最后都是转成流参数。简单实例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="UTF-8"/&gt;    &lt;style&gt;        body {            font-family: "SimSun", "Microsoft YaHei", sans-serif;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style="text-align: center"&gt;标题&lt;/h1&gt;&lt;p&gt;这是一段测试文本！&lt;/p&gt;&lt;p style="text-align: left;color: red"&gt;这是第二段测试文本！&lt;/p&gt;&lt;div&gt;    &lt;img src="http://www.baidu.com/img/bdlogo.gif" alt="百度" title="百度" width="100" height="100"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="java">@GetMapping("/previewPdf7")public void previewPdf7(HttpServletRequest request, HttpServletResponse response) throws IOException, DocumentException {    // 创建 PDF 文档    Document document = new Document();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PdfWriter writer = PdfWriter.getInstance(document, baos);    document.open();    // 读取 HTML 文件   // FileInputStream htmlFile = new FileInputStream("input.html");    String html = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";    InputStream htmlStream = new ByteArrayInputStream(html.getBytes(StandardCharsets.UTF_8));    // 从类路径加载 HTML 文件    InputStream htmlFile = MyPdfController.class.getResourceAsStream("/static/index2.html");    document.addTitle("html转pdf测试");    FontProvider asianFontProvider = new FontProvider() {        @Override        public boolean isRegistered(String s) {            return false;        }        @Override        public Font getFont(String s, String s1, boolean b, float v, int i, BaseColor baseColor) {            BaseFont bfChinese = null;            try {                bfChinese = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);            } catch (DocumentException | IOException e) {                throw new RuntimeException(e);            }            return new Font(bfChinese, v, i, baseColor);        }    };    // 使用 XMLWorkerHelper 将 HTML 转换为 PDF   // XMLWorkerHelper.getInstance().parseXHtml(writer, document, htmlFile, StandardCharsets.UTF_8, new AsianFontProvider());    XMLWorkerHelper.getInstance().parseXHtml(writer, document, htmlFile, StandardCharsets.UTF_8, asianFontProvider);    // 关闭文档    document.close();    // 获取 PDF 字节流    byte[] pdfBytes = baos.toByteArray();    response.setCharacterEncoding(StandardCharsets.UTF_8.toString());    response.setContentType(MediaType.APPLICATION_PDF_VALUE);    String fileName = new String("test".getBytes(), StandardCharsets.ISO_8859_1);    response.setHeader(Header.CONTENT_DISPOSITION.getValue(), "inline;filename=".concat(fileName + ".pdf"));    // 将 PDF 字节流写入响应输出流    OutputStream out = response.getOutputStream();    out.write(pdfBytes);    out.flush();    out.close();}</code></pre><p>注意中文的问题，需要FontProvider加载中文字体才能显示中文，否则会乱码。也可以单独写一个中文的class，然后，当成参数，传给parseXHtml方法。比如：</p><pre><code class="java">/** * 用于中文显示的Provider */class AsianFontProvider extends XMLWorkerFontProvider {    @Override    public Font getFont(final String fontname, String encoding, float size, final int style) {        try {            BaseFont bfChinese = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);            return new Font(bfChinese, size, style);        } catch (Exception e) {        }        return super.getFont(fontname, encoding, size, style);    }}</code></pre><p>字体可以是iTextAsian中的，也可以自定义加载字体，这个和前面的一样。效果如下：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318160427999.png" alt="image-20250318160427999"></p><p>到这里还没结束，简单的html和简单样式可以，但是稍微复杂的样式，itext5就不支持了，所以样式多的html用itext5效果很不好。比如这样一个html页面转成pdf后，效果很差。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318161132356.png" alt="image-20250318161132356"></p><p>pdf：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318161321981.png" alt="image-20250318161321981"></p><p>最重要的是表格显示不全，也许调整html样式可以解决，但是太麻烦，itext5对css样式支持有限是主要问题。text7支持更多的css样式，但是有开源协议的限制。</p><p>继续尝试其他的转pdf工具，比如：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt;    &lt;artifactId&gt;flying-saucer-pdf-itext5&lt;/artifactId&gt;    &lt;version&gt;9.1.22&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>但是效果一样不好，而且需要在html中指定字体，不然中文显示不出来。</p><pre><code class="html">&lt;style&gt;    body {        font-family: "SimSun", "Microsoft YaHei", sans-serif;    }&lt;/style&gt;</code></pre><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318162158739.png" alt="image-20250318162158739"></p><p>最后使用wkhtmltox工具，经过测试，这个工具转pdf效果好，所以采用这个方案，缺点是需要在服务器上安装工具、还有字体。</p><p>用工具转pdf后，可以直接保存到服务器上，也可以返回文件流。</p><pre><code class="java">@GetMapping("/previewPdf8")public void previewPdf8(HttpServletResponse response) {    response.setCharacterEncoding(StandardCharsets.UTF_8.toString());    response.setContentType(MediaType.APPLICATION_PDF_VALUE);    // HTML 内容    String htmlContent = "&lt;!DOCTYPE html&gt;\n" +            "&lt;html&gt;\n" +            "&lt;head&gt;\n" +            "    &lt;meta charset=\"UTF-8\"/&gt;\n" +            "&lt;/head&gt;\n" +            "&lt;body&gt; &lt;div data-v-137a61c0=\"\" style=\"text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 30px;\"&gt; xxx患者病历单 &lt;/div&gt;&lt;table data-v-137a61c0=\"\" cellspacing=\"0\" style=\"width: 100%; border-collapse: collapse;\"&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" colspan=\"6\" style=\"background: lightblue; line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;患者基本信息&lt;/td&gt;&lt;/tr&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;姓名&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;test012&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;性别&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;男&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;证件号&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;年龄&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;婚姻&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt; &lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;身高&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;体重&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt; &lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;民族&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;就诊ID&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;div data-v-137a61c0=\"\" style=\"font-size: 12px; color: rgb(102, 102, 102); margin: 20px 0px;\"&gt; 注：远程诊疗是异地医疗咨询活动，门诊医师与申请门诊医师之间的关系属于医学知识的咨询关系，对病人的诊断与治疗的决定权属于收治病人的医疗机构（引自原卫生部卫办发[1999]第2号）。 &lt;/div&gt;" +            "&lt;/body&gt;\n" +            "&lt;/html&gt;";    // 调用 wkhtmltopdf 将 HTML 字符串转换为 PDF 字节流    try {        byte[] pdfBytes = htmlToPdf(htmlContent);        System.out.println("PDF 生成成功！大小: " + pdfBytes.length + " 字节");        //避免中文乱码        String fileName = new String("test".getBytes(), StandardCharsets.ISO_8859_1);        response.setHeader("Content-Disposition", "inline;filename=".concat(fileName) + ".pdf");        OutputStream outputStream = response.getOutputStream();        outputStream.write(pdfBytes);        outputStream.flush();        outputStream.close();    } catch (IOException | InterruptedException e) {        e.printStackTrace();    }}public  byte[] htmlToPdf(String htmlContent) throws IOException, InterruptedException {    // 创建 ProcessBuilder    ProcessBuilder processBuilder = new ProcessBuilder("wkhtmltopdf", "-", "-");    processBuilder.redirectErrorStream(true);    // 启动进程    Process process = processBuilder.start();    // 将 HTML 内容写入进程的标准输入    try (OutputStream stdin = process.getOutputStream();         BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(stdin))) {        writer.write(htmlContent);    }    // 捕获进程的标准输出（PDF 字节流）    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    try (InputStream stdout = process.getInputStream()) {        byte[] buffer = new byte[1024];        int length;        while ((length = stdout.read(buffer)) != -1) {            outputStream.write(buffer, 0, length);        }    }    // 等待进程完成    int exitCode = process.waitFor();    if (exitCode != 0) {        throw new IOException("wkhtmltopdf 进程执行失败，退出码: " + exitCode);    }    // 返回 PDF 字节流    return outputStream.toByteArray();}</code></pre><p>效果如下：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318162816661.png" alt="image-20250318162816661"></p><p>工具的效果还是比较好的。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> itext5 </tag>
            
            <tag> pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2学习</title>
      <link href="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2学习"><a href="#Vue2学习" class="headerlink" title="Vue2学习"></a>Vue2学习</h1><p>视频教程来自尚硅谷：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH/?vd_source=51c1f9b29ad3cdfa95187e2976f09cef">尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通_哔哩哔哩_bilibili</a>,vue2文档：<a href="https://v2.cn.vuejs.org/v2/guide/">介绍 — Vue.js</a></p><h2 id="1-vue基础知识和原理"><a href="#1-vue基础知识和原理" class="headerlink" title="1. vue基础知识和原理"></a>1. vue基础知识和原理</h2><h3 id="1-1-初识vue"><a href="#1-1-初识vue" class="headerlink" title="1.1 初识vue"></a>1.1 初识vue</h3><ul><li><p>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象</p></li><li><p>app容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法</p></li><li><p>app容器里的代码被称为【Vue模板】</p></li><li><p>Vue实例和容器是一一对应的,不能一对多和多对一</p></li><li><p>真实开发中只有一个Vue实例，并且会配合着组件一起使用</p></li><li>是Vue的语法：插值表达式，可以读取到data中的所有属性</li><li><p>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新(Vue实现的响应式)<br>代码：这里是直接引入开发版本的vue.js,可以去官网下载</p></li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;01&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--容器和vue实例是一对一的，不能一对多和多对一--&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}} {{op}} {{wifu}}&lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--关闭生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            op: 'BC',            wifu: 'YM'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-2-模板语法"><a href="#1-2-模板语法" class="headerlink" title="1.2 模板语法"></a>1.2 模板语法</h3><p>Vue模板语法有2大类:</p><ul><li>插值语法：</li></ul><p>​    功能：用于解析<strong>标签体</strong>内容</p><p>​    写法：，xxx是js表达式，且可以直接读取到data中的所有属性</p><ul><li>指令语法:</li></ul><p>​    功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）</p><p>​    举例：v-bind:href=“xxx” 或 简写为 :href=“xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;插值语法&lt;/h1&gt;    &lt;h2&gt;Hello,{{name}}&lt;/h2&gt;    &lt;hr/&gt;    &lt;h1&gt;指令语法&lt;/h1&gt;    &lt;a v-bind:href="link.url"&gt;去{{link.title}}&lt;/a&gt;    &lt;!-- v-bind简写 --&gt;    &lt;br/&gt;    &lt;a :href="link.url"&gt;去{{link.title}}2&lt;/a&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            link:{                title: '百度',                url: 'https://www.baidu.com'            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-3-数据绑定"><a href="#1-3-数据绑定" class="headerlink" title="1.3 数据绑定"></a>1.3 数据绑定</h3><p>Vue中有2种数据绑定的方式：</p><ul><li>单向绑定(v-bind)：数据只能从data流向页面</li><li>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data</li></ul><p>注意：</p><p>1.双向绑定一般都应用在表单类元素上（如：input、select等）</p><p>2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    单向数据绑定：&lt;input type="text" v-bind:value="name"&gt;&lt;br/&gt;    双向数据绑定：&lt;input type="text" v-model:value="name"&gt;&lt;br/&gt;    &lt;!--    简写--&gt;    单向数据绑定2：&lt;input type="text" :value="name"&gt;&lt;br/&gt;    &lt;!-- 简写 v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值--&gt;    双向数据绑定2：&lt;input type="text" v-model="name"&gt;&lt;br/&gt;    &lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-4-el与data的两种写法"><a href="#1-4-el与data的两种写法" class="headerlink" title="1.4 el与data的两种写法"></a>1.4 el与data的两种写法</h3><p>el有2种写法</p><ul><li>new Vue时候配置el属性</li><li>先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值</li></ul><p>data有2种写法</p><ul><li><p>对象式</p></li><li><p>函数式</p><p>注意：在组件中，data必须使用函数式。一个重要原则：由Vue管理的函数不能是箭头函数，因为这样写this就不再是Vue实例了。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;el和data的两种写法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}} &lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    //el的两种写法    /*    const vm = new Vue({       // el: '#app',//第一种写法        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG'        }    });    console.log(vm);    vm.$mount('#app') //第二种写法,挂载容器*/    // data的两种写法    const vm2 = new Vue({        el: '#app',        // data: { //第一种写法，对象        //     name: 'ZQG'        // }        // 第二种写法，函数式        // data: function () {}        data() {            console.log(this)            return {                name: 'ZQG'            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ul><h3 id="1-5-MVVM模型"><a href="#1-5-MVVM模型" class="headerlink" title="1.5 MVVM模型"></a>1.5 MVVM模型</h3><ul><li><p>M：模型(Model) ：data中的数据</p></li><li><p>V：视图(View) ：模板代码</p></li></ul><ul><li>VM：视图模型(ViewModel)：Vue实例</li></ul><p><img src="https://img-blog.csdnimg.cn/02f5aad7bfc440789dfa852b370f740d.webp" alt="mvvm"></p><p>data中的所有属性都在vm中。</p><p>vm的所有属性，包括Vue原型上所有属性，Vue模板都可以直接使用。</p><h3 id="1-6-数据代理"><a href="#1-6-数据代理" class="headerlink" title="1.6 数据代理"></a>1.6 数据代理</h3><p>通过一个对象代理对另一个对象中的属性的操作(读/写)。</p><p>主要通过js方法：Object.defineProperty()实现的，需要先去了解Object.defineProperty()相关知识，属性标志，属性描述符，getter，setter.</p><p>简单介绍一下：</p><p>属性标志:</p><p>对象属性（properties），除 value 外，还有三个特殊的特性（attributes），也就是所谓的“标志”</p><p>writable — 如果为 true，则值可以被修改，否则它是只可读的，默认为false<br>enumerable — 如果为 true，则表示是可以遍历的，可以在for… .in Object.keys()中遍历出来，默认为false<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以，默认为false</p><pre><code class="javascript">&lt;script type="text/javascript"&gt;    let num = 18;    let person = {        name: 'ZQG',        //age: 18,        sex: '男'    };    Object.defineProperty(person, 'age',{         value: num,        // enumerable: true, // 是否可枚举，默认为false        // configurable: true,// 是否可以删除,默认为false        // writable: true// 能否修改,默认为false    })  console.log(person);&lt;/script&gt;</code></pre><p>如图：</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123165409650.png" alt="image-20250123165409650"></p><p>如果不将相应的配置设置为true，修改不起作用，删除也返回false，也无法枚举。</p><p>使用getter和setter时：</p><pre><code class="javascript">&lt;script type="text/javascript"&gt;    let num = 18;    let person = {        name: 'ZQG',        //age: 18,        sex: '男'    };    Object.defineProperty(person, 'age',{         //value: num,        // enumerable: true, // 是否可枚举，默认为false        // configurable: true,// 是否可以删除,默认为false        // writable: true// 能否修改,默认为false        get() {            console.log('读取age属性');//person.age 起作用            return num;        },        set(value) {            console.log('设置age属性,值是：', value);//person.age = 20 起作用            num = value;        }    })  console.log(person);&lt;/script&gt;</code></pre><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123170003588.png" alt="image-20250123170003588"></p><p>每次访问person.age时，会触发getter函数，返回num值；当设置person.age = xx值时，会把值设置给num，这样再次读取会返回最新的num值，（直接设置num值，获取age值也是返回设置后的num值）这样就实现了数据代理。</p><p><strong>Vue中的数据代理</strong></p><p>Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写）<br>Vue中数据代理的好处：更加方便的操作data中的数据<br>基本原理：<br>通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>为每一个添加到vm上的属性，都指定一个getter/setter。<br>在getter/setter内部去操作（读/写）data中对应的属性。</p><p>我们代码中的data实际和Vue实例中的_data是相等的，所以取值，Vue为了代码写的方便，通过数据代理将_data的属性值，直接放在vm中，所以直接取值用就可以了。</p><p>验证代码：为了验证data和我们代码中的数据（person）是一样的，所以把person定义在外面，这样可以直接可以_data==person作比较</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;数据代理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}},{{age}},{{sex}}&lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    let person = {        name: 'ZQG',        age: 18,        sex: '男'    };  const vm = new Vue({      el: '#app',      data: person  });  console.log(vm)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123175247017.png" alt="image-20250123175247017"></p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123175508777.png" alt="image-20250123175508777"></p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123175744591.png" alt="image-20250123175744591"></p><h3 id="1-7-事件处理"><a href="#1-7-事件处理" class="headerlink" title="1.7 事件处理"></a>1.7 事件处理</h3><p>事件的基本使用：</p><ul><li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名</li><li>事件的回调需要配置在methods对象中，最终会在vm上</li><li>methods中配置的函数不要用箭头函数，这会导致this不再是vm了</li><li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象</li><li>@click=”show” 和@click=”show($event)”，效果一致，但是后者可以传参</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;事件处理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}}，欢迎来到{{address}}&lt;/h1&gt;    &lt;button v-on:click="showInfo"&gt;点我&lt;/button&gt;    &lt;button @click="showInfo"&gt;点我2（不传参）&lt;/button&gt;    &lt;button @click="showInfo3($event,666)"&gt;点我3（传参）&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',        data: {            name: 'ZQG',            address: '支配剧场'        },        methods: {            showInfo: function (event) {                alert('Hello,Vue!');                console.log(event);// event对象                console.log(this);// this指向当前Vue实例            },            showInfo3(event, num) {                console.log(event.target.innerText);// event对象                //console.log(this);// this指向当前Vue实例                alert(num)            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Vue中的事件修饰符</p><ul><li>prevent：阻止默认事件（常用）</li><li>stop：阻止事件冒泡（常用）</li><li>once：事件只触发一次（常用）</li><li>capture: 使用事件的捕获模式</li><li>self: 只有event.target是当前的操作元素时才触发事件</li><li>passive: 事件的默认行为立即执行，无需等待事件回调完毕</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;事件处理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;    &lt;style type="text/css"&gt;        * {            margin-top: 10px;        }        .dd{            width: 100px;            height: 80px;            background-color: red;        }        .aa{            width: 100px;            height: 60px;            background-color: skyblue;        }        .bb{            width: 100px;            height: 20px;            background-color: green;        }        .ll{            width: 150px;            height: 100px;            background-color: orange;            overflow: auto;        }        li{            height: 50px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}}，欢迎来到{{address}}&lt;/h1&gt;    &lt;!--    阻止事件--&gt;    &lt;a href="https://www.baidu.com" @click.prevent="showInfo"&gt;点我跳转&lt;/a&gt;    &lt;div class="dd" @click="showInfo"&gt;        &lt;!--   阻止事件冒泡     --&gt;       &lt;button @click.stop="showInfo"&gt;点我&lt;/button&gt;         &lt;!--   修饰符可以连续写--&gt;        &lt;a href="https://www.baidu.com" @click.prevent.stop="showInfo"&gt;点我跳转&lt;/a&gt;    &lt;/div&gt;    &lt;!--    事件只触发一次--&gt;    &lt;button @click.once="showInfo"&gt;点我&lt;/button&gt;    &lt;!-- 原本： 事件捕获=》事件冒泡（调用）,所以打印2再打印1. 使用capture后：在捕获的时候就会调用，此时先打印1后打印2 --&gt;    &lt;div class="aa" @click.capture="showMsg(1)"&gt;        div1        &lt;div class="bb" @click="showMsg(2)"&gt;            div2        &lt;/div&gt;    &lt;/div&gt;    &lt;div class="dd" @click.self="showInfo"&gt;        &lt;!--   只有event.target是当前的操作元素时才触发事件     --&gt;        &lt;button @click="showInfo"&gt;点我&lt;/button&gt;    &lt;/div&gt;&lt;!--    @scroll 滚动条,@wheel 鼠标滚轮--&gt;    &lt;ul @wheel.passive="work" class="ll"&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',        data: {            name: 'ZQG',            address: '支配剧场'        },        methods: {            showInfo: function (event) {                alert('Hello,Vue!');                console.log(event);// event对象                console.log(this);// this指向当前Vue实例            },            showMsg: function (msg) {                alert(msg);            },            work: function (event) {                for (let i = 0; i &lt; 10000; i++) {                    console.log('#');                }            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-8-键盘事件"><a href="#1-8-键盘事件" class="headerlink" title="1.8 键盘事件"></a>1.8 键盘事件</h3><p>键盘事件语法糖：@keydown，@keyup</p><p>1.Vue中常用的按键别名：</p><ul><li>回车 =&gt; enter</li><li>删除 =&gt; delete(捕获删除和退格键)</li><li>退出 =&gt; esc</li><li>空格 =&gt; space</li><li>换行 =&gt; tab (特殊，必须配合keydown去使用)</li><li>上 =&gt; up</li><li>下 =&gt;down</li><li>左 =&gt;left</li><li>右 =&gt;right</li></ul><p>2.Vue未提供别名的键，可以使用按键的原始key值去绑定,但是要注意转为kebab-case（短横线命名）</p><p>3.系统修饰键(用法特殊):ctrl,alt,shift,meta</p><p>​3.1配合keyup使用：按下修饰键的同时，再按下其他键，随后释放，事件才会触发</p><p>​3.2配合keydown使用：正常触发</p><p>4.可以使用keyCode去指定具体的按键（不推荐）</p><p>5.Vue.config.keyCode.自定义键名=键码，可以定制按键别名</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;键盘事件&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}}&lt;/h1&gt;    &lt;input type="text" placeholder="按下回车提示输入" @keyup="showInfo"&gt;    &lt;input type="text" placeholder="按下tab提示输入" @keydown.tab="showInfo"&gt;        &lt;!--  连写 ctrl + y --&gt;    &lt;input type="text" placeholder="按下ctrl提示输入" @keyup.ctrl.y="showInfo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    Vue.config.keyCodes.dsb = 13;//自定义按键,dsb替换成enter @keyup.dsb="",不推荐使用    let person = {        name: 'ZQG'    };  new Vue({      el: '#app',      data: person,      methods: {          showInfo(e) {              console.log(e.key,e.keyCode,e.target.value)          }      }  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9 计算属性"></a>1.9 计算属性</h3><p>定义：要用的属性不存在，要通过已有属性计算得来。<br>原理：底层借助了Objcet.defineProperty方法提供的getter和setter<br>get函数什么时候执行？<br>(1).初次读取时会执行一次<br>(2).当依赖的数据发生改变时会被再次调用<br>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便<br>备注：<br>计算属性最终会出现在vm上，直接读取使用即可<br>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;姓名案例&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    姓: &lt;input type="text" v-model="firstName"/&gt;&lt;br&gt;    名：&lt;input type="text" v-model="lastName"/&gt;&lt;br&gt;    全名：&lt;span&gt;{{fullName}}&lt;/span&gt;&lt;br&gt;    全名：&lt;span&gt;{{fullName2}}&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            firstName: 'ZQG',            lastName: 'YM'        },        computed:{            fullName:{                //初次读取fullName时，get方法会调用一次                // 所依赖的数据发生变化时，get方法会调用一次                //其他情况，会读取缓存的数据                get(){                    console.log('get调用');                    console.log(this);                    return this.firstName + '-' + this.lastName;                },                //set方法不是必须写的，如果计算属性确定没有修改的场景，可以不写set                // 当fullName被修改时，set方法会调用一次                set(value){                    const names = value.split('-');                    this.firstName = names[0];                    this.lastName = names[1];                }            },            //简写，不包含set方法            fullName2() {                return this.firstName + '-' + this.lastName;            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-10-监视属性"><a href="#1-10-监视属性" class="headerlink" title="1.10 监视属性"></a>1.10 监视属性</h3><p>监视属性watch：</p><ul><li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li><li>监视的属性必须存在，才能进行监视</li><li>监视的两种写法：<ul><li>(1).new Vue时传入watch配置</li><li>(2).通过vm.$watch监视</li></ul></li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;天气案例&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--容器和vue实例是一对一的，不能一对多和多对一--&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;    &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            isHot: true,        },        computed: {            info() {                return this.isHot ? '炎热' : '凉爽';            }        },        methods: {            changeWeather() {                this.isHot = !this.isHot;            }        },        watch: {            isHot: {                // 监听isHot属性的变化                handler(newValue, oldValue) {                    console.log('isHot', newValue, oldValue);                },                immediate: true, //初始化时执行handler,默认false                deep: true //深度监听            },            //简写，不需要immediate，deep时            // 监听isHot属性的变化            isHot(newValue, oldValue) {                console.log('isHot', newValue, oldValue);            }            //info，计算属性也可以被监听            // info: {            //     // 监听info属性的变化            //     handler(newValue, oldValue) {            //         console.log('info', newValue, oldValue);            //     },            //     immediate: true, //初始化时执行handler,默认false            //     deep: true //深度监听            // }        }    });    // 监听isHot属性的变化   /* vm.$watch('isHot', {        handler(newValue, oldValue) {            console.log('isHot', newValue, oldValue);        },        immediate: true, //初始化时执行handler,默认false        deep: true //深度监听    });  */    //简写，不需要配置immediate，deep时    vm.$watch('isHot',function (newValue, oldValue) {        console.log('isHot改变了', newValue, oldValue);    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(1).Vue中的watch默认不监测对象内部值的改变（一层）<br>(2).配置deep:true可以监测对象内部值改变（多层）<br>备注：</p><p>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以</p><p>(2).使用watch时根据数据的具体结构，决定是否采用深度监视</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;天气案例-深度监视&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--容器和vue实例是一对一的，不能一对多和多对一--&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;    &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;    &lt;hr&gt;    &lt;h2&gt;a的值是{{num.a}}&lt;/h2&gt;    &lt;button @click="num.a++"&gt;点我a+1&lt;/button&gt;    &lt;hr&gt;    &lt;h2&gt;b的值是{{num.b}}&lt;/h2&gt;    &lt;button @click="num.b++"&gt;点我b+1&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            isHot: true,            num:{                a:1,                b:2            }        },        computed: {            info() {                return this.isHot ? '炎热' : '凉爽';            }        },        methods: {            changeWeather() {                this.isHot = !this.isHot;            }        },        watch: {            isHot: {                // 监听isHot属性的变化                handler(newValue, oldValue) {                    console.log('isHot', newValue, oldValue);                },                immediate: true, //初始化时执行handler,默认false                deep: true //深度监听            },            // 监听多级结构中某个属性，num.a属性的变化            'num.a':{                handler(newValue, oldValue) {                    console.log('num.a改变了', newValue, oldValue);                },            },            // 监听多级结构中所有属性的变化            num:{                handler(newValue, oldValue) {                    console.log("num改变了");                },                deep: true//深度监听            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>computed和watch之间的区别：</p><p>computed能完成的功能，watch都可以完成<br>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作<br>两个重要的小原则：</p><p>1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象</p><p>2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;姓名案例-watch写法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    姓: &lt;input type="text" v-model="firstName"/&gt;&lt;br&gt;    名：&lt;input type="text" v-model="lastName"/&gt;&lt;br&gt;    全名：&lt;span&gt;{{fullName}}&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            firstName: 'ZQG',            lastName: 'YM',            fullName: 'ZQG-YM'        },       watch:{            firstName(newValue,oldValue){                setTimeout(()=&gt;{                    this.fullName = newValue +'-'+ this.lastName;                },1000)            },            lastName(newValue,oldValue){                this.fullName = this.firstName +'-'+ newValue;            }       }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-11-绑定样式"><a href="#1-11-绑定样式" class="headerlink" title="1.11 绑定样式"></a>1.11 绑定样式</h3><h4 id="class样式"><a href="#class样式" class="headerlink" title="class样式"></a><strong>class样式</strong></h4><p>写法：:class=“xxx” xxx可以是字符串、对象、数。</p><p>所以分为三种写法，字符串写法，数组写法，对象写法</p><p><strong>字符串写法</strong></p><p>字符串写法适用于：类名不确定，要动态获取。</p><p><strong>数组写法</strong></p><p>数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p><p><strong>对象写法</strong></p><p>对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><h4 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a><strong>style样式</strong></h4><p>有两种写法，对象写法，数组写法.</p><p>:style = “{forntSize:xxx}” ,xxx时动态值</p><p>:style=”[a,b]”  a,b是样式对象</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;绑定样式&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;    &lt;style&gt;        .basic{            text-align: center;            width: 400px;            height: 100px;            border: 1px solid black;        }        .happy{            background-color: yellow;            border: 4px solid red;        }        .sad{            border: 4px solid blue;            background-color: gray;        }        .normal{            background-color: skyblue;        }        .zqg1{            background-color: yellowgreen;        }        .zqg2{            font-size: 30px;            text-shadow:2px 2px 10px red;        }        .zqg3{            border-radius: 20px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;&lt;!--    字符串写法，适用于：类名不确定，要动态获取--&gt;    &lt;div class="basic" :class="mood" @click="changeMood"&gt;{{name}}&lt;/div&gt;    &lt;br/&gt;&lt;!--   数组写法，适用于：要绑定多个样式，个数不确定，名字也不确定--&gt;    &lt;div class="basic" :class="arr"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;&lt;!--    对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用--&gt;    &lt;div class="basic" :class="classObj"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;    &lt;div class="basic" :style="styleObj"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;    &lt;div class="basic" :style="styleArr"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            mood:'normal',            arr:['zqg1','zqg2','zqg3'],            classObj:{                zqg1:true,                zqg2:false,                zqg3:true            },            styleObj:{                color:'red',                fontSize:'35px',                backgroundColor:'orange'            },            styleArr:[{color:'blue', fontSize: '45px'},{backgroundColor:'gray'}]        },        methods: {            changeMood: function () {                const arr = ['happy', 'sad','normal'];                this.mood = arr[Math.floor(Math.random() * arr.length)];            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-12-条件渲染"><a href="#1-12-条件渲染" class="headerlink" title="1.12 条件渲染"></a>1.12 条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>写法：</p><p>(1).v-if=“表达式”</p><p>(2).v-else-if=“表达式”</p><p>(3).v-else=“表达式”</p><p>适用于：切换频率较低的场景</p><p>特点：不展示的DOM元素直接被移除</p><p>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”</p><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><strong>v-show</strong></h4><ul><li>写法：v-show=“表达式”</li><li>适用于：切换频率较高的场景</li><li>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉(display:none)</li></ul><p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到;v-if 是实打实地改变dom元素，v-show 是隐藏或显示dom元素</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;条件渲染&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2 v-show="condition"&gt;你好，{{name}}&lt;/h2&gt;    &lt;br/&gt;    &lt;h2 v-show="1===1"&gt;你好，{{name}}&lt;/h2&gt;    &lt;hr&gt;    &lt;h2 v-if="1===1"&gt;你好，{{name}}&lt;/h2&gt;    &lt;hr&gt;    &lt;h2&gt;当前i的值是：{{i}}&lt;/h2&gt;    &lt;button @click="i++"&gt;点我++&lt;/button&gt;    &lt;div v-if ="i === 1"&gt;Angular&lt;/div&gt;    &lt;div v-else-if ="i === 2 "&gt;React&lt;/div&gt;    &lt;div v-else-if="i === 3"&gt;Vue&lt;/div&gt;    &lt;div v-else&gt;666&lt;/div&gt;&lt;!--  template只能和v-if配合使用  --&gt;    &lt;template v-if="i === 4"&gt;        &lt;h2&gt;zqg&lt;/h2&gt;        &lt;h2&gt;bc&lt;/h2&gt;        &lt;h2&gt;ym&lt;/h2&gt;    &lt;/template&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            condition: true,            i: 0        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-13-列表渲染"><a href="#1-13-列表渲染" class="headerlink" title="1.13 列表渲染"></a>1.13 列表渲染</h3><h4 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h4><ul><li>用于展示列表数据</li><li>语法：v-for=“(item, index) in xxx” :key=“yyy”</li><li>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表渲染&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt; &lt;ul&gt;     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;     &lt;hr/&gt;     &lt;li v-for="(p,index) in persons" :key="index"&gt;{{p.name}}-{{p.age}}&lt;/li&gt; &lt;/ul&gt;    &lt;hr/&gt;    &lt;h2&gt;汽车信息&lt;/h2&gt;    &lt;li v-for="(value,key,index) in car" :key="key"&gt;        {{index}}-{{key}}-{{value}}    &lt;/li&gt;    &lt;hr/&gt;    &lt;h2&gt;字符串信息&lt;/h2&gt;    &lt;li v-for="(value,index) in str" :key="index"&gt;        {{index}}--{{value}}    &lt;/li&gt;    &lt;hr&gt;    &lt;h2&gt;遍历次数&lt;/h2&gt;    &lt;li v-for="(value,index) in 5" :key="index"&gt;        {{index}} -- {{value}}    &lt;/li&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: 'zqg', age: 18},               {id: '002', name: 'bc',age: 19},               {id: '003', name: 'ym',age: 20},           ],            car: {                name: '奔驰',                price: '1000000',                color: '黑色'            },            str: 'hello world'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="key的原理"><a href="#key的原理" class="headerlink" title="key的原理"></a>key的原理</h4><p>可以先了解一下虚拟DOM和真实DOM，以及它们之间的差异：<a href="https://juejin.cn/post/6844903895467032589">深入剖析：Vue核心之虚拟DOM使用 Vue 做项目也有两年时间了，对 Vue 的 api也用的比较得心应手了，虽然对 - 掘金</a></p><p><strong>虚拟DOM中key的作用</strong></p><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p><ol><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><p>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p><p>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key:</p><p>创建新的真实DOM，随后渲染到到页面。</p></li></ol><p></p><p><strong>用index作为key可能会引发的问题：</strong></p><ol><li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作：</p><p>会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p></li><li><p>如果结构中还包含输入类的DOM：</p><p>会产生错误DOM更新==&gt;界面有问题。</p></li></ol><p><strong>开发中如何选择key：</strong></p><ol><li>最好使用每条数据的唯一标识作为key，如id，身份证号，手机号，学号等。</li><li>如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表展示，可以使用index作为key。</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表渲染-key的原理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;button @click.once="add"&gt;添加一个老张&lt;/button&gt; &lt;ul&gt;     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}} &lt;input type="text"&gt;&lt;/li&gt;     &lt;hr/&gt;     &lt;li v-for="(p,index) in persons" :key="index"&gt;{{p.name}}-{{p.age}} &lt;input type="text"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: 'zqg', age: 18},               {id: '002', name: 'bc',age: 19},               {id: '003', name: 'ym',age: 20},           ]        },        methods: {            add() {                const p = {id: '004', name: '老张', age: 30};                this.persons.unshift(p);            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Vue中key原理图：</p><p>index作为key时：注意，如果不指定key，Vue会默认用index作为key。</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250210160230853.png" alt="image-20250210160230853"></p><p>因为老刘被插到第一个，重刷了 key 的值，vue Diff 算法根据 key 的值判断虚拟DOM 全部发生了改变，然后全部重新生成新的真实 DOM（key所对应的input输入框，算法比对是一样的，所以直接复用了，这导致页面上输入框对不上）。实际上，张三，李四，王五并没有发生更改，是可以直接复用之前的真实 DOM，而因为 key 的错乱，导致要全部重新生成，造成了性能的浪费。</p><p>使用唯一标识作为key时：</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250210160037121.png" alt="image-20250210160037121"></p><h3 id="1-14-列表过滤"><a href="#1-14-列表过滤" class="headerlink" title="1.14 列表过滤"></a>1.14 列表过滤</h3><p>watch和computed都可以实现，computed更简单方便</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表过滤&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type="text" v-model="keyword" placeholder="请输入名字"&gt; &lt;ul&gt;     &lt;li v-for="p in filterPersons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: '马冬梅', age: 18},               {id: '002', name: '周冬雨',age: 19},               {id: '003', name: '周杰伦',age: 20},               {id: '004', name: '温兆伦',age: 25}           ],            //filterPersons:[],            keyword: ''        },        computed: {            filterPersons() {                return this.persons.filter(p =&gt; p.name.indexOf(this.keyword) !== -1);            }        },        /*        watch: {            keyword:{                immediate: true,                handler(newValue, oldValue) {                    this.filterPersons = this.persons.filter(p =&gt; p.name.indexOf(newValue) !== -1);                }            }        }        */    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-15-列表排序"><a href="#1-15-列表排序" class="headerlink" title="1.15 列表排序"></a>1.15 列表排序</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表排序&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type="text" v-model="keyword" placeholder="请输入名字"&gt;    &lt;button @click="sortType=1"&gt;年龄升序&lt;/button&gt;    &lt;button @click="sortType=2"&gt;年龄降序&lt;/button&gt;    &lt;button @click="sortType=0"&gt;原顺序&lt;/button&gt; &lt;ul&gt;     &lt;li v-for="p in filterPersons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;     &lt;hr/&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: '马冬梅', age: 28},               {id: '002', name: '周冬雨',age: 19},               {id: '003', name: '周杰伦',age: 20},               {id: '004', name: '温兆伦',age: 25}           ],            keyword: '',            sortType:0 //0:原顺序，1：升序，2：降序        },        computed: {            filterPersons() {                return this.persons.filter(p =&gt; p.name.indexOf(this.keyword) !== -1).sort(                    (p1, p2) =&gt; {                        if (this.sortType === 1) {                            return p1.age - p2.age;                        } else if (this.sortType === 2) {                            return p2.age - p1.age;                        } else {                            return 0;                        }                    }                );            }        },    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-16-Vue监测数据的原理"><a href="#1-16-Vue监测数据的原理" class="headerlink" title="1.16 Vue监测数据的原理"></a>1.16 Vue监测数据的原理</h3><h4 id="监测对象数据："><a href="#监测对象数据：" class="headerlink" title="监测对象数据："></a>监测对象数据：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;更新时的问题&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;button @click="updateYm"&gt;更新ym&lt;/button&gt; &lt;ul&gt;     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt; &lt;/ul&gt;    &lt;button @click="addGender"&gt;添加性别&lt;/button&gt;    &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt;    &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt;    &lt;h3&gt;性别：{{student.gender}}&lt;/h3&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: 'zqg', age: 18},               {id: '002', name: 'bc',age: 19},               {id: '003', name: 'ym',age: 20},           ],            student:{                name:'lyf',                age:18            }        },        methods:{            updateYm(){                //this.persons[2].name = 'lyf' //成功，生效                this.persons[0]={id: '001', name: 'zzz', age: 10}//失效，因为vue对数组的变更进行了监听，如果直接修改数组中的某一个对象，vue是无法知道这个数组发生了变化，所以需要使用数组的方法进行操作，如：push、pop、shift、unshift、splice等            },            addGender(){                //Vue.set(this.student,'gender','男')                this.$set(this.student,'gender','女')            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>现象：直接修改person数组中某个对象的某个属性值室，Vue可以监测到并解析模板重新渲染，但是把某个对象改了（替换），代码是执行了，内存中的数据夜修改成功了，但是页面没有变化，说明Vue没有监测到。</p><p>Vue 监测数据变化的原理：</p><p>加工data中的数据（主要是添加响应式的getter和setter方法，用的是Object.defineProperty()方法）==&gt;把加工后的对象传给_data,也就是vm._data = data  ==&gt; 属性值改变会调用set方法，在set方法中去解析模板，生成虚拟DOM，新旧DOM比较，更新页面。</p><p>简单模拟实现一下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模拟数据监测&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" &gt;    let data = {        name:'zqg',        address:'bj',    }    //创建一个监视的实例对象，用于监视data中属性的变化，（Vue实际做的更多，更完善）    const obs = new Observer(data)    console.log(obs)    //准备一个vm实例对象    let vm = {}    vm._data = data = obs        function Observer(obj){        //汇总对象中所有的属性形成一个数组        const keys = Object.keys(obj)        //遍历        keys.forEach((k) =&gt; {            Object.defineProperty(this, k, {                get() {                    return obj[k]                },                set(val) {                    console.log(`${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)                    obj[k] = val                }            })        })    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>Vue.set 的使用</strong></p><p>Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index，value)</p><p>用法：</p><p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式<strong>对象</strong>上添加新 property，因为 Vue 无法探测普通的新增 property (比如 vm.myObject.newProperty = ‘xx’)</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250212180852337.png" alt="image-20250212180852337"></p><h4 id="监测数组："><a href="#监测数组：" class="headerlink" title="监测数组："></a>监测数组：</h4><p>vue 没有为数组中的元素生成 getter 和 setter，所以监测不到数据的更改（根据index替换元素的值），也不会引起页面的更新。</p><p>想要Vue监测到数据变化，需要使用数组的方法进行操作，如：push、pop、shift、unshift、splice等。（这些方法已经被Vue包装了）</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250213112714047.png" alt="image-20250213112714047"></p><p>除了用数组方法，当然还可以用Vue.set()或者vm.$set()来修改数组元素。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>Vue监视数据的原理：</strong></p><p>vue会监视data中所有层次的数据。</p><p><strong>如何监测对象中的数据？</strong></p><p>通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><p>对象中后追加的属性，Vue默认不做响应式处理，如需给后添加的属性做响应式，请使用如下API：</p><p>Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index，value)</p><p><strong>如何监测数组中的数据？</strong></p><p>通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>1、调用原生对应的方法对数组进行更新<br>2、重新解析模板，进而更新页面<br><strong>在Vue修改数组中的某个元素一定要用如下方法：</strong></p><p>1、使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>2、Vue.set() 或 vm.$set()</p><p><strong>注意：Vue.set() 或 vm.$set() 不能给vm对象和根数据对象_data，添加响应式的属性。</strong></p><h3 id="1-17-收集表单数据"><a href="#1-17-收集表单数据" class="headerlink" title="1.17 收集表单数据"></a>1.17 收集表单数据</h3><p>若：&lt;input type=”text”/&gt;，则v-model收集的是value值，用户输入的就是value值。</p><p>若：&lt;input type=”radio”/&gt;，则v-model收集的是value值，且要给标签配置value值。</p><p>若：&lt;input type=”checkbox”/&gt;</p><p>没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>配置input的value属性:<br>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>v-model的初始值是数组，那么收集的的就是value组成的数组。</p><p>备注：v-model的三个修饰符：</p><p>lazy：失去焦点再收集数据</p><p>number：输入字符串转为有效的数字</p><p>trim：输入首尾空格过滤</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;form @submit="submitForm"&gt;        &lt;label for = "userName"&gt;账号：&lt;/label&gt;        &lt;input type="text" id="userName" v-model.trim="userInfo.userName"&gt;&lt;br&gt;        &lt;label for="password"&gt;密码：&lt;/label&gt;        &lt;input type="password" id="password" v-model="userInfo.password"&gt;&lt;/input&gt;&lt;br&gt;        &lt;br&gt;        性别：        男&lt;input type="radio" name="sex" value="1" v-model="userInfo.sex"&gt;        女&lt;input type="radio" name="sex" value="0" v-model="userInfo.sex"&gt;&lt;br&gt;        &lt;br&gt;        年龄: &lt;input type="number" v-model.number="userInfo.age"&gt;&lt;br&gt;&lt;br&gt;        爱好：        打游戏&lt;input type="checkbox" name="hobby" value="game" v-model="userInfo.hobby"&gt;        看电影&lt;input type="checkbox" name="hobby" value="movie" v-model="userInfo.hobby"&gt;        跑步&lt;input type="checkbox" name="hobby" value="run" v-model="userInfo.hobby"&gt;        &lt;br&gt;        &lt;br&gt;        学历：        &lt;select name="userInfo.education" &gt;            &lt;option value="大专"&gt;大专&lt;/option&gt;            &lt;option value="本科"&gt;本科&lt;/option&gt;            &lt;option value="硕士"&gt;硕士&lt;/option&gt;            &lt;option value="博士"&gt;博士&lt;/option&gt;        &lt;/select&gt;        &lt;br&gt;        &lt;br&gt;        &lt;label for="birthday"&gt;出生日期：&lt;/label&gt;        &lt;input type="date" id="birthday" v-model="userInfo.birthday"&gt;&lt;br&gt;&lt;/input&gt;        &lt;br&gt;        其他信息：        &lt;textarea name="otherInfo" cols="30" rows="10" v-model.lazy="userInfo.otherInfo"&gt;&lt;/textarea&gt;        &lt;br&gt;        &lt;br&gt;        &lt;input type="checkbox" name="agree" value="agree" v-model="userInfo.agree"&gt;&lt;/input&gt;        阅读并接受&lt;a href="https://zhangqingguo.github.io/"&gt;《用户协议》&lt;/a&gt;        &lt;br&gt;        &lt;br&gt;        &lt;button type="submit"&gt;提交&lt;/button&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',        data: {            userInfo: {                userName: '',                password: '',                sex: '',                age: null,                hobby: [],                education: '',                birthday: '',                otherInfo: '',                agree: false            }        },        methods: {            submitForm(e) {                e.preventDefault();                console.log(this.userInfo.userName);                console.log(JSON.stringify(this.userInfo))            }        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="1-18-过滤器使用"><a href="#1-18-过滤器使用" class="headerlink" title="1.18 过滤器使用"></a>1.18 过滤器使用</h3><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p><strong>语法：</strong></p><ul><li>注册过滤器：<strong>Vue.filter(name,callback)</strong>   ==》全局过滤器  或 <strong>new Vue{filters:{}}</strong>  ==》局部过滤器</li><li>使用过滤器：{ { xxx | 过滤器名} } 或 v-bind:属性 = “xxx | 过滤器名”</li></ul><p>备注：</p><p>1.过滤器也可以接收额外参数、多个过滤器也可以串联</p><p>2.并没有改变原本的数据, 是产生新的对应的数据。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript" src="./js/dayjs.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h2&gt;显示格式化时间&lt;/h2&gt;    现在是：{{time}}&lt;br&gt;    &lt;!--计算属性--&gt;    现在是：{{formatTime}}&lt;br&gt;    &lt;!-- 方法--&gt;    现在是：{{getTime()}}&lt;br&gt;    &lt;!--过滤器--&gt;    现在是：{{time | timeFormater}}&lt;br&gt;    &lt;!--过滤器传参--&gt;    现在是：{{time | timeFormater('YYYY年MM月DD日 HH:mm:ss')}}&lt;br&gt;    &lt;!--多个过滤器串联使用--&gt;    现在是：{{time | timeFormater('YYYY年MM月DD日 HH:mm:ss') | strSplice(0,11)}}&lt;br&gt;    &lt;!--v-bind使用--&gt;    &lt;h3 :x="mag | strSplice(0,5)"&gt;zzz&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    // 全局 过滤器    Vue.filter('timeFormater', function (value, str = 'YYYY-MM-DD HH:mm:ss') {        return dayjs(value).format(str)    })    const vm = new Vue({        el: '#app',        data: {            time: Date.now(),            mag: 'hello world'        },        // 计算属性        computed: {            formatTime() {                return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')            }        },        // 方法        methods: {            getTime() {                return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')            }        },        // 局部的 过滤器        filters: {            timeFormater(value, str = 'YYYY-MM-DD HH:mm:ss') {                console.log('value=', value)                return dayjs(value).format(str)            },            strSplice(value, start, end) {                return value.substring(start, end)            }        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="1-19-内置指令"><a href="#1-19-内置指令" class="headerlink" title="1.19 内置指令"></a>1.19 内置指令</h3><p>已经学过的指令：</p><pre><code>v-bind:属性绑定,单向数据绑定，简写为 :xxxv-model:双向数据绑定v-on:事件绑定,监听，简写为 @v-if:条件渲染，动态控制节点是否存在v-else:条件渲染，动态控制节点是否存在v-show:条件渲染，动态控制节点是否显示v-for:循环渲染，遍历数组/对象/字符串</code></pre><p><strong>v-text指令：</strong></p><p>1.作用：向其所在的节点中渲染文本内容。</p><p>2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。</p><p><strong>v-html指令：</strong></p><p>1.作用：向指定节点中渲染包含html结构的内容。</p><p>2.与插值语法的区别：</p><p>v-html会替换掉节点中所有的内容，则不会。<br>v-html可以识别html结构。<br>3.严重注意：v-html有安全性问题！！！！</p><p>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p><p><strong>v-cloak指令：</strong></p><ul><li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li><li>使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题(未解析的模板，直接展示影响用户体验)。</li></ul><p><strong>v-once指令：</strong></p><ul><li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li><li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li></ul><p><strong>v-pre指令：</strong></p><ul><li>跳过其所在节点的编译过程</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src="./js/vue.js"&gt;&lt;/script&gt;    &lt;style&gt;        [v-cloak]{            display: none;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--v-bind:属性绑定,单向数据绑定，简写为 :xxxv-model:双向数据绑定v-on:事件绑定,监听，简写为 @v-if:条件渲染，动态控制节点是否存在v-else:条件渲染，动态控制节点是否存在v-show:条件渲染，动态控制节点是否显示v-for:循环渲染，遍历数组/对象/字符串v-text:文本绑定，v-html:html绑定，    1.作用：向指定节点中渲染包含html结构的内容。    2.与插值语法的区别：    v-html会替换掉节点中所有的内容，{{xx}}则不会。    v-html可以识别html结构。    3.严重注意：v-html有安全性问题！！！！    在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。    一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！--&gt;&lt;div id="app"&gt;    &lt;div&gt;hello, {{name}}&lt;/div&gt;    &lt;div v-text="name"&gt;&lt;/div&gt;    &lt;div v-html="msg"&gt;&lt;/div&gt;    &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt;&lt;hr&gt;    &lt;h2 v-once&gt;初始化数值num：{{num}}&lt;/h2&gt;    &lt;h2&gt;当前数值num：{{num}}&lt;/h2&gt;    &lt;button @click="num++"&gt;点我num++&lt;/button&gt;    &lt;hr&gt;    &lt;h2 v-pre&gt; 这是一个普通标签&lt;/h2&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    const vm = new Vue({        el: '#app',        data: {            msg: '&lt;h3&gt;hello vue&lt;/h3&gt;',            name: 'zhangsan',            num: 100        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="1-20-自定义指令"><a href="#1-20-自定义指令" class="headerlink" title="1.20 自定义指令"></a>1.20 自定义指令</h3><p>需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。</p><p>需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。</p><p>语法：</p><p><strong>局部指令：</strong></p><p>new Vue({</p><p>​directives:{指名:配置对象}             </p><p>})</p><p>或者</p><p>new Vue({</p><p>​directives:{指令名:回调函数}             </p><p>})</p><p><strong>全局指令：</strong>Vue.directive(指令名,配置对象) 或者 Vue.directive(指令名,回调函数)</p><p>配置对象中常用的3个回调：</p><ul><li>bind：指令与元素成功绑定时调用。</li><li>inserted：指令所在元素被插入页面时调用。</li><li>update：指令所在模板结构被重新解析时调用。</li></ul><p>备注：</p><ul><li><p>指令定义时不加v-，但使用时要加v-。</p></li><li><p>指令名如果是多个单词，要使用kebab-case命名方式，不要使用驼峰命名。</p></li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。--&gt;&lt;div id="app"&gt;    &lt;h3&gt;当前值：&lt;span v-text="num"&gt;&lt;/span&gt;&lt;/h3&gt;    &lt;h3 &gt;放大10倍：&lt;span v-big="num"&gt;&lt;/span&gt;&lt;/h3&gt;    &lt;h3 &gt;放大15倍：&lt;span v-big-number="num"&gt;&lt;/span&gt;&lt;/h3&gt;    &lt;button @click="num++"&gt;点我num++&lt;/button&gt;    &lt;br&gt;    &lt;input type="text" v-fbind:value="num"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;Vue.config.productionTip = false;// 全局自定义指令    Vue.directive('big', {        bind(el, binding){            el.innerText = binding.value * 10        }    })    Vue.directive('fbind', {        // 指令与元素成功绑定时（一上来）        bind(el, binding){            el.value = binding.value        },        // 指令所在元素被插入页面时        inserted(el){            el.focus()        },        // 指令所在的模板被重新解析时        update(el, binding){            el.value = binding.value        }    })    new Vue({        el: '#app',        data: {            num: 1        },        // 局部自定义指令        directives: {            //big函数什么时候调用：1.指令与元素成功绑定时（一上来）2.指令所在的模板被重新解析时            big(el, binding){                //this 是window                console.log('big',this);                // el是绑定指令的元素,真实的dom                console.log(el)                console.log(el instanceof HTMLElement)                el.innerText = binding.value * 10            },            'big-number'(el, binding){                el.innerText = binding.value * 15            },            fbind:{                bind(el, binding){                    el.value = binding.value                },                // 指令所在元素被插入页面时                inserted(el){                    el.focus()                },                update(el, binding){                    el.value = binding.value                }            }        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="1-21-生命周期"><a href="#1-21-生命周期" class="headerlink" title="1.21 生命周期"></a>1.21 生命周期</h3><p>先上图</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="life"></p><p><strong>beforeCreate（创建前）</strong>：数据监测(getter和setter)和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。<br><strong>created（创建后）</strong>：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el属性。<br><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。此阶段Vue开始解析模板，生成虚拟DOM存在内存中，还没有把虚拟DOM转换成真实DOM，插入页面中。所以网页不能显示解析好的内容。<br><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el（就是真实DOM的拷贝）替换，并挂载到实例上去之后调用（将内存中的虚拟DOM转为真实DOM，真实DOM插入页面）。此时页面中呈现的是经过Vue编译的DOM，这时在这个钩子函数中对DOM的操作可以有效，但要尽量避免。一般在这个阶段进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等等<br><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染（数据是新的，但页面是旧的，页面和数据没保持同步呢）。<br><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。在这个阶段一般进行关闭定时器，取消订阅消息，解绑自定义事件。（这个时候修改数据不会触发更新）<br><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器（Vue自定义的，dom原生的监听事件还在）会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</p><p>created之后：</p><p>先判断有没有 <strong>el</strong> 这个配置项，没有就调用 vm.$mount(el)，如果两个都没有就一直卡着，显示的界面就是最原始的容器的界面。有 <strong>el</strong> 这个配置项，就进行判断有没有 template 这个配置项，没有 template 就将 el 绑定的容器编译为 vue 模板。</p><p><strong>第一种情况，有 template：</strong></p><p>如果 el 绑定的容器没有任何内容，就一个空壳子，但在 Vue 实例中写了 template，就会编译解析这个 template 里的内容，生成虚拟 DOM，最后将 虚拟 DOM 转为 真实 DOM 插入页面（其实就可以理解为 template 替代了 el 绑定的容器的内容）。</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250415151131396.png" alt="image-20250415151131396"></p><p><strong>第二种情况，没有 template：</strong></p><p>没有 template，就编译解析 el 绑定的容器，生成虚拟 DOM，后面就顺着生命周期执行下去。</p><p>总结：</p><p><strong>常用生命周期钩子：</strong></p><p>1、mounted：发送ajax请求，启动定时器，绑定自定义事件，订阅消息【初始化操作】</p><p>2、beforeDestroy：清除定时器，解绑自定义事件，取消订阅消息等【收尾工作】</p><p><strong>关于销毁Vue实例</strong></p><p>1、销毁后借助Vue开发工具看不到任何信息。</p><p>2、销毁后自定义事件会失效，但是原生DOM事件依然有效。</p><p>3、一般不会在beforeDestroy操作数据，因为即使操作数据，也不会触发更新流程。</p><h3 id="1-21-非单文件组件"><a href="#1-21-非单文件组件" class="headerlink" title="1.21 非单文件组件"></a>1.21 非单文件组件</h3><p>组件的定义：实现应用中局部功能代码和资源的集合。</p><p>作用：复用编码，简化项目编码，提高运行效率。</p><p>非单文件组件：一个文件包含多个组件。</p><p>单文件组件：一个文件只包含1个组件。</p><p><strong>基本使用</strong><br>Vue中使用组件的三大步骤：</p><p>定义组件(创建组件)<br>注册组件<br>使用组件(写组件标签)</p><p><strong>定义组件</strong></p><p>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p><p>区别如下：</p><p>el不要写，为什么？ ———&gt; 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。<br>data必须写成函数（普通函数），为什么？ ————&gt; 避免组件被复用时，数据存在引用关系。</p><p>举例说明 data为什么要写成函数？</p><p>这是因为js底层设计的原因：</p><p>对象形式：</p><pre><code class="javascript">let data = {    a: 99,    b: 100}let x = data;let y = data;// x 和 y 引用的都是同一个对象，修改 x 的值， y 的值也会改变x.a = 66;console.log(x); // a:66 b:100console.log(y); // a:66 b:100</code></pre><p>函数形式：</p><pre><code class="javascript">function data() {    return {        a: 99,        b: 100    }}let x = data();let y = data();console.log(x === y); // false，调用函数，每次返回新的对象</code></pre><p>备注：使用template可以配置组件结构。</p><p><strong>注册组件</strong></p><ul><li>局部注册：靠new Vue的时候传入components选项</li><li>全局注册：靠Vue.component(‘组件名’,组件)</li></ul><p>几个注意点：<br>1、关于组件名：</p><p>一个单词组成：</p><p>第一种写法(首字母小写)：school<br>第二种写法(首字母大写)：School<br>多个单词组成：</p><p>第一种写法(kebab-case命名)：my-school<br>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</p><p>备注：</p><p>(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p><p>(2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p><p>2、关于组件标签</p><p>第一种写法：&lt;school&gt;&lt;/school&gt;</p><p>第二种写法：&lt;school/&gt;</p><p>备注：不使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。</p><p>3、一个简写方式：</p><p>const school = Vue.extend(options) 可简写为：const school = options</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h2&gt;{{msg}}&lt;/h2&gt;    &lt;hr&gt;    &lt;school&gt;&lt;/school&gt;    &lt;hr&gt;    &lt;person&gt;&lt;/person&gt;    &lt;hr&gt;    &lt;student&gt;&lt;/student&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    // 简写 组件    const student = {        template: `            &lt;div&gt;                &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;                &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;                &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;                &lt;button @click="showInfo"&gt;点我提示学生姓名&lt;/button&gt;            &lt;/div&gt;        `,        data() {            return {                name: '李四',                age: 19,                sex: '女'            }        },        methods: {            showInfo(){                alert(this.name)            }        }    }    const school = Vue.extend({        template: `            &lt;div&gt;                &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;                &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;                &lt;button @click="showSchool"&gt;点我提示学校名称&lt;/button&gt;            &lt;/div&gt;        `,        data() {            return {                name: '圣芙蕾雅',                address: '极东'            }        },        methods: {            showSchool() {                alert(this.name)            }        }    })    const person = Vue.extend({        template: `            &lt;div&gt;                &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;                &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;                &lt;h2&gt;性别：{{sex}}&lt;/h2&gt;                &lt;button @click="showInfo"&gt;点我提示姓名&lt;/button&gt;            &lt;/div&gt;        `,        data() {            return {                name: '张三',                age: 18,                sex: '男'            }        },        methods: {            showInfo(){                alert(this.name)            }        }    })    // 全局注册组件    Vue.component('student', student)    Vue.component('school', school)    Vue.component('person', person)    new Vue({        el: '#app',        data: {            msg: '你好啊'        },        // 局部 注册组件        // components: {        //    school: school,        //    person: person        //   // ES6简写形式        //   school,        //   student        // }    })&lt;/script&gt;&lt;/html&gt;</code></pre><p>组件嵌套：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    // 简写 组件    const student = {        template: `            &lt;div&gt;                &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;                &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;                &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;                &lt;button @click="showInfo"&gt;点我提示学生姓名&lt;/button&gt;            &lt;/div&gt;        `,        data() {            return {                name: '李四',                age: 19,                sex: '女'            }        },        methods: {            showInfo(){                alert(this.name)            }        }    }    const school = Vue.extend({        template: `            &lt;div&gt;                &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;                &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;                &lt;student&gt;&lt;/student&gt;                &lt;button @click="showSchool"&gt;点我提示学校名称&lt;/button&gt;            &lt;/div&gt;        `,        data() {            return {                name: '圣芙蕾雅',                address: '极东'            }        },        components:{            student        },        methods: {            showSchool() {                alert(this.name)            }        }    })    const myAddress = Vue.extend({        template: `            &lt;div&gt;                &lt;h2&gt;地址：{{address}}&lt;/h2&gt;            &lt;/div&gt;        `,        data() {            return {                address: '神州'            }        }    })    const person = Vue.extend({        template: `            &lt;div&gt;                &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;                &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;                &lt;h2&gt;性别：{{sex}}&lt;/h2&gt;                &lt;my-address&gt;&lt;/my-address&gt;                &lt;button @click="showInfo"&gt;点我提示姓名&lt;/button&gt;            &lt;/div&gt;        `,        data() {            return {                name: '张三',                age: 18,                sex: '男'            }        },        components: {            'my-address': myAddress        },        methods: {            showInfo(){                alert(this.name)            }        }    })    const app = {        template: `            &lt;div&gt;                &lt;h2&gt;{{msg}}&lt;/h2&gt;                &lt;hr&gt;                &lt;school&gt;&lt;/school&gt;                &lt;hr&gt;                &lt;person&gt;                &lt;/person&gt;                &lt;hr&gt;            &lt;/div&gt;        `,        data() {            return {                msg: '你好啊'            }        },        components: {            school,            person        },    }    const vm = new Vue({        el: '#app',        template: '&lt;app&gt;&lt;/app&gt;',        components: {            app        }    })    &lt;/script&gt;&lt;/html&gt;</code></pre><p><strong>VueComponent</strong><br>1、school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。<br>2、我们只需要写或，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。<br>3、特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！(这个VueComponent可不是实例对象)<br>4、关于this指向：<br>    组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。<br>    new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。<br>5、VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。</p><p><strong>一个重要的内置关系</strong></p><ul><li>一个重要的内置关系：VueComponent.prototype._proto_=== Vue.prototype</li><li>为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</li></ul><h3 id="1-22-单文件组件"><a href="#1-22-单文件组件" class="headerlink" title="1.22 单文件组件"></a>1.22 单文件组件</h3><p>单文件组件就是将一个组件的代码写在 .vue 这种格式的文件中，webpack 会将 .vue 文件解析成 html,css,js这些形式。</p><h2 id="2、vue脚手架，自定义事件，插槽等复杂内容"><a href="#2、vue脚手架，自定义事件，插槽等复杂内容" class="headerlink" title="2、vue脚手架，自定义事件，插槽等复杂内容"></a>2、vue脚手架，自定义事件，插槽等复杂内容</h2><h3 id="2-1-脚手架"><a href="#2-1-脚手架" class="headerlink" title="2.1 脚手架"></a>2.1 脚手架</h3><p>使用前置：</p><p>第一步(没有安装过的执行)：全局安装 @vue/cli</p><p>npm install -g @vue/cli</p><p>第二步：切换到要创建项目的目录，然后使用命令创建项目</p><p>vue create xxxxx</p><p>第三步：启动项目</p><p>npm run serve</p><p><strong>脚手架文件结构</strong></p><pre><code class="txt">├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><p>import Vue，不需要加文件路径，脚手架已经处理好了， package.json文件中的module指定了具体引入的文件。</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250502200345172.png" alt="image-20250502200345172"></p><p>main.js入口文件：</p><pre><code class="javascript">/** * 整个项目的入口文件 *///引入Vue(vue.runtime.esm.js，精简版，不包含模板解析器)import Vue from 'vue'//引入App组件，它是所有组件的父组件import App from './App.vue'//关闭Vue的生产提示Vue.config.productionTip = false/** * vue.js与vue.runtime.xxx.js的区别： * vue.js是完整版的Vue，包含：核心功能+模板解析器。 * vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。 * 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。 *///创建Vue实例对象new Vue({  //将app组件，渲染到#app容器中  //render: h =&gt; h(App),  //完整写法  render(crateElement){    console.log(typeof crateElement)    return crateElement(App)  }}).$mount('#app')</code></pre><p><strong>render函数</strong></p><p>为什么要使用render函数？</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250504174642814.png" alt="image-20250504174642814"></p><p>这样template写法会报错：</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250504175136022.png" alt="image-20250504175136022"></p><p>所以，要么使用完整版本的Vue，要么使用运行版本Vue提供的render函数，否则无法解析编译模板。</p><pre><code class="javascript">//完整的render函数写法render(crateElement){     return crateElement(App)}</code></pre><p>因为 render 函数内并没有用到 this，所以可以简写成箭头函数。只有一个参数就可以把圆括号去了，函数体内部只有一个 return 就可以把大括号去掉，return去掉，最后简写成：render: h =&gt; h(App)</p><pre><code class="javascript">new Vue({  render: h =&gt; h(App),}).$mount('#app')</code></pre><p><strong>不同版本 vue 的区别</strong></p><p>vue.js与vue.runtime.xxx.js的区别：<br>vue.js是完整版的Vue，包含：核心功能+模板解析器。<br>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。<br>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。</p><p><strong>修改脚手架的默认配置</strong></p><ul><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ul><p><strong>脚手架中的index页面</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=""&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;!--  针对IE浏览器的兼容性     --&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;!--   开启移动端的理想视口   --&gt;    &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;&lt;!--配置页签图标，BASE_URL值是public目录--&gt;    &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;&lt;!--配置网页标题--&gt;    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 当浏览器不支持js，标签内容会被渲染 --&gt;    &lt;noscript&gt;      &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;    &lt;/noscript&gt;    &lt;!-- 挂载点，容器 --&gt;    &lt;div id="app"&gt;&lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2-2-vue的其他知识"><a href="#2-2-vue的其他知识" class="headerlink" title="2.2 vue的其他知识"></a>2.2 vue的其他知识</h3><h4 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a><strong>ref属性</strong></h4><p>1、被用来给元素或子组件注册引用信息（id的替代者）<br>2、<strong>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</strong><br>3、使用方式：<br>    打标识：&lt;h1 ref=”xxx”&gt;…..&lt;/h1&gt;或 &lt;School ref=”xxx”&gt;&lt;/School&gt;<br>    获取：this.$refs.xxx</p><h4 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h4><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name="xxx"/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:['name']</code></p></li><li><p>第二种方式（限制类型）：<code>props:{name:String}</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）   </p><pre><code class="javascript">props:{ ​name:{       type:String, //类型           required:true, //必要性          default:'老王' //默认值 ​} }</code></pre></li></ol></li></ol><p>备注：</p><p>1.props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据</p><p>2.属性名不要使用已有的关键名字，如key，ref等</p><h4 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h4><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><p><strong>定义混入</strong></p><pre><code class="javascript">export const mixin = {    methods: {        showName() {            alert(this.name)        }    },    mounted() {        console.log('mixin mounted')    }}export const mixin2 = {    data() {        return {            x: 100,            y: 200        }    }}</code></pre><p><strong>使用混入</strong></p><p>1、局部混入：</p><pre><code class="vue">&lt;script&gt;import {mixin,mixin2} from '../mixin'export default {  name: 'SchoolInfo',  data() {    return {      name: '折纸大学',      address: '匹诺康尼'    }  },  mixins: [mixin, mixin2]}&lt;/script&gt;</code></pre><p>2、全局混入：不建议使用，会导致整个Vue，组件都引入了混入的配置。</p><p>在main.js中引入使用。</p><pre><code class="javascript">//全局混入import {mixin,mixin2} from "@/mixin";Vue.mixin(mixin)Vue.mixin(mixin2)</code></pre><p><strong>选项合并</strong></p><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p><p>1、数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</p><p>2、同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p><p>3、值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制。</p><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成。</p><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p><p><strong>定义插件：</strong></p><pre><code class="javascript">export default  {    install(Vue,y){        // y是自定义参数        console.log('插件被调用了', Vue,y)        Vue.filter('filterName', function(value) {            return value.slice(0,2)        })        Vue.mixin({            data() {                return {                    x: 100                }            }        })        Vue.directive('fbind', {            bind(el, binding) {                el.value = binding.value            },            inserted(el) {                el.focus()            },            update(el,binding) {                el.value = binding.value            }        })        //给Vue原型上添加一个方法，vm和vc都可以使用        Vue.prototype.hello = function() {            alert('你好啊')        }    }}</code></pre><p><strong>引入使用插件：</strong></p><p>在main.js中：</p><pre><code class="javascript">import MyPlugins from './plugins.js'//调用MyPlugins.install方法,可以带自定义参数Vue.use(MyPlugins,111)</code></pre><p>这样就可以在组件里使用插件里面的功能了。</p><h4 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h4><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><p>style里面的lang指定语言，css,less等</p><h4 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h4><p>组件化编码流程：</p><p> (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p> (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p> 1).一个组件在用：放在组件自身即可。</p><p> 2). 一些组件在用：放在他们共同的父组件上（状态提升）。</p><p> (3).实现交互：从绑定事件开始。</p><p>props适用于：</p><p> (1).父组件 ==&gt; 子组件 通信</p><p> (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p><h3 id="2-3-浏览器本地存储"><a href="#2-3-浏览器本地存储" class="headerlink" title="2.3 浏览器本地存储"></a>2.3 浏览器本地存储</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。</p><p><strong>Cookie的特性：</strong></p><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去</li></ul><p><strong>Cookie 在身份认证中的作用</strong></p><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中。</p><p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份。</p><p><strong>Cookie 不具有安全性</strong></p><p>由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。</p><blockquote><p>注意：千万不要使用 Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等。</p></blockquote><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了session是一种特殊的cookie。cookie是保存在客户端的，而session是保存在服务端。</p><p><strong>为什么要用session</strong> 由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了</p><p><strong>session原理</strong> 当客户端第一次请求服务器的时候，服务器生成一份session保存在服务端，将该数据(session)的id以cookie的形式传递给客户端；以后的每次请求，浏览器都会自动的携带cookie来访问服务器(session数据id)。</p><h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p><p><strong>LocalStorage的优点：</strong></p><ul><li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li><li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li><li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li></ul><p><strong>LocalStorage的缺点：</strong></p><ul><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li><li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li><li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li></ul><p><strong>LocalStorage的使用场景:</strong></p><ul><li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li><li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li></ul><h4 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p><p><strong>SessionStorage与LocalStorage对比：</strong></p><ul><li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li><li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li><li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li></ul><p>总结：</p><p>WebStorage</p><p>1、存储大小一般支持5MB（不同浏览器可能不一样）</p><p>2、浏览器通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制。</p><p>3、相关API：</p><p>localStorage：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;localStorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;localStorage&lt;/h2&gt;&lt;button onclick="setLocalStorage()"&gt;设置localStorage&lt;/button&gt;&lt;button onclick="getLocalStorage()"&gt;获取localStorage&lt;/button&gt;&lt;button onclick="removeLocalStorage()"&gt;删除localStorage&lt;/button&gt;&lt;button onclick="clearLocalStorage()"&gt;清空localStorage&lt;/button&gt;&lt;script type="text/javascript"&gt;    function setLocalStorage() {        //setItem的第二个参数是string，会调用toSting方法        let p = {name: '张三', age: 18, sex: '男'};        localStorage.setItem('msg', 'hhhhhh2');        localStorage.setItem('n', 18);        localStorage.setItem('person', JSON.stringify(p));        localStorage.setItem('person2', p);    }    function getLocalStorage() {        console.log(localStorage.getItem('msg'));        console.log(localStorage.getItem('n'));        console.log(localStorage.getItem('person'));        console.log(JSON.parse(localStorage.getItem('person')));    }    function removeLocalStorage() {        localStorage.removeItem('msg');        localStorage.removeItem('n');        localStorage.removeItem('person');        localStorage.removeItem('person2');    }    function clearLocalStorage() {        localStorage.clear();    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>sessionStorage：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;sessionStorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;sessionStorage&lt;/h2&gt;&lt;button onclick="setSessionStorage()"&gt;设置sessionStorage&lt;/button&gt;&lt;button onclick="getSessionStorage()"&gt;获取sessionStorage&lt;/button&gt;&lt;button onclick="removeSessionStorage()"&gt;删除sessionStorage&lt;/button&gt;&lt;button onclick="clearSessionStorage()"&gt;清空sessionStorage&lt;/button&gt;&lt;script type="text/javascript"&gt;    function setSessionStorage() {        //setItem的第二个参数是string，会调用toSting方法        let p = {name: '张三', age: 18, sex: '男'};        sessionStorage.setItem('msg', 'hhhhhh2');        sessionStorage.setItem('n', 18);        sessionStorage.setItem('person', JSON.stringify(p));        sessionStorage.setItem('person2', p);    }    function getSessionStorage() {        console.log(sessionStorage.getItem('msg'));        console.log(sessionStorage.getItem('n'));        console.log(sessionStorage.getItem('person'));        console.log(JSON.parse(sessionStorage.getItem('person')));    }    function removeSessionStorage() {        sessionStorage.removeItem('msg');        sessionStorage.removeItem('n');        sessionStorage.removeItem('person');        sessionStorage.removeItem('person2');    }    function clearSessionStorage() {        sessionStorage.clear();    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>4、备注：</p><ol><li>sessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>localStorage存储的内容需要手动清除才会消失。</li><li>getItem(key)，获取不到key对应的value值，返回null。</li><li>JSON.parse(null)结果是null。</li></ol><h3 id="2-4-组件自定义事件"><a href="#2-4-组件自定义事件" class="headerlink" title="2.4 组件自定义事件"></a>2.4 组件自定义事件</h3><p>组件自定义事件是一种组件间通信的方式，适用于：<strong>子组件 ===&gt; 父组件</strong></p><p><strong>使用场景</strong></p><p>A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<strong>事件的回调在A中</strong>），B触发自定义事件。</p><p>给谁绑定事件，就找谁触发事件。</p><p><strong>绑定自定义事件：</strong></p><p>第一种方式，在父组件中：<code>&lt;StudentInfo v-on:zqg="getStudentName"/&gt;</code>或 <code>&lt;StudentInfo @zqg="getStudentName"/&gt;</code></p><p>第二种方式，在父组件中：</p><p>使用 <code>this.$refs.xxx.$on()</code> 这样写起来更灵活，比如可以加定时器。this.$refs.xxx.$once()，只调用一次。</p><p>App.vue ，给student组件绑定自定义事件：<code>zqg</code></p><pre><code class="vue">&lt;StudentInfo ref="student" @click.native="show"&gt;&lt;/StudentInfo&gt;...methods: {  //可以声明接收多个参数，也可以指定一个参数，其他参数全部存到params数组中  getStudentName(name, ...params) {    console.log('app getStudentName receive:', name, params)  }}mounted() {   this.$refs.student.$on('zqg', this.getStudentName) }</code></pre><p>Student.vue  触发<code>zqg</code>事件</p><pre><code class="vue">&lt;button @click="sendStudentName"&gt;点我发送学生姓名&lt;/button&gt;...methods: {    sendStudentName() {      //  触发组件实例的zqg事件      this.$emit('zqg',this.name)    }}</code></pre><p><strong>解绑自定义事件</strong>：<code>this.$off('zqg')</code>==》解绑一个, <code>this.$off('xx','yy')</code>==》解绑多个，<code>this.$off()</code>==》解绑所有</p><p><strong>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</strong></p><p><code>&lt;StudentInfo ref="student" @click.native="show"&gt;&lt;/StudentInfo&gt;</code></p><p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调要么<strong>配置在methods中，要么用箭头函数</strong>，否则this指向会出问题！（使用普通函数，this是触发事件的组件的实例对象）</p><p>举例：下面写法不行，无法给app的studentName赋值，因为this指向不对</p><pre><code class="vue">//回调是普通函数，this指向student实例对象, this.studentName = name 会出问题，这种写法不行this.$refs.student.$on('zqg', function (name){  console.log('app mounted $refs receive:', name)  this.studentName = name  console.log(this)//this指向student实例对象})</code></pre><p>可以的写法：</p><pre><code class="vue">//回调是箭头函数，没有this，往外找，找到app实例，this.studentName = name 成功this.$refs.student.$on('zqg', (name) =&gt; {  console.log('app mounted $refs receive:', name)  this.studentName = name  console.log(this)//this指向app实例对象})</code></pre><p>或者：</p><pre><code class="vue">methods: {  getSchoolName(name) {    console.log('app getSchoolName receive:', name)  },  //可以声明接收多个参数，也可以指定一个参数，其他参数全部存到params数组中  getStudentName(name, ...params) {    console.log('app getStudentName receive:', name, params)  }} mounted() {    // this.getStudentName，传入app实例对象的method的函数，会以app的函数为准，不会出现问题    this.$refs.student.$on('zqg', this.getStudentName)  }</code></pre><h3 id="2-5-全局事件总线（GlobalEventBus）"><a href="#2-5-全局事件总线（GlobalEventBus）" class="headerlink" title="2.5 全局事件总线（GlobalEventBus）"></a>2.5 全局事件总线（GlobalEventBus）</h3><p>1、一种组件间通信的方式，适用于任意组件间通信。</p><p>2、安装全局事件总线：</p><pre><code class="vue">new Vue({    ......    beforeCreate() {        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm    },    ......}) </code></pre><p>3、使用事件总线：</p><p>  1、接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。</p><pre><code class="vue">methods(){  demo(data){......}}......mounted() {  this.$bus.$on('xxxx',this.demo)}</code></pre><p>​      2、提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p><p>4、最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。</p><h3 id="2-6-消息订阅与发布"><a href="#2-6-消息订阅与发布" class="headerlink" title="2.6 消息订阅与发布"></a>2.6 消息订阅与发布</h3><ol><li><p>一种组件间通信的方式，适用于任意组件间通信。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from 'pubsub-js'</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。</p><pre><code class="vue">methods:{  demo(data){......}}......mounted() {  this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息}</code></pre></li><li><p>提供数据：<code>pubsub.publish('xxx',数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去取消订阅。</p></li></ol><h3 id="2-7-nextTick"><a href="#2-7-nextTick" class="headerlink" title="2.7 nextTick"></a>2.7 nextTick</h3><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><pre><code class="vue">// 在dom节点更新完后，执行设置焦点this.$nextTick(() =&gt; {  this.$refs.inputText.focus();});</code></pre></li></ol><h3 id="2-8-Vue封装的过度与动画"><a href="#2-8-Vue封装的过度与动画" class="headerlink" title="2.8 Vue封装的过度与动画"></a>2.8 Vue封装的过度与动画</h3><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250523105250111.png" alt="image-20250523105250111"></p><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过渡的元素，并配置name属性：</p><pre><code class="vue">&lt;transition name="hello"&gt;    &lt;h1 v-show="isShow"&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt;</code></pre><p>name 的作用可以让让不同的元素有不同的动画效果，用name区分开不同元素的样式。指定了name后，样式名称要改成 xxx-enter, 比如hello-enter-active</p></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p><p>appear属性，作用是一开始进入就展示动画效果。</p></li></ol></li><li><p>具体案例</p><p>单个元素动画</p><pre><code class="vue">&lt;script&gt;export default {  name: 'MyTest',  data() {    return {      isShow: true    }  },}&lt;/script&gt;&lt;template&gt;&lt;div&gt;  &lt;button @click="isShow = !isShow"&gt;显示/隐藏&lt;/button&gt;&lt;!--  &lt;h2 v-show="isShow" class="go"&gt;bcym&lt;/h2&gt;--&gt;  &lt;transition name="hello" appear&gt;    &lt;h2 v-show="isShow"&gt;bcym&lt;/h2&gt;  &lt;/transition&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;h2 {  background: orange;}.hello-enter-active{  animation: mymove 1s linear;}.hello-leave-active {  animation: mymove 1s reverse linear;}.come{  animation: mymove 1s;}.go{  animation: mymove 1s reverse;}@keyframes mymove {  from {    margin-left: 0px;    transform: translateX(-100%);  }  to {    margin-left: 200px;    transform: translateX(0px);  }}&lt;/style&gt;</code></pre><p>已经有了动画，想要借助Vue实现，那么用<code>&lt;transition&gt;</code>标签包裹，同时在v-enter-active，v-leave-active配置好已有的动画。</p><p>单个元素过度：</p><pre><code class="vue">&lt;script&gt;export default {  name: 'MyTest',  data() {    return {      isShow: true    }  },}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click="isShow = !isShow"&gt;显示/隐藏&lt;/button&gt;    &lt;transition name="hello" appear&gt;      &lt;h2 v-show="isShow"&gt;bcym&lt;/h2&gt;    &lt;/transition&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;h2 {  background: orange;}/**进入的起点,离开的终点 */.hello-enter,.hello-leave-to {  transform: translateX(-100%);}.hello-enter-active,.hello-leave-active {  transition: 0.5s linear;}/**进入的终点，离开的起点 */.hello-enter-to,.hello-leave {  transform: translateX(0);}&lt;/style&gt;</code></pre><p>没有写好的动画，想要靠过度实现动画效果，进入的起点，终点，离开的起点、终点，还有过程中，都要配置好。</p><p>多个元素过度：</p><pre><code class="vue">&lt;script&gt;export default {  name: 'MyTest',  data() {    return {      isShow: true    }  },}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click="isShow = !isShow"&gt;显示/隐藏&lt;/button&gt;    &lt;transition-group name="hello" appear&gt;      &lt;h2 v-show="!isShow" key="1"&gt;zqg&lt;/h2&gt;      &lt;h2 v-show="isShow" key="2"&gt;bcym&lt;/h2&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;h2 {  background: orange;}/**进入的起点,离开的终点 */.hello-enter,.hello-leave-to {  transform: translateX(-100%);}.hello-enter-active,.hello-leave-active {  transition: 0.5s linear;}/**进入的终点，离开的起点 */.hello-enter-to,.hello-leave {  transform: translateX(0);}&lt;/style&gt;</code></pre></li></ol><p>导入第三方库：<a href="https://animate.style/">Animate.css | A cross-browser library of CSS animations.</a>。需要安装<code>npm install animate.css</code>、导入<code>import 'animate.css'</code>，然后使用。指定name，配置进入，离开等的clas。</p><pre><code class="vue">&lt;script&gt;import 'animate.css'export default {  name: 'MyTest',  data() {    return {      isShow: true    }  },}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click="isShow = !isShow"&gt;显示/隐藏&lt;/button&gt;    &lt;transition-group name="animate__animated animate__bounce"                      enter-active-class="animate__swing"                      leave-active-class="animate__backOutUp"                      appear&gt;      &lt;h2 v-show="!isShow" key="1"&gt;zqg&lt;/h2&gt;      &lt;h2 v-show="isShow" key="2"&gt;bcym&lt;/h2&gt;    &lt;/transition-group&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;h2 {  background: orange;}&lt;/style&gt;</code></pre><h3 id="2-9-vue脚手架配置代理"><a href="#2-9-vue脚手架配置代理" class="headerlink" title="2.9 vue脚手架配置代理"></a>2.9 vue脚手架配置代理</h3><p>跨域问题：</p><p>1、服务器返回响应时添加cors的特殊响应头</p><p>2、jsonp，利用script 的src，只能解决get请求，不常用。</p><p>3、使用代理服务器，（让代理服务器和浏览器同源，不会有跨域问题，然后中转一下真实服务器返回的数据。常见代理有：nginx，vue-cli、vite等</p><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250523144159375.png" alt="image-20250523144159375"></p><p>注意：<strong>代理服务器和前端开发服务器确实需要监听同一个端口（如8080），但不会冲突</strong>，因为它们实际上是同一个服务器提供的两种功能。关键点：代理服务器是前端服务器的一部分。</p><p>❌ <strong>误区</strong>：”配置了proxy就是启动了一个独立代理服务器”<br>✅ <strong>事实</strong>：proxy只是开发服务器的一个功能，没有额外端口占用</p><p>❌ <strong>误区</strong>：”proxy配置的目标服务器就是代理服务器”<br>✅ <strong>事实</strong>：目标服务器是你的后端API服务，不是代理服务器</p><p><strong>使用脚手架配置代理服务器：</strong></p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p> 在vue.config.js中添加如下配置：</p><pre><code class="javascript">devServer:{  proxy:"http://localhost:5000"}</code></pre><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p> 编写vue.config.js配置具体代理规则：</p><pre><code class="javascript">module.exports = {    devServer: {    proxy: {      '/api1': {// 匹配所有以 '/api1'开头的请求路径        target: 'http://localhost:5000',// 代理目标的基础路径        changeOrigin: true,        pathRewrite: {'^/api1': ''}//代理服务器将请求地址转给真实服务器时会将 /api1 去掉      },      '/api2': {// 匹配所有以 '/api2'开头的请求路径        target: 'http://localhost:5001',// 代理目标的基础路径        changeOrigin: true, //控制请求头中host的值        pathRewrite: {'^/api2': ''},        ws: true//  支持代理websocket      }    }  }}/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080   changeOrigin默认值为true*/</code></pre><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h3 id="2-10-插槽"><a href="#2-10-插槽" class="headerlink" title="2.10 插槽"></a>2.10 插槽</h3><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong>父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽named slot、作用域插槽<strong>scoped slot</strong></p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><pre><code class="vue">父组件中：        &lt;Category&gt;           &lt;div&gt;html结构1&lt;/div&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>具名插槽：</p><pre><code class="vue">父组件中：        &lt;Category&gt;            &lt;template slot="center"&gt;              &lt;div&gt;html结构1&lt;/div&gt;            &lt;/template&gt;            &lt;template v-slot:footer&gt;               &lt;div&gt;html结构2&lt;/div&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;               &lt;!-- 定义插槽 --&gt;               &lt;slot name="center"&gt;插槽默认内容...&lt;/slot&gt;               &lt;slot name="footer"&gt;插槽默认内容...&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;</code></pre></li><li><p>作用域插槽：</p><ol><li><p>理解：<strong>数据在组件的自身（子组件），但根据数据生成的结构需要组件的使用者（父组件）来决定</strong>。（games数据在Category（子）组件中，但使用数据所遍历出来的结构由App（父）组件决定）。</p></li><li><p>具体编码：</p><pre><code class="vue">父组件中：        &lt;Category&gt;            &lt;template scope="scopeData"&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ul&gt;                    &lt;li v-for="g in scopeData.games" :key="g"&gt;{{g}}&lt;/li&gt;                &lt;/ul&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template slot-scope="{games}"&gt;                &lt;!-- 生成的是ul列表 --&gt;                &lt;ol&gt;                    &lt;li v-for="g in games" :key="g"&gt;{{g}}&lt;/li&gt;                &lt;/ol&gt;            &lt;/template&gt;        &lt;/Category&gt;        &lt;Category&gt;            &lt;template  v-slot="scopeData"&gt;                &lt;!-- 生成的是h4标题 --&gt;                &lt;h4 v-for="g in scopeData.games" :key="g"&gt;{{g}}&lt;/h4&gt;            &lt;/template&gt;        &lt;/Category&gt;子组件中：        &lt;template&gt;            &lt;div&gt;            &lt;!-- 通过数据绑定就可以把子组件的数据传到父组件 --&gt;                &lt;slot :games="games"&gt;&lt;/slot&gt;            &lt;/div&gt;        &lt;/template&gt;                &lt;script&gt;            export default {                name:'Category',                props:['title'],                //数据在子组件自身                data() {                    return {                        games:['红色警戒','穿越火线','劲舞团','超级玛丽']                    }                },            }        &lt;/script&gt;</code></pre></li></ol></li></ol></li></ol><p>注意： <code>scope</code> 属性在 Vue 2.x 中已经被废弃，推荐使用 <code>slot-scope</code>。使用 <code>v-slot</code>（Vue 2.6.0+ 推荐，包括Vue 3.x）。在 Vue 3 中，<code>v-slot</code> 是唯一支持的语法。作用域插槽也可以指定名字。</p><p><strong><code>v-slot="{ games }"</code>（解构赋值）</strong></p><p>✅ <strong>作用</strong>：直接从插槽的 <code>props</code> 对象中解构出 <code>games</code> 属性，并直接在模板中使用 <code>games</code>。<br>✅ <strong>适用场景</strong>：当只需要 <code>games</code> 数据，而不关心插槽提供的其他属性时。</p><p><strong><code>v-slot="scopeData"</code>（访问对象属性）</strong></p><p>✅ <strong>作用</strong>：接收整个插槽的 <code>props</code> 对象（假设命名为 <code>scopeData</code>），然后通过 <code>scopeData.games</code> 访问具体数据。<br>✅ <strong>适用场景</strong>：当需要访问插槽提供的多个属性时。</p><h2 id="3-Vuex"><a href="#3-Vuex" class="headerlink" title="3.Vuex"></a>3.Vuex</h2><p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"></p><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p> 在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="3-2-何时使用？"><a href="#3-2-何时使用？" class="headerlink" title="3.2 何时使用？"></a>3.2 何时使用？</h3><p> 多个组件需要共享数据时</p><h3 id="3-3-搭建vuex环境"><a href="#3-3-搭建vuex环境" class="headerlink" title="3.3 搭建vuex环境"></a>3.3 搭建vuex环境</h3><p>先安装<code> npm i vuex@3</code>,  注意，Vue2.x使用的Vuex是3.x版本，Vue3使用Vuex4版本。</p><ol><li><p>创建文件：<code>src/store/index.js</code></p><pre><code class="javascript">//引入Vue核心库import Vue from 'vue'//引入Vueximport Vuex from 'vuex'//应用Vuex插件,必须在创建store实例之前使用Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = {}//准备mutations对象——修改state中的数据const mutations = {}//准备state对象——保存具体的数据const state = {}//创建并暴露storeexport default new Vuex.Store({    actions,    mutations,    state})</code></pre></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><pre><code class="javascript">......//引入storeimport store from './store'......//创建vmnew Vue({    el:'#app',    render: h =&gt; h(App),    store})</code></pre></li></ol><h3 id="3-4-基本使用"><a href="#3-4-基本使用" class="headerlink" title="3.4 基本使用"></a>3.4 基本使用</h3><p>store.js</p><pre><code class="javascript">import Vue from 'vue'import Vuex from 'vuex'//  使用vuex，必须在创建store实例之前使用Vue.use(Vuex)// 定义actions,mutations,stateconst actions = {  // add(context, value) {  //   context.commit('ADD', value)  // },  // minus(context, value){  //   context.commit('MINUS', value)  // },  addOdd(context, value){    if(context.state.count % 2){      context.commit('ADD', value)    }  },  addWait(context, value){    setTimeout(() =&gt; {      context.commit('ADD', value)    }, 1000)  }}const mutations = {  ADD(state, value) {    state.count += value  },  MINUS(state, value) {    state.count -= value  },}const state = {  count: 0,}// 创建,并导出 store 实例export default new Vuex.Store({  actions,  mutations,  state})</code></pre><ol><li>组件中读取vuex中的数据：<code>$store.state.count</code></li><li>组件中修改vuex中的数据：<code>$store.dispatch('action中的方法名',数据)</code>或 <code>$store.commit('mutations中的方法名',数据)</code></li><li>备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code>也是可以的。</li></ol><p>Count.vue</p><pre><code class="vue">&lt;script&gt;export default {  name: "MyCount",  data() {    return {      num: 1    }  },  methods: {    increment() {     // this.$store.dispatch('add', this.num)      //没有业务逻辑，直接提交      this.$store.commit('ADD', this.num)    },    decrement() {      //this.$store.dispatch('minus', this.num)      this.$store.commit('MINUS', this.num)    },    incrementOdd() {      //业务逻辑，写在store中      this.$store.dispatch('addOdd', this.num)      // if (this.$store.state.count % 2) {      //   this.$store.dispatch('add', this.num)      // }    },    incrementWait() {      this.$store.dispatch('addWait', this.num)      // setTimeout(() =&gt; {      //   this.$store.dispatch('add', this.num)      // }, 1000)    }  }}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;当前和为：{{ $store.state.count }}&lt;/h1&gt;    &lt;select v-model.number="num"&gt;      &lt;option value="1"&gt;1&lt;/option&gt;      &lt;option value="2"&gt;2&lt;/option&gt;      &lt;option value="3"&gt;3&lt;/option&gt;    &lt;/select&gt;    &lt;button @click="increment"&gt;+&lt;/button&gt;    &lt;button @click="decrement"&gt;-&lt;/button&gt;    &lt;button @click="incrementOdd"&gt;当前和为奇数，则执行加法&lt;/button&gt;    &lt;button @click="incrementWait"&gt;等一等再加&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;button  {  margin: 0 10px;}&lt;/style&gt;</code></pre><h3 id="3-5-getters的使用"><a href="#3-5-getters的使用" class="headerlink" title="3.5 getters的使用"></a>3.5 getters的使用</h3><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><pre><code>......const getters = {    bigSum(state){        return state.sum * 10    }}//创建并暴露storeexport default new Vuex.Store({    ......    getters})</code></pre></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="3-6-四个map方法的使用"><a href="#3-6-四个map方法的使用" class="headerlink" title="3.6 四个map方法的使用"></a>3.6 四个map方法的使用</h3><p>导入</p><pre><code>import {mapState, mapGetters, mapActions, mapMutations} from 'vuex'</code></pre><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><pre><code class="vue">computed: {    //借助mapState生成计算属性：sum、school、subject（对象写法）     ...mapState({sum:'sum',school:'school',subject:'subject'}),             //借助mapState生成计算属性：sum、school、subject（数组写法）    ...mapState(['sum','school','subject']),},</code></pre></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><pre><code class="vue">computed: {    //借助mapGetters生成计算属性：bigSum（对象写法）    ...mapGetters({bigSum:'bigSum'}),    //借助mapGetters生成计算属性：bigSum（数组写法）    ...mapGetters(['bigSum'])},</code></pre></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><pre><code class="vue">methods:{    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    ...mapActions(['jiaOdd','jiaWait'])}</code></pre></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><pre><code class="vue">methods:{    //靠mapActions生成：increment、decrement（对象形式）    ...mapMutations({increment:'JIA',decrement:'JIAN'}),        //靠mapMutations生成：JIA、JIAN（对象形式）    ...mapMutations(['JIA','JIAN']),}</code></pre></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则传的参数是事件对象(event)。</p></blockquote><p>Count.vue</p><pre><code class="vue">&lt;script&gt;import { mapState,mapGetters,mapMutations,mapActions } from 'vuex'export default {  name: "MyCount",  data() {    return {      num: 1    }  },  computed: {    //手动写计算属性，    // count() {    //   return this.$store.state.count    // },    // evenOrOdd() {    //   return this.$store.getters.evenOrOdd    // },    // race() {    //   return this.$store.state.race    // },    // score() {    //   return this.$store.state.score    // },    //使用mapState生成计算属性，从state中获取    //...（展开运算符）：因为 mapState 返回的是一个对象，使用 ... 可以将其展开并合并到组件的 computed 属性中。 /*   ...mapState({      count: 'count',  // 将 Vuex 的 `state.count` 映射到组件的 `count` 计算属性      race: 'race',    // 将 Vuex 的 `state.race` 映射到组件的 `race` 计算属性      score: 'score'   // 将 Vuex 的 `state.score` 映射到组件的 `score` 计算属性    }),*/    //可以简写，因为key和value相同.数组写法    ...mapState(['count', 'race', 'score']),    // bigCount() {    //   return this.$store.getters.bigCount    // },    ...mapGetters(['bigCount', 'evenOrOdd'])  },  methods: {    // increment() {    //   //没有业务逻辑，直接提交    //   this.$store.commit('ADD', this.num)    // },    // decrement() {    //   //this.$store.dispatch('minus', this.num)    //   this.$store.commit('MINUS', this.num)    // },    //  使用mapMutations生成方法,  mapMutations会返回一个对象，对象中的方法会映射成组件的methods.注意这个时候需要传参,应为生成的函数是带参数的。    ...mapMutations({increment: 'ADD',  decrement: 'MINUS'}),    //数组写法，注意，生成的函数名字是ADD，MINUS，组件的点击事件函数名要修改,如@click="ADD(num)"   // ...mapMutations(['ADD', 'MINUS']),   //  incrementOdd() {   //    //业务逻辑，写在store中   //    this.$store.dispatch('addOdd', this.num)   //  },   //  incrementWait() {   //    this.$store.dispatch('addWait', this.num)   //  }    ...mapActions({incrementOdd: 'addOdd', incrementWait: 'addWait'}),    //数组写法,对应点击函数也要改   // ...mapActions(['addOdd', 'addWait'])  },  mounted() {    console.log(mapState({ss: 'count'}))  }}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;我在{{ race }}赢得了{{ score }}分好成绩！你也来试试吧！&lt;/h1&gt;    &lt;h1&gt;当前和为：{{ count }}&lt;/h1&gt;    &lt;h1&gt;当前和是：{{ evenOrOdd }}&lt;/h1&gt;    &lt;h1&gt;当前和扩大10倍是：{{ bigCount }}&lt;/h1&gt;    &lt;select v-model.number="num"&gt;      &lt;option value="1"&gt;1&lt;/option&gt;      &lt;option value="2"&gt;2&lt;/option&gt;      &lt;option value="3"&gt;3&lt;/option&gt;    &lt;/select&gt;    &lt;button @click="increment(num)"&gt;+&lt;/button&gt;    &lt;button @click="decrement(num)"&gt;-&lt;/button&gt;    &lt;button @click="incrementOdd(num)"&gt;当前和为奇数，则执行加法&lt;/button&gt;    &lt;button @click="incrementWait(num)"&gt;等一等再加&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;button  {  margin: 0 10px;}&lt;/style&gt;</code></pre><h3 id="3-7-模块化-命名空间"><a href="#3-7-模块化-命名空间" class="headerlink" title="3.7 模块化+命名空间"></a>3.7 模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><pre><code class="javascript">const countAbout = {  namespaced:true,//开启命名空间  state:{x:1},  mutations: { ... },  actions: { ... },  getters: {    bigSum(state){       return state.sum * 10    }  }}const personAbout = {  namespaced:true,//开启命名空间  state:{ ... },  mutations: { ... },  actions: { ... }}const store = new Vuex.Store({  modules: {    countAbout,    personAbout  }})</code></pre></li><li><p>开启命名空间后，组件中读取state数据：</p><pre><code class="vue">//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：// 用 mapState 取 countAbout 中的state 必须加上 'countAbout'...mapState('countAbout',['sum','school','subject']),</code></pre></li><li><p>开启命名空间后，组件中读取getters数据：</p><pre><code class="vue">//方式一：自己直接读取this.$store.getters['personAbout/firstPersonName']//方式二：借助mapGetters读取：...mapGetters('countAbout',['bigSum'])</code></pre></li><li><p>开启命名空间后，组件中调用dispatch</p><pre><code class="vue">//方式一：自己直接dispatchthis.$store.dispatch('personAbout/addPersonWang',person)//方式二：借助mapActions：...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})</code></pre></li><li><p>开启命名空间后，组件中调用commit</p><pre><code class="vue">//方式一：自己直接committhis.$store.commit('personAbout/ADD_PERSON',person)//方式二：借助mapMutations：...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),</code></pre></li></ol><p>模块拆分后，可以单独写count.js,person.js,然后export，在index.js中import。</p><p>count.js</p><pre><code class="javascript">export default {    namespaced: true,//命名空间,默认为false,为true，mapState,mapMutations,mapGetters,mapActions会自动加上该模块的namespace    actions: {        addOdd(context, value) {            if (context.state.count % 2) {                context.commit('ADD', value)            }        },        addWait(context, value) {            setTimeout(() =&gt; {                context.commit('ADD', value)            }, 1000)        }    },    mutations: {        ADD(state, value) {            state.count += value        },        MINUS(state, value) {            state.count -= value        }    },    state: {        count: 0,        race: "bcym",        score: 100    },    getters: {        evenOrOdd(state) {            return state.count % 2 ? '奇数' : '偶数'        },        bigCount(state) {            return state.count * 10        }    }}</code></pre><p>person.js</p><pre><code class="javascript">import axios from 'axios'import { nanoid } from 'nanoid'export default {    namespaced: true,    actions: {        addPersonBc(context, value) {            //只允许添加bc开头的            if(value.name.indexOf('bc')===0){                context.commit('ADD_PERSON', value)            }else {                alert('bc开头的才被允许添加')            }        },        addPersonServer(context) {            axios.get('https://www.klapi.cn/api/yiyan.php?type=txt').then(                res =&gt; {                    context.commit('ADD_PERSON', {id: nanoid(), name: res.data})                },                err =&gt; {                    alert('请求失败:',  err.message)                }            )        }    },    mutations: {        ADD_PERSON(state, value) {            state.personList.unshift(value)        }    },    state: {        personList: [            {id: '001', name: '张三'},            {id: '002', name: '李四'},            {id: '003', name: '王五'},            {id: '004', name: 'bcym'}        ]    },    getters: {        firstPersonName(state) {            return state.personList[0].name        }    }}</code></pre><h2 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key是路径，value是组件。</li></ol><h3 id="4-1-基本使用"><a href="#4-1-基本使用" class="headerlink" title="4.1 基本使用"></a>4.1 基本使用</h3><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><pre><code class="javascript">//引入VueRouterimport VueRouter from 'vue-router'//引入路由 组件import About from '../components/About'import Home from '../components/Home'//创建router实例对象，去管理一组一组的路由规则export default new VueRouter({    routes:[        {            path:'/about',            component:About        },        {            path:'/home',            component:Home        }    ]})</code></pre></li><li><p>实现切换（active-class可配置高亮样式）</p><pre><code class="vue">&lt;router-link active-class="active" to="/about"&gt;About&lt;/router-link&gt;</code></pre></li><li><p>指定展示位置</p><pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li></ol><h3 id="4-2-几个注意点"><a href="#4-2-几个注意点" class="headerlink" title="4.2 几个注意点"></a>4.2 几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="4-3-多级路由（嵌套路由）"><a href="#4-3-多级路由（嵌套路由）" class="headerlink" title="4.3 多级路由（嵌套路由）"></a>4.3 多级路由（嵌套路由）</h3><ol><li><p>配置路由规则，使用children配置项：</p><pre><code class="javascript">routes:[    {        path:'/about',        component:About,    },    {        path:'/home',        component:Home,        children:[ //通过children配置子级路由            {                path:'news', //此处一定不要写：/news                component:News            },            {                path:'message',//此处一定不要写：/message                component:Message            }        ]    }]</code></pre></li><li><p>跳转（要写完整路径）：</p><pre><code class="vue">&lt;router-link to="/home/news"&gt;News&lt;/router-link&gt;</code></pre></li><li><p>指定展示位置</p><pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;</code></pre></li></ol><h3 id="4-4-路由的query参数"><a href="#4-4-路由的query参数" class="headerlink" title="4.4 路由的query参数"></a>4.4 路由的query参数</h3><ol><li><p>传递参数</p><pre><code class="vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to="/home/message/detail?id=666&amp;title=你好"&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link     :to="{        path:'/home/message/detail',        query:{           id:666,            title:'你好'        }    }"&gt;跳转&lt;/router-link&gt;</code></pre></li><li><p>接收参数：</p><pre><code class="vue">$route.query.id$route.query.title</code></pre></li></ol><h3 id="4-5-命名路由"><a href="#4-5-命名路由" class="headerlink" title="4.5 命名路由"></a>4.5 命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><pre><code class="javascript">{    path:'/demo',    component:Demo,    children:[        {            path:'test',            component:Test,            children:[                {                      name:'hello' //给路由命名                    path:'welcome',                    component:Hello,                }            ]        }    ]}</code></pre></li><li><p>简化跳转：</p><pre><code class="vue">&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to="/demo/test/welcome"&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to="{name:'hello'}"&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link     :to="{        name:'hello',        query:{           id:666,            title:'你好'        }    }"&gt;跳转&lt;/router-link&gt;</code></pre></li></ol></li></ol><h3 id="4-6-路由的params参数"><a href="#4-6-路由的params参数" class="headerlink" title="4.6 路由的params参数"></a>4.6 路由的params参数</h3><ol><li><p>配置路由，声明接收params参数</p><pre><code class="javascript">{    path:'/home',    component:Home,    children:[        {            path:'news',            component:News        },        {            component:Message,            children:[                {                    name:'xiangqing',                    path:'detail/:id/:title', //使用占位符声明接收params参数                    component:Detail                }            ]        }    ]}</code></pre></li><li><p>传递参数</p><pre><code class="vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to="/home/message/detail/666/你好"&gt;跳转&lt;/router-link&gt;                &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link     :to="{        name:'xiangqing',        params:{           id:666,            title:'你好'        }    }"&gt;跳转&lt;/router-link&gt;</code></pre><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><pre><code class="vue">$route.params.id$route.params.title</code></pre></li></ol><h3 id="4-7-路由的props配置"><a href="#4-7-路由的props配置" class="headerlink" title="4.7 路由的props配置"></a>4.7 路由的props配置</h3><p>作用：让路由组件更方便的收到参数</p><pre><code class="javascript">{    name:'xiangqing',    path:'detail/:id',    component:Detail,    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件    // props:{a:900}    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件    // props:true        //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件    props($route) {        return {          id: $route.query.id,          title:$route.query.title,          a: 1,          b: 'hello'        }    }}</code></pre><blockquote><p>方便在要跳转去的组件里更简便的写法</p></blockquote><p>跳转去组件的具体代码</p><pre><code class="vue">&lt;template&gt;  &lt;ul&gt;      &lt;h1&gt;Detail&lt;/h1&gt;      &lt;li&gt;消息编号：{{id}}&lt;/li&gt;      &lt;li&gt;消息标题：{{title}}&lt;/li&gt;      &lt;li&gt;a:{{a}}&lt;/li&gt;      &lt;li&gt;b:{{b}}&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'Detail',    props: ['id', 'title', 'a', 'b'],    mounted () {        console.log(this.$route);    }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h3 id="4-8-的replace属性"><a href="#4-8-的replace属性" class="headerlink" title="4.8 <router-link>的replace属性"></a>4.8 <code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>（栈结构）和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="4-8-的replace属性-1"><a href="#4-8-的replace属性-1" class="headerlink" title="4.8 <router-link>的replace属性"></a>4.8 <code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="4-9-编程式路由导航"><a href="#4-9-编程式路由导航" class="headerlink" title="4.9 编程式路由导航"></a>4.9 编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><pre><code>//$router的两个APIthis.$router.push({    name:'xiangqing',        params:{            id:xxx,            title:xxx        }})this.$router.replace({    name:'xiangqing',        params:{            id:xxx,            title:xxx        }})this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退</code></pre></li></ol><h3 id="4-10-缓存路由组件"><a href="#4-10-缓存路由组件" class="headerlink" title="4.10 缓存路由组件"></a>4.10 缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><p>这个 include 指的是组件名</p><pre><code>&lt;keep-alive include="News"&gt;     &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre></li></ol><h3 id="4-11-两个新的生命周期钩子"><a href="#4-11-两个新的生命周期钩子" class="headerlink" title="4.11 两个新的生命周期钩子"></a>4.11 两个新的生命周期钩子</h3><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 具体名字：</p><ul><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ul><blockquote><p>这两个生命周期钩子需要配合前面的缓存路由组件使用（没有缓存路由组件不起效果）</p></blockquote><pre><code class="vue">activated() {  console.log('news组件被激活了');  this.timer = setInterval(() =&gt; {    this.opacity -= 0.01;    if (this.opacity &lt;= 0) {      this.opacity = 1;    }  }, 18);},deactivated() {  console.log('news组件失活了');  clearInterval(this.timer);}</code></pre><h3 id="4-12-路由守卫"><a href="#4-12-路由守卫" class="headerlink" title="4.12 路由守卫"></a>4.12 路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><pre><code class="javascript">//全局前置路由守卫————初始化时、每次路由切换之前调用router.beforeEach((to,from,next)=&gt;{    console.log(to,from)    //  if(to.name === 'message' || to.name === 'news'){}。用name判断也行    // 如果to.path等于/home/message或者/home/news，则跳转到/home，否则放行    //to.path === '/home/message' || to.path === '/home/news'    if(to.meta.isAuth){        if(localStorage.getItem('user')==='zqg'){            //放行            next()        }else {            alert('user不是zqg，无权限。')        }    }else{        //放行        next()    }})//全局后置路由守卫————初始化时、每次路由切换之后调用router.afterEach((to,from)=&gt;{    console.log(to,from)    document.title = to.meta.title || 'Vue_Router'})</code></pre><p>完整代码</p></li></ol><pre><code class="javascript">//引入VueRouterimport VueRouter from 'vue-router'//引入路由 组件import About from '../pages/About.vue'import Home from '../pages/Home.vue'//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter({    routes:[        {            name:'about',            path:'/about',            component:About,            meta:{title:'关于'}        },        {            name:'home',            path:'/home',            component:Home,            meta:{title:'主页'},            children:[                {                    path:'news', //注意这里的path不要写/                    component:()=&gt;import('../pages/News.vue'),                    meta:{isAuth:true,title:'新闻'}                },                {                    path:'message',                    component:()=&gt;import('../pages/Message.vue'),                    meta:{isAuth:true,title:'消息'},                    children:[                        {                            name:'detail',                            path:'detail/:id/:title',                            component:()=&gt;import('../pages/Detail.vue'),                            //  props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件                           /* props:{                                a:1,                                b:'hello'                            }*/                            //  props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件                            //props:true,                            // props的第三种写法，值为函数，params和query都适用。该对象中的所有key-value都会以props的形式传给Detail组件                            props($route){                                return {                                    id:$route.params.id,                                    title:$route.params.title                                }                            }                        }                    ]                }            ]        }    ]})//全局前置路由守卫————初始化时、每次路由切换之前调用router.beforeEach((to,from,next)=&gt;{    console.log(to,from)    //  if(to.name === 'message' || to.name === 'news'){}。用name判断也行    // 如果to.path等于/home/message或者/home/news，则跳转到/home，否则放行    //to.path === '/home/message' || to.path === '/home/news'    if(to.meta.isAuth){        if(localStorage.getItem('user')==='zqg'){            //放行            next()        }else {            alert('user不是zqg，无权限。')        }    }else{        //放行        next()    }})//全局后置路由守卫————初始化时、每次路由切换之后调用router.afterEach((to,from)=&gt;{    console.log(to,from)    document.title = to.meta.title || 'Vue_Router'})export default router</code></pre><p>4.独享守卫:</p><blockquote><p>就是在 routes 子路由内写守卫，只对单独的路由起作用</p></blockquote><pre><code class="javascript">    //独享路由守卫                    beforeEnter:(to,from,next)=&gt;{                        if(to.meta.isAuth){                            if(localStorage.getItem('user')==='zqg'){                                //放行                                next()                            }else {                                alert('user不是zqg，无权限。')                            }                        }else{                            //放行                            next()                        }                    }</code></pre><p>5.组件内守卫：</p><blockquote><p>在具体组件内写守卫</p></blockquote><pre><code class="javascript">//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) {},//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) {}</code></pre><h3 id="4-13-路由器的两种工作模式"><a href="#4-13-路由器的两种工作模式" class="headerlink" title="4.13 路由器的两种工作模式"></a>4.13 路由器的两种工作模式</h3><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol><h2 id="5-Vue-UI组件库"><a href="#5-Vue-UI组件库" class="headerlink" title="5.Vue UI组件库"></a>5.Vue UI组件库</h2><h3 id="5-1-移动端常用UI组件库"><a href="#5-1-移动端常用UI组件库" class="headerlink" title="5.1 移动端常用UI组件库"></a>5.1 移动端常用UI组件库</h3><ol><li><p>Vant <a href="https://youzan.github.io/vant">https://youzan.github.io/vant</a> </p></li><li><p>CubeUI <a href="https://didi.github.io/cube-ui">https://didi.github.io/cube-ui</a> </p></li><li><p>Mint UI <a href="http://mint-ui.github.io/">http://mint-ui.github.io</a></p></li><li><p>…</p></li></ol><h3 id="5-2-PC端常用UI组件库"><a href="#5-2-PC端常用UI组件库" class="headerlink" title="5.2 PC端常用UI组件库"></a>5.2 PC端常用UI组件库</h3><ol><li>Element UI <a href="https://element.eleme.cn/">https://element.eleme.cn</a> </li><li>IView UI <a href="https://www.iviewui.com/">https://www.iviewui.com</a></li><li>…</li></ol><h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px"><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h2 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h2><h3 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h3><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve</code></pre><h3 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h3><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><blockquote><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250615185843691.png" alt="image-20250615185843691"></p></blockquote><p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250615185958852.png" alt="image-20250615185958852"></p><pre><code class="bash">## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev</code></pre><h3 id="3-分析文件目录"><a href="#3-分析文件目录" class="headerlink" title="3.分析文件目录"></a>3.分析文件目录</h3><p><strong>main.js</strong></p><p>Vue2项目的main.js</p><pre><code class="javascript">import Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falsenew Vue({  render: h =&gt; h(App),}).$mount('#app')</code></pre><p>我们再来看看Vue3项目中的main.js</p><pre><code class="javascript">import { createApp } from 'vue'import App from './App.vue'createApp(App).mount('#app')</code></pre><p>分析一下</p><pre><code class="javascript">// 引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数import { createApp } from 'vue'import App from './App.vue'// 创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)const app = createApp(App)console.log(app)// 挂载app.mount('#app')</code></pre><p><strong>App.vue</strong></p><p>我们再来看看组件</p><p>在<code>template</code>标签里可以没有根标签了</p><pre><code class="vue">&lt;template&gt;    &lt;!-- Vue3组件中的模板结构可以没有根标签 --&gt;    &lt;img alt="Vue logo" src="./assets/logo.png"&gt;    &lt;HelloWorld msg="Welcome to Your Vue.js App"/&gt;&lt;/template&gt;</code></pre><h2 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h2><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h3 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h3><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h3 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h3><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h3 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h3><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h3 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h3><h4 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h4><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><pre><code class="javascript">Object.defineProperty(data, 'count', {    get () {},     set () {}})</code></pre></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h4 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h4><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><pre><code class="js">new Proxy(data, {    // 拦截读取属性值    get (target, prop) {        return Reflect.get(target, prop)    },    // 拦截设置属性值或添加新属性    set (target, prop, value) {        return Reflect.set(target, prop, value)    },    // 拦截删除属性    deleteProperty (target, prop) {        return Reflect.deleteProperty(target, prop)    }})proxy.name = 'tom'   </code></pre></li></ul></li></ul></li></ul><h3 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h3><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h3 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h3><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h3 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h3><h4 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h4><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><pre><code class="js">import {computed} from 'vue'setup(){    ...    //计算属性——简写    let fullName = computed(()=&gt;{        return person.firstName + '-' + person.lastName    })    //计算属性——完整    let fullName = computed({        get(){            return person.firstName + '-' + person.lastName        },        set(value){            const nameArr = value.split('-')            person.firstName = nameArr[0]            person.lastName = nameArr[1]        }    })}</code></pre></li></ul><h4 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h4><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><pre><code class="js">//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;{    console.log('sum变化了',newValue,oldValue)},{immediate:true})//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;{    console.log('sum或msg变化了',newValue,oldValue)}) /* 情况三：监视reactive定义的响应式数据            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;{    console.log('person变化了',newValue,oldValue)},{immediate:true,deep:false}) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;{    console.log('person的job变化了',newValue,oldValue)},{immediate:true,deep:true}) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{    console.log('person的job变化了',newValue,oldValue)},{immediate:true,deep:true})//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;{    console.log('person的job变化了',newValue,oldValue)},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</code></pre></li></ul><h4 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h4><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;{    const x1 = sum.value    const x2 = person.age    console.log('watchEffect配置的回调执行了')})</code></pre></li></ul><h3 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h3><div style="border:1px solid black;width:390px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://v2.cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px;"></div><div style="border:1px solid black;width:540px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.W0MNXI0C.png" alt="lifecycle_2" style="zoom:33%;width:2500px;"></div><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code>&nbsp;==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h3><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h3 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h3><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,'name')</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h2 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h2><h3 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h3><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h3 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h3><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h3 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h3><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h3><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre><code class="vue">&lt;template&gt;    &lt;input type="text" v-model="keyword"&gt;    &lt;h3&gt;{{keyword}}&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;    import {ref,customRef} from 'vue'    export default {        name:'Demo',        setup(){            // let keyword = ref('hello') //使用Vue准备好的内置ref            //自定义一个myRef            function myRef(value,delay){                let timer                //通过customRef去实现自定义                return customRef((track,trigger)=&gt;{                    return{                        get(){                            track() //告诉Vue这个value值是需要被“追踪”的                            return value                        },                        set(newValue){                            clearTimeout(timer)                            timer = setTimeout(()=&gt;{                                value = newValue                                trigger() //告诉Vue去更新界面                            },delay)                        }                    }                })            }            let keyword = myRef('hello',500) //使用程序员自定义的ref            return {                keyword            }        }    }&lt;/script&gt;</code></pre></li></ul><h3 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h3><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px"><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre><code class="js">setup(){    ......    let car = reactive({name:'奔驰',price:'40万'})    provide('car',car)    ......}</code></pre></li><li><p>后代组件中：</p><pre><code class="js">setup(props,context){    ......    const car = inject('car')    return {car}    ......}</code></pre></li></ol></li></ul><h3 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h3><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h2><h3 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h3><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left"></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left"> </div><h3 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="height:360px"></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="height:360px"></div><h2 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h2><h3 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h3><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h3 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h3><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><pre><code class="vue">&lt;teleport to="移动位置"&gt;    &lt;div v-if="isShow" class="mask"&gt;        &lt;div class="dialog"&gt;            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;            &lt;button @click="isShow = false"&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;</code></pre></li></ul><h3 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h3><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre><code class="js">import {defineAsyncComponent} from 'vue'const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue'))</code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre><code class="vue">&lt;template&gt;    &lt;div class="app"&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;            &lt;template v-slot:default&gt;                &lt;Child/&gt;            &lt;/template&gt;            &lt;template v-slot:fallback&gt;                &lt;h3&gt;加载中.....&lt;/h3&gt;            &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre><code class="js">//注册全局组件Vue.component('MyButton', {  data: () =&gt; ({    count: 0  }),  template: '&lt;button @click="count++"&gt;Clicked {{ count }} times.&lt;/button&gt;'})//注册全局指令Vue.directive('focus', {  inserted: el =&gt; el.focus()}</code></pre></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h3 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h3><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><pre><code class="css">.v-enter,.v-leave-to {  opacity: 0;}.v-leave,.v-enter-to {  opacity: 1;}</code></pre></li><li><p>Vue3.x写法</p><pre><code class="css">.v-enter-from,.v-leave-to {  opacity: 0;}.v-leave-from,.v-enter-to {  opacity: 1;}</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre><code class="vue">&lt;my-component  v-on:close="handleComponentEvent"  v-on:click="handleNativeClickEvent"/&gt;</code></pre></li><li><p>子组件中声明自定义事件</p><pre><code class="vue">&lt;script&gt;  export default {    emits: ['close']  }&lt;/script&gt;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue2 </tag>
            
            <tag> 学习笔记，前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝V3接口接入</title>
      <link href="/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/"/>
      <url>/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot项目接入支付宝v3接口"><a href="#SpringBoot项目接入支付宝v3接口" class="headerlink" title="SpringBoot项目接入支付宝v3接口"></a>SpringBoot项目接入支付宝v3接口</h1><h2 id="1、接入准备"><a href="#1、接入准备" class="headerlink" title="1、接入准备"></a>1、接入准备</h2><p>首先到<a href="https://open.alipay.com/">支付宝开放平台</a>注册或者登录，选择移动/网页支付，按照页面的指引进行接入（正式生产环境是必须要申请账号、创建应用、配置相关参数等）。如果只是开发测试，可以使用支付宝提供的沙箱环境，下面的所有的内容都是基于沙箱环境的。</p><p>打开<a href="https://open.alipay.com/develop/manage">控制台首页 - 开放平台</a>，选择开发工具里的沙箱，可以查看支付宝分配给你的沙箱环境账号信息，特别是公钥和私钥，或者证书。本次开发，我用的是公钥和私钥的接口加签方式，使用证书也可以，只不过在1.0和2.0版本的接口，公私钥和证书的代码有些许不同，貌似在3.0版本中，代码都一样，只要在AlipayConfig中给相应字段赋值接可以了。</p><p>总之，接入准备的步骤，详细看支付宝官方文档，这里就不详细介绍了。</p><h2 id="2、开发环境"><a href="#2、开发环境" class="headerlink" title="2、开发环境"></a>2、开发环境</h2><p>开发工具：idea + maven</p><pre><code class="properties">SpringBoot.version=2.7.8alipay-sdk-java-v3.version=3.1.22.ALL</code></pre><p>在pom文件引入支付宝v3版本的依赖：（注意如果SpringBoot的版本过低，会导致OkHttp的版本变低，导致接口调用失败，要么直接强制指定OkHttp的版本为alipay-sdk-java-v3中引用的，如4.9.3，要么升级SpringBoot的版本，2.7.8是没问题的）</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;    &lt;artifactId&gt;alipay-sdk-java-v3&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="3、编写测试代码"><a href="#3、编写测试代码" class="headerlink" title="3、编写测试代码"></a>3、编写测试代码</h2><h3 id="3-1-支付宝接口的配置信息"><a href="#3-1-支付宝接口的配置信息" class="headerlink" title="3.1 支付宝接口的配置信息"></a>3.1 支付宝接口的配置信息</h3><p>实际项目开发，配置信息放在配置文件中，如果用证书，证书一定要妥善保管，一般放在服务器里。这里直接就写死了，配置信息来自支付宝的沙箱账号信息。</p><pre><code class="java">private AlipayConfig getAlipayConfig() {    AlipayConfig alipayConfig = new AlipayConfig();    //alipayConfig.setServerUrl("https://openapi.alipay.com");    alipayConfig.setServerUrl("https://openapi-sandbox.dl.alipaydev.com");    alipayConfig.setAppId("9021xxxxxxxxxxxxx");    alipayConfig.setPrivateKey("MIIEvAIBADANxxxxxxxxxxxxxxx");    alipayConfig.setAlipayPublicKey("MIIBIjANBgxxxxxxxxxxxxxxx");    return alipayConfig;}</code></pre><h3 id="3-2-电脑网站支付"><a href="#3-2-电脑网站支付" class="headerlink" title="3.2 电脑网站支付"></a>3.2 电脑网站支付</h3><p>这个就是常见的在电脑浏览器上点击支付，会出现二维码或者登录支付宝账户，扫码或者输入支付密码然后支付完成。详细文档：<a href="https://opendocs.alipay.com/open-v3/05w3qc">产品介绍 - 支付宝文档中心</a></p><p>支付宝的文档十分详细，但是初次接入肯定会有点眼花缭乱，下面我挑一些重点的内容来将和我踩过的一些坑。</p><h4 id="支付流程："><a href="#支付流程：" class="headerlink" title="支付流程："></a>支付流程：</h4><p>电脑网站支付的支付接口 <a href="https://opendocs.alipay.com/open-v3/0e5a81?scene=22">alipay.trade.page.pay</a>（统一收单下单并支付页面接口）调用时序图如下：</p><p><img src="https://gw.alipayobjects.com/os/skylark-tools/public/files/0ba3e82ad37ecf8649ee4219cfe9d16b.png%26originHeight%3D2023%26originWidth%3D2815%26size%3D526149%26status%3Ddone%26width%3D2815" alt="流程图"></p><p><strong>调用流程如下</strong>：</p><ol><li>商家系统调用 <a href="https://opendocs.alipay.com/open-v3/0e5a81?scene=22">alipay.trade.page.pay</a>（统一收单下单并支付页面接口）向支付宝发起支付请求，支付宝对商家请求参数进行校验，而后重新定向至用户登录页面。</li><li>用户确认支付后，支付宝通过 get 请求 returnUrl（商户入参传入），返回同步返回参数。</li><li>交易成功后，支付宝通过 post 请求 notifyUrl（商户入参传入），返回异步通知参数。</li><li>若由于网络等原因，导致商家系统没有收到异步通知，商家可自行调用 <a href="https://opendocs.alipay.com/open-v3/0e5a7y">alipay.trade.query</a>（统一收单交易查询接口）查询交易以及支付信息（商家也可以直接调用该查询接口，不需要依赖异步通知）。</li></ol><p><strong>注意</strong>： </p><ul><li>由于同步返回的不可靠性，支付结果必须以异步通知或查询接口返回为准，不能依赖同步跳转。</li><li>商家系统接收到异步通知以后，必须通过验签（验证通知中的 sign 参数）来确保支付通知是由支付宝发送的。详细验签规则可查看 <a href="https://opendocs.alipay.com/open-v3/05w3qh?pathHash=78bd7a2c#s7">异步通知验签</a>。</li><li>接收到异步通知并验签通过后，请务必核对通知中的 app_id、out_trade_no、total_amount 等参数值是否与请求中的一致，并根据 trade_status 进行后续业务处理。</li><li>在支付宝端，partnerId 与 out_trade_no 唯一对应一笔单据，商家端保证不同次支付 out_trade_no 不可重复；若重复，支付宝会关联到原单据，基本信息一致的情况下会以原单据为准进行支付。</li></ul><h4 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h4><p>开放平台提供了支持主流开发语言的 SDK 接入的方式。对于页面跳转类 API，SDK 不会也无法像系统调用类 API 一样自动请求支付宝并获得结果，而是在接受 request 请求对象后，为开发者生成前台页面请求需要的完整 form 表单的 html（包含自动提交脚本），商家直接将这个表单的 String 输出到 http response 中即可。</p><p><strong>注意：</strong></p><ul><li>付款页面生成的付款码每 <strong>2 分钟</strong> 会自动刷新一次。</li><li>电脑网站支付后使用 <a href="https://opendocs.alipay.com/open-v3/repo-021o7g?ref=api_v3">商家分账</a> 完成分账，查询结果需使用 <a href="https://opendocs.alipay.com/open-v3/0e5a7y">alipay.trade.query</a>（统一收单交易查询接口） <code>query_options</code> 传入 <code>trade_settle_info</code> 查询分账信息，不能使用 alipay.trade.order.settle.query（交易分账查询接口）查询。</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p>文档中的代码很长，但是最关键的是代码没有展示如何设置<strong>return_url</strong>和<strong>notify_url</strong>两个参数，这就有点坑了，return_url是支付完成了跳转回原来系统的地址，notify_url是接收支持成功的异步通知的，我自己试了几次没成功，然后再支付宝社区找答案，于是：</p><p><img src="/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/image-20241225163338921.png" alt="图1"></p><p>也就是说<strong>return_url</strong>和<strong>notify_url</strong>都放在<strong>bizContent</strong>业务参数中，结果还是不对。。。。。。，后来找技术支持，说还是要和bizContent同级，也就是放在<strong>bizParams</strong>中，这真是，说虽然是V3接口，但是还是走的V2的逻辑，好吧。关键的代码如下：</p><pre><code class="java"> ApiClient defaultClient = Configuration.getDefaultApiClient(); // 初始化alipay参数（全局设置一次） defaultClient.setAlipayConfig(getAlipayConfig()); GenericExecuteApi api = new GenericExecuteApi(); // 构造请求参数以调用接口 Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;(); // 设置商户订单号 bizContent.put("out_trade_no", String.valueOf(System.currentTimeMillis())); // 设置订单总金额 bizContent.put("total_amount", "6.88"); // 设置订单标题 bizContent.put("subject", "测试电脑网站支付"); // 设置产品码 bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY"); // 设置订单附加信息 bizContent.put("body", "谢谢谢谢"); // 设置PC扫码支付的方式 bizContent.put("qr_pay_mode", "2"); bizParams.put("biz_content", bizContent); //return_url 必须是 http 或 https 开头的完整的 url 地址。 //return_url 地址后不可带自定义参数。 //设置 return_url 时不要进行转义、urlencode 等数据处理。 //当面付和APP支付不支持 return_url 参数，即使设置了也没有任何效果。 //同步通知参数只可参考，不能作为判断是否支付成功的依据。 bizParams.put("return_url", "https://docs.open.alipay.com"); bizParams.put("notify_url", "http://xxxxx/pay/pcNotify"); try {        System.out.println(JSON.serialize(bizParams));        // 如果是第三方代调用模式，请设置app_auth_token（应用授权令牌）        String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "POST", bizParams);        // 如果需要返回GET请求，请使用        // String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "GET", bizParams);        System.out.println(pageRedirectionData);        return pageRedirectionData;    } catch (ApiException e) {        System.out.println("调用失败");    }</code></pre><p>电脑网站支付就可以了。</p><h3 id="3-3-APP支付"><a href="#3-3-APP支付" class="headerlink" title="3.3 APP支付"></a>3.3 APP支付</h3><p>这个是最常见的了，在商家APP中集成支付宝SDK，然后支付。<a href="https://opendocs.alipay.com/open-v3/05vuxe?pathHash=3444d649">产品介绍 - 支付宝文档中心</a>，后端调用app支付接口，返回订单的加密信息给前端，然后前端调用支付接口，完成支付。</p><p>交互流程:</p><p><img src="http://mdn.alipayobjects.com/afts/img/A*TKy2TKpVL3wAAAAAAAAAAAAAAa8wAA/original?bz=openpt_doc&amp;t=4msaCTXlxU0OKJWNkWsscvHbSGcA6jWukIuBa4lIU0UDAAAAZAAAMK8AAAAA" alt="p2"></p><p>以下对重点步骤做简要说明：</p><ul><li>第 1 步用户在商户 App 客户端/小程序中购买商品下单。</li><li>第 2 步商户订单信息由商户 App 客户端/小程序发送到服务端。</li><li>第 3 步商家服务端调用 <a href="https://opendocs.alipay.com/open-v3/429e4d75_alipay.trade.app.pay">alipay.trade.app.pay（app支付接口2.0接口）</a>通过支付宝服务端 SDK 获取 orderStr（orderStr 中包含了订单信息和签名）。</li><li>第 4 步商家将 orderStr 发送给商户 App 客户端/小程序。</li><li>第 5 步商家在客户端/小程序发起请求，将 orderStr 发送给支付宝。</li><li>第 6 步进行支付预下单：支付宝客户端将会按照商家客户端提供的请求参数进行支付预下单。正常场景下，会唤起支付宝收银台等待用户核身；异常场景下，会返回异常信息。</li><li>第 11 步返回商家 App/小程序：用户在支付宝 App 完成支付后，会跳转回商家页面，并返回最终的支付结果（即同步通知），可查看 <a href="https://opendocs.alipay.com/open-v3/05vuxo">同步通知说明</a>。</li><li>第 13 步支付结果异步通知，支付宝会根据步骤3 传入的异步通知地址 notify_url，发送异步通知，可查看 <a href="https://opendocs.alipay.com/open-v3/05vuxp">异步通知说明</a>。</li></ul><p>除了正向支付流程外，支付宝也提供交易查询、关闭、退款、退款查询以及对账等配套 API。</p><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><pre><code class="java"> ApiClient defaultClient = Configuration.getDefaultApiClient(); // 初始化alipay参数（全局设置一次） defaultClient.setAlipayConfig(getAlipayConfig()); GenericExecuteApi api = new GenericExecuteApi(); // 构造请求参数以调用接口 Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;(); // 设置商户订单号 bizContent.put("out_trade_no", "70501111111S001111119"); // 设置订单总金额 bizContent.put("total_amount", "9.00"); // 设置订单标题 bizContent.put("subject", "大乐透"); // 设置产品码 bizContent.put("product_code", "QUICK_MSECURITY_PAY"); // 设置订单附加信息 bizContent.put("body", "Iphone6 16G"); // 设置订单绝对超时时间 bizContent.put("time_expire", "2024-12-31 10:05:00"); // 设置建议使用time_expire字段 bizContent.put("timeout_express", "90m"); bizParams.put("biz_content", bizContent); // 同步回调指定的页面 app不需要// bizParams.put("return_url", "https://docs.open.alipay.com"); bizParams.put("notify_url", "http://xxxxx/pay/appNotify"); try {     String orderStr = api.sdkExecute("alipay.trade.app.pay", bizParams);     System.out.println(orderStr);     return orderStr; } catch (ApiException e) {     System.out.println("调用失败"); }</code></pre><h3 id="3-4-手机网站支付"><a href="#3-4-手机网站支付" class="headerlink" title="3.4 手机网站支付"></a>3.4 手机网站支付</h3><p><a href="https://opendocs.alipay.com/open-v3/05w4kp?pathHash=f3e513ea">产品介绍 - 支付宝文档中心</a>,手机网站支付是指商家在移动端网页展示商品或服务，用户在商家页面确认使用支付宝支付后，浏览器自动跳转支付宝 App 或支付宝网页完成付款的支付产品。该产品在签约完成后，需要技术集成方可使用。代码和电脑网站支付差不多。</p><p>建议手机网站支付转Native支付，也就是唤起支付宝APP支付，而不是在H5页面进行支付。<a href="https://opendocs.alipay.com/open-v3/05w4kw?pathHash=386b48c6">手机网站支付转Native支付（推荐） - 支付宝文档中心</a></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/179989/1668414529588-da8c06d7-41da-49b2-a967-00d05d01ff33.png" alt="p2"></p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><p>手机网站支付与手机网站转 Native 支付的主要区别为：</p><ul><li>如果用户手机安装了支付宝客户端，手机网站转 Native 支付方式将跳转到支付宝客户端中进行订单支付，用户体验和支付成功率均优于手机网站支付方式。除此之外，还能使用手机网站支付没有提供的指纹支付、手环支付、手表支付、免密支付等功能。 </li><li>如果用户手机没有安装支付宝客户端，将在 SDK 提供的 Web-view 中打开 H5 页面进行支付。即便如此，由于 SDK 与服务端的交互携带账号信息，仍比不携带任何账号信息的普通手机网站支付体验更好。</li></ul><h4 id="如何实现手机网站转Native支付"><a href="#如何实现手机网站转Native支付" class="headerlink" title="如何实现手机网站转Native支付"></a>如何实现手机网站转Native支付</h4><p>要实现上述功能需接入支付宝提供的 SDK。接入过程十分简单，可以以上述 Demo 为参考，该 Demo 程序只有一个功能：创建一个 Web-view，在 Web-view 中拦截每个 URL，然后调用 SDK 提供的接口检查该 URL 是否是有效的支付宝订单支付 URL，如果是则将该 URL 传给 SDK 提供的支付接口进行支付。</p><h3 id="3-5-退款接口"><a href="#3-5-退款接口" class="headerlink" title="3.5 退款接口"></a>3.5 退款接口</h3><p>退款接口没啥好说的，主要是区分部分退款和全额退款交易状态的不同，参数传递的些许差异。<a href="https://opendocs.alipay.com/open-v3/da960891_alipay.trade.refund?scene=common&amp;pathHash=f692c2c5">统一收单交易退款接口 - 支付宝文档中心</a>。先上代码：</p><pre><code class="java">@GetMapping ("/refundPay")public String refundPay(String orderNo,String amount) throws ApiException {    ApiClient defaultClient = Configuration.getDefaultApiClient();    // 初始化alipay参数（全局设置一次）    defaultClient.setAlipayConfig(getAlipayConfig());    // 构造请求参数以调用接口    AlipayTradeApi api = new AlipayTradeApi();    AlipayTradeRefundModel data = new AlipayTradeRefundModel();    // 部分退款时,outRequestNo必传,同一笔交易多次退款需要保证唯一    data.outRequestNo(String.valueOf(System.currentTimeMillis()));    data.setOutTradeNo(orderNo);    data.setRefundAmount(amount);    data.setRefundReason("测试退款");    // 第三方代调用模式下请设置app_auth_token    CustomizedParams params = new CustomizedParams();    params.setAppAuthToken("&lt;-- 请填写应用授权令牌 --&gt;");    try {        AlipayTradeRefundResponseModel response = api.refund(data);        //{"buyer_logon_id":"rpv***@sandbox.com","buyer_user_id":"2088722013720112","fund_change":"Y","gmt_refund_pay":"2024-12-19 14:16:39","out_trade_no":"1734423455786","refund_fee":"15.88","send_back_fee":"0.00","trade_no":"2024121722001420110504891744"}        System.out.println("调用成功:" + JSON.serialize(response));        return JSON.serialize(response);    } catch (ApiException e) {        AlipayTradeRefundDefaultResponse errorObject = (AlipayTradeRefundDefaultResponse) e.getErrorObject();        System.out.println("调用失败:" + errorObject);    }    return "";}</code></pre><p>首先全额退款时，<strong>trade_no(支付宝交易号)<strong>和</strong>out_trade_no(商户订单号)<strong>二选一传入,<strong>refund_amount</strong>是必传的，退款成功后，交易状态变为：</strong>TRADE_CLOSED</strong>；</p><p>部分退款时，参数在全额基础上，加了<strong>out_request_no</strong>退款请求号,必传。 标识一次退款请求，需要保证在交易号下唯一，如需部分退款，则此参数必传。 注：针对同一次退款请求，如果调用接口失败或异常了，重试时需要保证退款请求号不能变更，防止该笔交易重复退款。支付宝会保证同样的退款请求号多次请求只会退一次。部分退款成功后，交易状态仍为 <strong>TRADE_SUCCESS</strong>。</p><p>APP、手机网站支付退款成功会触发异步通知，就是在调用pay接口时传入的notify_url，电脑网站只有部分退款时有通知（交易状态<strong>TRADE_SUCCESS</strong>）。但是不同的交易状态触发机制不同，后面会详说。退款是否成功建议还是调用<a href="https://opendocs.alipay.com/open-v3/b95db51d_alipay.trade.fastpay.refund.query?scene=common&amp;pathHash=013d131b">统一收单交易退款查询接口 - 支付宝文档中心</a>来确认，异步通知虽然也可以，但是判断条件有点复杂，而且会和支付成功时的通知业务耦合在一起，还要判断是全额退款和部分退款，所以，异步通知接口只用来接收支付成功的消息比较好，退款可以根据退款接口返回的字段<strong>fund_change=Y</strong>判断，再结合退款查询接口。</p><h4 id="退款说明"><a href="#退款说明" class="headerlink" title="退款说明"></a>退款说明</h4><ul><li><strong>退款周期：</strong>12 个月，即交易发生后 12 个月内可发起退款，超过 12 个月则不可发起退款。</li><li><strong>退款方式：</strong>资金原路返回用户账号。</li><li><strong>退款退费：</strong>退款时手续费不退回。</li><li>一笔退款失败后重新提交，要采用原来的退款单号。</li><li>总退款金额不能超过用户实际支付金额。</li><li>退款信息以退款接口同步返回或者 <a href="https://opendocs.alipay.com/open-v3/0e5a7x">alipay.trade.fastpay.refund.query</a>（统一收单交易退款查询接口）为准。</li></ul><p>退款存在退到银行卡场景下时，开发者需要先订阅 <a href="https://opendocs.alipay.com/open-v3/05w4la?pathHash=da33cafe&amp;scene=common">alipay.trade.refund.depositback.completed</a>（收单退款冲退完成通知）如果是使用 <a href="https://opendocs.alipay.com/open-v3/064zh9?pathHash=a9c7a1f2">From 蚂蚁消息服务</a> 需要先设置好应用网关地址，支付宝会根据银行回执消息发送退款完成信息至应用网关地址。具体消息订阅步骤可查看 <a href="https://opendocs.alipay.com/open-v3/064zh9?pathHash=a9c7a1f2#%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF">订阅消息</a>。</p><h3 id="3-6-订单查询接口"><a href="#3-6-订单查询接口" class="headerlink" title="3.6 订单查询接口"></a>3.6 订单查询接口</h3><p><a href="https://opendocs.alipay.com/open-v3/cd439c70_alipay.trade.query?scene=23&amp;pathHash=525a8e13">统一收单交易查询接口 - 支付宝文档中心</a>,直接查就可以了。</p><h3 id="3-7-交易关闭接口"><a href="#3-7-交易关闭接口" class="headerlink" title="3.7 交易关闭接口"></a>3.7 交易关闭接口</h3><p>通常交易关闭是通过 alipay.trade.page.pay 中的超时时间来控制，支付宝也提供给商家 <a href="https://opendocs.alipay.com/open-v3/0e5a80">alipay.trade.close</a>（统一收单交易关闭接口）。若用户一直未支付，商家可以调用该接口关闭指定交易；成功关闭交易后该交易不可支付。</p><h3 id="3-8-异步通知接口"><a href="#3-8-异步通知接口" class="headerlink" title="3.8 异步通知接口"></a>3.8 异步通知接口</h3><p>支付成功和退款成功都会触发异步通知，建议只处理支付成功的通知，这样的话电脑网站支付和app支付可以用同一个notify_url，同一个接口，如果处理退款的通知，电脑网站支付和app支付触发条件不一样，判断条件也不一样，会有一些复杂的场景，比如：部分退款时，最后一笔退款会改变交易状态为TRADE_CLOSED，而没有退完时，状态仍是TRADE_SUCCESS，需要各种条件判断，所以退款还是调用退款查询接口比较好，建议在退款后10s后调用，可以用MQ延时消息处理。</p><p>我写了两个异步通知方法，简单判断了通知类型，但是肯定没有包含所有情况。代码如下：</p><pre><code class="java">@PostMapping("/pcNotify")public String notifyPay(HttpServletRequest request) throws ApiException {    System.out.println("电脑网站收到异步通知=====支付宝回调");    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();    Map&lt;String, String[]&gt; requestParams = request.getParameterMap();    for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = iter.next();        String[] values = requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        params.put(name, valueStr);    }    //{"gmt_create":"2024-12-19 14:04:16","charset":"UTF-8","gmt_payment":"2024-12-19 14:04:31","notify_time":"2024-12-19 14:04:33","subject":"测试电脑网站支付","sign":"XAzGwc/dZ6ON1TwXvw92GnhF7X4PTZNJ6h6TfH/5T0sgfTtIRVgnny150B7Ip1xHgjpuNoz+T8XlMpMNgvkpxNlcWmlbDfs72Ls/OyyV7ttEKgRos4VWKIrojJ1Apy06H9kie6cCfmBC3mmW9Gh+QAh5oejdZDSq+NDgJIjBlz8S6x85GEQ0BprcVHDfPKubaOWl5nCri7YKxTPOLZcqwTgV9mWXzoIa9hSp32bqyTiLtDlM1h5Z7IJKuj9/EhKuOAz6PF/vws/lftp9gzG3bJVkwwP4z50neyJNWzENIHIKQoGDInZF+T2yNyJJ0YPg/x8LejPzyfdkHjM9bZjBEA\u003d\u003d","buyer_id":"2088722013720112","invoice_amount":"6.88","version":"1.0","notify_id":"2024121901222140432120110505059148","fund_bill_list":"[{\"amount\":\"6.88\",\"fundChannel\":\"ALIPAYACCOUNT\"}]","notify_type":"trade_status_sync","out_trade_no":"1734588234593","total_amount":"6.88","trade_status":"TRADE_SUCCESS","trade_no":"2024121922001420110504898164","auth_app_id":"9021000128652691","receipt_amount":"6.88","point_amount":"0.00","buyer_pay_amount":"6.88","app_id":"9021000128652691","sign_type":"RSA2","seller_id":"2088721013742803"}    System.out.println(JSON.serialize(params));    // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）    boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");    if (verified) {        //todo 参数验证，out_trade_no，total_amount等        //1. 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。        //2. 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）。        //3. 校验通知中的 seller_id（或者 seller_email ) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个seller_id/seller_email）。        //4. 验证 app_id 是否为该商家本身。        System.out.println("支付异步验签成功");        String tradeStatus = params.get("trade_status");        //总退款金额        String refundFee = params.get("refund_fee");        //交易退款时间        String gmtRefund = params.get("gmt_refund");        if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){            //只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功。            if ("TRADE_SUCCESS".equals(tradeStatus) || "TRADE_FINISHED".equals(tradeStatus)) {                System.out.println("支付成功异步通知");            }        }else {            System.out.println("退款异步通知");            String gmtClose = params.get("gmt_close");            if ("TRADE_SUCCESS".equals(tradeStatus)) {                //最后一次部分退款没有通知，因为状态已经变成TRADE_CLOSED                System.out.println("部分退款异步通知");            }            //电脑网站支付应该不会有全额退款通知，因为TRADE_CLOSED不会触发异步通知            if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                System.out.println("全额退款异步通知");            }        }        return "success";    }else {        System.out.println("验签失败，支付失败");        return "failure";    }}@PostMapping("/appNotify")public String notifyAppPay(HttpServletRequest request) throws ApiException {    System.out.println("app收到异步通知=====支付宝回调");    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();    Map&lt;String, String[]&gt; requestParams = request.getParameterMap();    for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = iter.next();        String[] values = requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        params.put(name, valueStr);    }    System.out.println(JSON.serialize(params));    // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）    boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");    if (verified) {        System.out.println("支付异步验签成功");        String tradeStatus = params.get("trade_status");        //总退款金额        String refundFee = params.get("refund_fee");        //交易退款时间        String gmtRefund = params.get("gmt_refund");        if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("支付成功异步通知");            }            if ("TRADE_CLOSED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }            if ("TRADE_FINISHED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }        }else {            System.out.println("退款异步通知");            String gmtClose = params.get("gmt_close");            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("部分退款异步通知");            }            //全额退款，或者最后一次部分退款            if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                System.out.println("全额退款异步通知");            }        }        return "success";    }else {        System.out.println("支付异步验签失败，支付失败");        return "failure";    }}</code></pre><h3 id="3-9-一些要注意的信息"><a href="#3-9-一些要注意的信息" class="headerlink" title="3.9 一些要注意的信息"></a>3.9 一些要注意的信息</h3><h4 id="交易状态流程"><a href="#交易状态流程" class="headerlink" title="交易状态流程"></a>交易状态流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/179989/1662454282907-29e733cb-88ce-443a-b045-47ffef16ab67.png" alt="p3"></p><p>随着订单支付成功、退款、关闭等操作，订单交易的每一个环节 trade_status（交易状态）也不同。</p><ol><li>交易创建成功后，用户支付成功，交易状态转为 <strong>TRADE_SUCCESS（交易成功）</strong>。</li><li>交易成功后，规定退款时间内没有退款，交易状态转为 <strong>TRADE_FINISHED（交易完成）</strong>。</li><li>交易支付成功后，交易部分退款，交易状态仍为 <strong>TRADE_SUCCESS（交易成功）</strong>。</li><li>交易成功后，交易全额退款，交易状态转为 <strong>TRADE_CLOSED（交易关闭）</strong>。</li><li>交易创建成功后，用户未付款交易超时关闭，交易状态转为 <strong>TRADE_CLOSED（交易关闭）</strong>。</li><li>交易创建成功后，用户支付成功后，若用户商品不支持退款，交易状态直接转为 <strong>TRADE_FINISHED（交易完成）</strong>。</li></ol><p><strong>注意</strong>：交易成功后部分退款，交易状态仍为 TRADE_SUCCESS（交易成功）。</p><p>如果一直部分退款退完所有交易金额则交易状态转为 TRADE_CLOSED（交易关闭）。</p><p>如果未退完所有交易金额，超过有效退款时间后交易状态转为 TRADE_FINISHED（交易完成）不可退款。</p><h4 id="异步通知："><a href="#异步通知：" class="headerlink" title="异步通知："></a>异步通知：</h4><p>先上代码：</p><pre><code class="java">@PostMapping("/appNotify")public String notifyAppPay(HttpServletRequest request) throws ApiException {    System.out.println("app收到异步通知=====支付宝回调");    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();    Map&lt;String, String[]&gt; requestParams = request.getParameterMap();    for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = iter.next();        String[] values = requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        params.put(name, valueStr);    }    System.out.println(JSON.serialize(params));    // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）    boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");    if (verified) {        System.out.println("支付异步验签成功");        String tradeStatus = params.get("trade_status");        //总退款金额        String refundFee = params.get("refund_fee");        //交易退款时间        String gmtRefund = params.get("gmt_refund");        if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("支付成功异步通知");            }            if ("TRADE_CLOSED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }            if ("TRADE_FINISHED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }        }else {            System.out.println("退款异步通知");            String gmtClose = params.get("gmt_close");            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("部分退款异步通知");            }            //全额退款，或者最后一次部分退款            if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                System.out.println("全额退款异步通知");            }        }        return "success";    }else {        System.out.println("支付异步验签失败，支付失败");        return "failure";    }}</code></pre><p>交易退款接口触发异步通知:<a href="https://opendocs.alipay.com/open-v3/05w4kp?pathHash=f3e513ea">产品介绍 - 支付宝文档中心</a>，前面已经说了，退款不建议在异步通知中处理，可以调用退款查询接口来判断，</p><p><a href="https://opendocs.alipay.com/support/01rawa">如何判断退款是否成功 - 支付宝文档中心</a>。</p><p>这里的交易退款接口是指统一收单交易退款接口（<a href="https://docs.open.alipay.com/api_1/alipay.trade.refund">alipay.trade.refund</a>），统一收单交易退款接口本身接口不支持设置 notify_url 参数，因此退款导致触发的异步通知是发送到支付接口中设置的 notify_url。</p><p>历史版本的退款接口 refund_fastpay_by_platform_pwd（即时到账有密退款接口）不同于新版本的统一收单交易退款接口（alipay.trade.refund）。历史版本的退款接口本身支持设置 notify_url，但由于历史接口目前不支持签约，无法使用等情况，本文只阐述新版本的统一收单交易退款接口（alipay.trade.refund）是否会触发异步通知。</p><p>以下是交易状态说明：</p><p><img src="https://gw.alipayobjects.com/zos/workflow/workflow/202002261582698731390_3381f68343d8db05198d25bbf1eb6049.png" alt="img"></p><h4 id="触发异步通知条件"><a href="#触发异步通知条件" class="headerlink" title="触发异步通知条件"></a>触发异步通知条件</h4><p>异步通知是根据交易状态的改变进行触发的，不同的支付产品触发异步通知的条件不同。</p><table><thead><tr><th>产品</th><th>触发异步通知条件</th></tr></thead><tbody><tr><td>当面付</td><td>当面付的支付接口，详见 <a href="https://docs.open.alipay.com/194/103296/#s1">当面付异步通知-仅用于扫码支付</a>默认 TRADE_SUCCESS（交易成功）触发。TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）、WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr><tr><td>App 支付</td><td>App 支付接口，详见 <a href="https://docs.open.alipay.com/204/105301/#s2">App 支付异步通知触发条件</a>默认 TRADE_SUCCESS（交易成功）、TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）三种状态均会触发异步通知。WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr><tr><td>手机网站支付</td><td>手机网站支付接口，详见<a href="https://docs.open.alipay.com/203/105286/#s2">手机网站支付结果异步通知触发条件</a>默认 TRADE_SUCCESS（交易成功）、TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）三种状态均会触发异步通知。WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr><tr><td>电脑网站支付</td><td>电脑网站支付接口，详见<a href="https://docs.open.alipay.com/270/105902/#s2">电脑网站支付异步通知触发条件</a>默认 TRADE_SUCCESS（交易成功）状态触发异步通知。TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）、WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr></tbody></table><h4 id="退款是否会收到异步"><a href="#退款是否会收到异步" class="headerlink" title="退款是否会收到异步"></a>退款是否会收到异步</h4><p>根据退款的行为可分为全额退款和部分退款。</p><ul><li>全额退款，交易状态变为 TRADE_CLOSED（交易关闭）。只有 App 支付和手机网站支付交易状态变为 TRADE_CLOSED（交易关闭）会触发异步通知。</li><li>部分退款，交易状态仍为 TRADE_SUCCESS（交易成功）。当面付、电脑网站支付、App 支付和手机网站支付交易状态为 TRADE_SUCCESS（交易成功）都会触发异步通知。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于不同操作导致不同的交易状态，异步通知对交易状态的常见问题如下。</p><ul><li><a href="https://opendocs.alipay.com/support/01rawd">异步通知如何区分全额退款和部分退款</a></li><li><a href="https://opendocs.alipay.com/support/01rawe">异步通知如何区分全额退款和订单超时导致的交易关闭</a></li><li><a href="https://opendocs.alipay.com/support/01rawf">异步通知如何判断对应哪笔退款交易</a></li></ul><h4 id="关于异步通知的验签"><a href="#关于异步通知的验签" class="headerlink" title="关于异步通知的验签"></a>关于异步通知的验签</h4><p>收到异步通知后需要先验签，V3的SDK提供的验签方法与V2相比，换了方法。</p><pre><code class="java">// SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）  boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");</code></pre><p>当然也可以自定义方法验签。</p><h3 id="4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。"><a href="#4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。" class="headerlink" title="4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。"></a>4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。</h3><pre><code class="java">package com.zqg.pay.alipay.web;import com.alipay.v3.ApiClient;import com.alipay.v3.ApiException;import com.alipay.v3.Configuration;import com.alipay.v3.JSON;import com.alipay.v3.api.AlipayTradeApi;import com.alipay.v3.api.AlipayTradeFastpayRefundApi;import com.alipay.v3.model.*;import com.alipay.v3.util.AlipaySignature;import com.alipay.v3.util.GenericExecuteApi;import com.alipay.v3.util.model.AlipayConfig;import com.alipay.v3.util.model.CustomizedParams;import org.apache.commons.lang3.StringUtils;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.*;@RestController@RequestMapping("/pay")public class PayController {    /**     * https://opendocs.alipay.com/open-v3/2423fad5_alipay.trade.page.pay?scene=22&amp;pathHash=b20c762a     *     * @param response     * @return String     * @throws ApiException     * @throws IOException     */    @GetMapping(value = "/payOrder",produces = "text/html;charset=UTF-8")    public String pay(HttpServletResponse response) throws ApiException, IOException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        GenericExecuteApi api = new GenericExecuteApi();        // 构造请求参数以调用接口        Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;();        // 设置商户订单号        bizContent.put("out_trade_no", String.valueOf(System.currentTimeMillis()));        // 设置订单总金额        bizContent.put("total_amount", "6.88");        // 设置订单标题        bizContent.put("subject", "测试电脑网站支付");        // 设置产品码        bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");        // 设置订单附加信息       // bizContent.put("body", "http://localhost:8080/hello");        // 设置PC扫码支付的方式        bizContent.put("qr_pay_mode", "2");        // 设置商户自定义二维码宽度        //bizContent.put("qrcode_width", 100);        // 设置订单包含的商品列表信息        List&lt;Map&lt;String, Object&gt;&gt; goodsDetail = new ArrayList&lt;&gt;();        Map&lt;String, Object&gt; goodsDetail0 = new HashMap&lt;&gt;();        goodsDetail0.put("out_sku_id", "outSku_01");        goodsDetail0.put("goods_name", "ipad");        goodsDetail0.put("alipay_goods_id", "20010001");        goodsDetail0.put("quantity", 1);        goodsDetail0.put("price", 2000);        goodsDetail0.put("out_item_id", "outItem_01");        goodsDetail0.put("goods_id", "apple-01");        goodsDetail0.put("goods_category", "34543238");        goodsDetail0.put("categories_tree", "124868003|126232002|126252004");        goodsDetail0.put("show_url", "http://www.alipay.com/xxx.jpg");        goodsDetail.add(goodsDetail0);        //bizContent.put("goods_detail", goodsDetail);        // 设置订单绝对超时时间      //  bizContent.put("time_expire", "2024-12-31 10:05:01");        // 设置建议使用time_expire字段      //  bizContent.put("timeout_express", "90m");        // 设置描述分账信息        Map&lt;String, Object&gt; royaltyInfo = new HashMap&lt;&gt;();        royaltyInfo.put("royalty_type", "ROYALTY");        List&lt;Map&lt;String, Object&gt;&gt; royaltyDetailInfos = new ArrayList&lt;&gt;();        Map&lt;String, Object&gt; royaltyDetailInfos0 = new HashMap&lt;&gt;();        royaltyDetailInfos0.put("out_relation_id", "20131124001");        royaltyDetailInfos0.put("amount_percentage", "100");        royaltyDetailInfos0.put("amount", "0.1");        royaltyDetailInfos0.put("batch_no", "123");        royaltyDetailInfos0.put("trans_in", "2088101126708402");        royaltyDetailInfos0.put("trans_out_type", "userId");        royaltyDetailInfos0.put("trans_out", "2088101126765726");        royaltyDetailInfos0.put("serial_no", 1);        royaltyDetailInfos0.put("trans_in_type", "userId");        royaltyDetailInfos0.put("desc", "分账测试1");        royaltyDetailInfos.add(royaltyDetailInfos0);        royaltyInfo.put("royalty_detail_infos", royaltyDetailInfos);       // bizContent.put("royalty_info", royaltyInfo);        // 设置二级商户信息        Map&lt;String, Object&gt; subMerchantvxgvh = new HashMap&lt;&gt;();        subMerchantvxgvh.put("merchant_id", "2088000603999128");        subMerchantvxgvh.put("merchant_type", "alipay");        //bizContent.put("sub_merchant", subMerchantvxgvh);        // 设置描述结算信息        Map&lt;String, Object&gt; settleInfo = new HashMap&lt;&gt;();        settleInfo.put("settle_period_time", "7d");        List&lt;Map&lt;String, Object&gt;&gt; settleDetailInfos = new ArrayList&lt;&gt;();        Map&lt;String, Object&gt; settleDetailInfos0 = new HashMap&lt;&gt;();        settleDetailInfos0.put("amount", "0.1");        settleDetailInfos0.put("trans_in", "A0001");        settleDetailInfos0.put("settle_entity_type", "SecondMerchant");        settleDetailInfos0.put("summary_dimension", "A0001");        settleDetailInfos0.put("actual_amount", "0.1");        settleDetailInfos0.put("settle_entity_id", "2088xxxxx;ST_0001");        settleDetailInfos0.put("trans_in_type", "cardAliasNo");        settleDetailInfos.add(settleDetailInfos0);        settleInfo.put("settle_detail_infos", settleDetailInfos);       // bizContent.put("settle_info", settleInfo);        // 设置业务扩展参数        Map&lt;String, Object&gt; extendParams = new HashMap&lt;&gt;();        extendParams.put("sys_service_provider_id", "2088511833207846");        extendParams.put("hb_fq_seller_percent", "100");        extendParams.put("hb_fq_num", "3");        extendParams.put("tc_installment_order_id", "2015042321001004720200028594");        extendParams.put("industry_reflux_info", "{\"scene_code\":\"metro_tradeorder\",\"channel\":\"xxxx\",\"scene_data\":{\"asset_name\":\"ALIPAY\"}}");        extendParams.put("specified_seller_name", "XXX的跨境小铺");        extendParams.put("royalty_freeze", "true");        extendParams.put("card_type", "S0JP0000");        extendParams.put("credit_ext_info", "{\"category\":\"CHARGE_PILE_CAR\",\"serviceId\":\"2020042800000000000001450466\"}");        extendParams.put("trade_component_order_id", "2023060801502300000008810000005657");       // bizContent.put("extend_params", extendParams);        // 设置商户传入业务信息       // bizContent.put("business_params", "{\"mc_create_trade_ip\":\"127.0.0.1\"}");        // 设置优惠参数      //  bizContent.put("promo_params", "{\"storeIdType\":\"1\"}");        // 设置请求后页面的集成方式      //  bizContent.put("integration_type", "PCWEB");        // 设置请求来源地址       // bizContent.put("request_from_url", "https://");        // 设置签约参数        Map&lt;String, Object&gt; agreementSignParams = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; subMerchantRWfdn = new HashMap&lt;&gt;();        subMerchantRWfdn.put("sub_merchant_name", "滴滴出行");        subMerchantRWfdn.put("sub_merchant_service_name", "滴滴出行免密支付");        subMerchantRWfdn.put("sub_merchant_service_description", "免密付车费，单次最高500");        subMerchantRWfdn.put("sub_merchant_id", "2088123412341234");        agreementSignParams.put("sub_merchant", subMerchantRWfdn);        agreementSignParams.put("buckle_app_id", "1001164");        agreementSignParams.put("sign_validity_period", "2m");        agreementSignParams.put("buckle_merchant_id", "268820000000414397785");        agreementSignParams.put("external_logon_id", "138****8888");        agreementSignParams.put("third_party_type", "PARTNER");        agreementSignParams.put("personal_product_code", "GENERAL_WITHHOLDING_P");        agreementSignParams.put("external_agreement_no", "test");        agreementSignParams.put("promo_params", "{\"key\",\"value\"}");        agreementSignParams.put("sign_scene", "INDUSTRY|CARRENTAL");      //  bizContent.put("agreement_sign_params", agreementSignParams);        // 设置商户门店编号      //  bizContent.put("store_id", "NJ_001");        // 设置指定支付渠道       // bizContent.put("enable_pay_channels", "pcredit,moneyFund,debitCardExpress");        // 设置禁用渠道      //  bizContent.put("disable_pay_channels", "pcredit,moneyFund,debitCardExpress");        // 设置商户的原始订单号      //  bizContent.put("merchant_order_no", "20161008001");        // 设置外部指定买家        Map&lt;String, Object&gt; extUserInfo = new HashMap&lt;&gt;();        extUserInfo.put("cert_type", "IDENTITY_CARD");        extUserInfo.put("cert_no", "362334768769238881");        extUserInfo.put("name", "李明");        extUserInfo.put("mobile", "16587658765");        extUserInfo.put("min_age", "18");        extUserInfo.put("need_check_info", "F");        extUserInfo.put("identity_hash", "27bfcd1dee4f22c8fe8a2374af9b660419d1361b1c207e9b41a754a113f38fcc");       // bizContent.put("ext_user_info", extUserInfo);        // 设置开票信息        Map&lt;String, Object&gt; invoiceInfo = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; keyInfo = new HashMap&lt;&gt;();        keyInfo.put("tax_num", "1464888883494");        keyInfo.put("is_support_invoice", true);        keyInfo.put("invoice_merchant_name", "ABC|003");        invoiceInfo.put("key_info", keyInfo);        invoiceInfo.put("details", "[{\"code\":\"100294400\",\"name\":\"服饰\",\"num\":\"2\",\"sumPrice\":\"200.00\",\"taxRate\":\"6%\"}]");       // bizContent.put("invoice_info", invoiceInfo);        // 设置返回参数选项        List&lt;String&gt; queryOptions = new ArrayList&lt;&gt;();        queryOptions.add("hyb_amount");        queryOptions.add("enterprise_pay_info");       // bizContent.put("query_options", queryOptions);        bizParams.put("biz_content", bizContent);        //return_url 必须是 http 或 https 开头的完整的 url 地址。        //return_url 地址后不可带自定义参数。        //设置 return_url 时不要进行转义、urlencode 等数据处理。        //当面付和APP支付不支持 return_url 参数，即使设置了也没有任何效果。        //同步通知参数只可参考，不能作为判断是否支付成功的依据。        bizParams.put("return_url", "https://docs.open.alipay.com");        bizParams.put("notify_url", "http://lql5520.yunmv.cn/pay/pcNotify");        try {            //rpvexb4275@sandbox.com            System.out.println(JSON.serialize(bizParams));            System.out.println("==============================");            // 如果是第三方代调用模式，请设置app_auth_token（应用授权令牌）            String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "POST", bizParams);            // 如果需要返回GET请求，请使用            // String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "GET", bizParams);            System.out.println(pageRedirectionData);            return pageRedirectionData;         /*  //produces = "text/html"            response.setContentType("text/html;charset=UTF-8");            PrintWriter out = response.getWriter();            out.write(pageRedirectionData);            out.flush();            out.close();            */        } catch (ApiException e) {            System.out.println("调用失败");        }        return "";    }    /**     * https://opendocs.alipay.com/support/01rawc?pathHash=4ad70fe3     * App 支付   App 支付接口，详见 App 支付异步通知触发条件     * 默认 TRADE_SUCCESS（交易成功）、TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）三种状态均会触发异步通知。     * WAIT_BUYER_PAY（交易创建）不触发异步通知。     *     * 电脑网站支付   电脑网站支付接口，详见电脑网站支付异步通知触发条件     * 默认 TRADE_SUCCESS（交易成功）状态触发异步通知。     * TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）、WAIT_BUYER_PAY（交易创建）不触发异步通知。     *     * 退款是否会收到异步     * 根据退款的行为可分为全额退款和部分退款。     * ● 全额退款，交易状态变为 TRADE_CLOSED（交易关闭）。只有 App 支付和手机网站支付交易状态变为 TRADE_CLOSED（交易关闭）会触发异步通知。     * ● 部分退款，交易状态仍为 TRADE_SUCCESS（交易成功）。当面付、电脑网站支付、App 支付和手机网站支付交易状态为 TRADE_SUCCESS（交易成功）都会触发异步通知。     * 如何区分部分退款和全额退款： https://opendocs.alipay.com/support/01rawd     *     * 25 小时以内完成 8 次通知（通知的间隔频率一般是 4m，10m，10m，1h，2h，6h，15h）     * @param request     * @return     * @throws ApiException     */    @PostMapping("/pcNotify")    public String notifyPay(HttpServletRequest request) throws ApiException {        System.out.println("电脑网站收到异步通知=====支付宝回调");        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        Map&lt;String, String[]&gt; requestParams = request.getParameterMap();        for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {            String name = iter.next();            String[] values = requestParams.get(name);            String valueStr = "";            for (int i = 0; i &lt; values.length; i++) {                valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";            }            params.put(name, valueStr);        }        //{"gmt_create":"2024-12-19 14:04:16","charset":"UTF-8","gmt_payment":"2024-12-19 14:04:31","notify_time":"2024-12-19 14:04:33","subject":"测试电脑网站支付","sign":"XAzGwc/dZ6ON1TwXvw92GnhF7X4PTZNJ6h6TfH/5T0sgfTtIRVgnny150B7Ip1xHgjpuNoz+T8XlMpMNgvkpxNlcWmlbDfs72Ls/OyyV7ttEKgRos4VWKIrojJ1Apy06H9kie6cCfmBC3mmW9Gh+QAh5oejdZDSq+NDgJIjBlz8S6x85GEQ0BprcVHDfPKubaOWl5nCri7YKxTPOLZcqwTgV9mWXzoIa9hSp32bqyTiLtDlM1h5Z7IJKuj9/EhKuOAz6PF/vws/lftp9gzG3bJVkwwP4z50neyJNWzENIHIKQoGDInZF+T2yNyJJ0YPg/x8LejPzyfdkHjM9bZjBEA\u003d\u003d","buyer_id":"2088722013720112","invoice_amount":"6.88","version":"1.0","notify_id":"2024121901222140432120110505059148","fund_bill_list":"[{\"amount\":\"6.88\",\"fundChannel\":\"ALIPAYACCOUNT\"}]","notify_type":"trade_status_sync","out_trade_no":"1734588234593","total_amount":"6.88","trade_status":"TRADE_SUCCESS","trade_no":"2024121922001420110504898164","auth_app_id":"9021000128652691","receipt_amount":"6.88","point_amount":"0.00","buyer_pay_amount":"6.88","app_id":"9021000128652691","sign_type":"RSA2","seller_id":"2088721013742803"}        System.out.println(JSON.serialize(params));        // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）        boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");        if (verified) {            //todo 参数验证，out_trade_no，total_amount等            //1. 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。            //2. 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）。            //3. 校验通知中的 seller_id（或者 seller_email ) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个seller_id/seller_email）。            //4. 验证 app_id 是否为该商家本身。            System.out.println("支付异步验签成功");            String tradeStatus = params.get("trade_status");            //总退款金额            String refundFee = params.get("refund_fee");            //交易退款时间            String gmtRefund = params.get("gmt_refund");            if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){                //只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功。                if ("TRADE_SUCCESS".equals(tradeStatus) || "TRADE_FINISHED".equals(tradeStatus)) {                    System.out.println("支付成功异步通知");                }            }else {                System.out.println("退款异步通知");                String gmtClose = params.get("gmt_close");                if ("TRADE_SUCCESS".equals(tradeStatus)) {                    //最后一次部分退款没有通知，因为状态已经变成TRADE_CLOSED                    System.out.println("部分退款异步通知");                }                //电脑网站支付应该不会有全额退款通知，因为TRADE_CLOSED不会触发异步通知                if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                    System.out.println("全额退款异步通知");                }            }            return "success";        }else {            System.out.println("验签失败，支付失败");            return "failure";        }    }    @PostMapping("/appNotify")    public String notifyAppPay(HttpServletRequest request) throws ApiException {        System.out.println("app收到异步通知=====支付宝回调");        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        Map&lt;String, String[]&gt; requestParams = request.getParameterMap();        for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {            String name = iter.next();            String[] values = requestParams.get(name);            String valueStr = "";            for (int i = 0; i &lt; values.length; i++) {                valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";            }            params.put(name, valueStr);        }        System.out.println(JSON.serialize(params));        // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）        boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");        if (verified) {            System.out.println("支付异步验签成功");            String tradeStatus = params.get("trade_status");            //总退款金额            String refundFee = params.get("refund_fee");            //交易退款时间            String gmtRefund = params.get("gmt_refund");            if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){                if ("TRADE_SUCCESS".equals(tradeStatus)) {                    System.out.println("支付成功异步通知");                }                if ("TRADE_CLOSED".equals(tradeStatus)) {                    System.out.println("交易关闭异步通知");                }                if ("TRADE_FINISHED".equals(tradeStatus)) {                    System.out.println("交易关闭异步通知");                }            }else {                System.out.println("退款异步通知");                String gmtClose = params.get("gmt_close");                if ("TRADE_SUCCESS".equals(tradeStatus)) {                    System.out.println("部分退款异步通知");                }                //全额退款，或者最后一次部分退款                if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                    System.out.println("全额退款异步通知");                }            }            return "success";        }else {            System.out.println("支付异步验签失败，支付失败");            return "failure";        }    }    @GetMapping("/queryOrder")    public String queryPage(String orderNo) throws ApiException {        //1733990822574        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeQueryModel data = new AlipayTradeQueryModel();        // 设置订单支付时传入的商户订单号        data.setOutTradeNo(orderNo);        try {            AlipayTradeQueryResponseModel response = api.query(data);            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeQueryDefaultResponse errorObject = (AlipayTradeQueryDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    @GetMapping(value = "/payAppOrder")    public String payOrderApp() throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        GenericExecuteApi api = new GenericExecuteApi();        // 构造请求参数以调用接口        Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;();        // 设置商户订单号        bizContent.put("out_trade_no", "70501111111S001111119");        // 设置订单总金额        bizContent.put("total_amount", "9.00");        // 设置订单标题        bizContent.put("subject", "大乐透");        // 设置产品码        bizContent.put("product_code", "QUICK_MSECURITY_PAY");        // 设置订单附加信息        bizContent.put("body", "Iphone6 16G");        // 设置订单绝对超时时间        bizContent.put("time_expire", "2024-12-31 10:05:00");        // 设置建议使用time_expire字段        bizContent.put("timeout_express", "90m");        bizParams.put("biz_content", bizContent);        // 同步回调指定的页面 app不需要       // bizParams.put("return_url", "https://docs.open.alipay.com");        bizParams.put("notify_url", "http://xxxx/pay/appNotify");        try {            String orderStr = api.sdkExecute("alipay.trade.app.pay", bizParams);            System.out.println(orderStr);            return orderStr;        } catch (ApiException e) {            System.out.println("调用失败");        }        return "";    }    /**     * 预下单（沙箱环境调用显示无权限；ACCESS_FORBIDDEN）     * @return     * @throws ApiException     */    @GetMapping(value = "/createPay")    public String getOrderPreCreatePay() throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi alipayTradeApi = new AlipayTradeApi();        AlipayTradePrecreateModel model = new AlipayTradePrecreateModel();        model.setOutTradeNo(String.valueOf(System.currentTimeMillis()));        model.setTotalAmount("9.00");        model.setSubject("扫码测试");        model.setProductCode("QR_CODE_OFFLINE");        model.setNotifyUrl("http://xxxx/pay/notify");        try {            AlipayTradePrecreateResponseModel responseModel = alipayTradeApi.precreate(model);            //{"code":"ACQ.ACCESS_FORBIDDEN","message":"ACCESS_FORBIDDEN"} 没有权限，沙箱环境没有alipay.trade.precreate权限            System.out.println("调用成功："+JSON.serialize(responseModel));            return responseModel.getQrCode();        } catch (ApiException e) {            System.out.println("调用失败:"+e);        }        return "";    }    @GetMapping(value = "/createPay2",produces = "text/html;charset=UTF-8")    public String getOrderPreCreatePay2() throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        GenericExecuteApi api = new GenericExecuteApi();        HashMap&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;();        HashMap&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;();        bizContent.put("out_trade_no", String.valueOf(System.currentTimeMillis()));        bizContent.put("total_amount", "9.00");        bizContent.put("subject", "扫码测试");        bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");        /**         * 支持前置模式和跳转模式。         * 前置模式是将二维码前置到商户的订单确认页的模式。需要商户在自己的页面中以 iframe 方式请求支付宝页面。具体支持的枚举值有以下几种：         * 0：订单码-简约前置模式，对应 iframe 宽度不能小于600px，高度不能小于300px；         * 1：订单码-前置模式，对应iframe 宽度不能小于 300px，高度不能小于600px；         * 3：订单码-迷你前置模式，对应 iframe 宽度不能小于 75px，高度不能小于75px；         * 4：订单码-可定义宽度的嵌入式二维码，商户可根据需要设定二维码的大小。         * 跳转模式下，用户的扫码界面是由支付宝生成的，不在商户的域名下。支持传入的枚举值有：         * 2：订单码-跳转模式         */        bizContent.put("qr_pay_mode", "4");        bizContent.put("qrcode_width", 100);        bizParams.put("notify_url", "http://lql5520.yunmv.cn/pay/pcNotify");        bizParams.put("return_url", "https://docs.open.alipay.com");        bizParams.put("biz_content", bizContent);        try {            String form = api.pageExecute("alipay.trade.page.pay", "POST", bizParams);            System.out.println("调用成功："+JSON.serialize(form));            return form;        } catch (ApiException e) {            System.out.println("调用失败:"+e);        }        return "";    }    /**     * https://opendocs.alipay.com/open-v3/01073208_alipay.trade.refund     * 退款时根据异步的返回信息可进行判断，但部分接口存在全额退款时不进行触发异步（电脑网站支付，全额退款时，TRADE_CLOSED,没有异步通知），     * 因此建议根据退款同步响应参数以及退款查询接口进行判断。     *     * 部分退款：     * 检查是否设置out_request_no参数，该参数是标识一次退款请求，同一笔交易多次退款需要保证唯一，且 部分退款，则此参数必传。     * @param orderNo     * @param amount     * @return     * @throws ApiException     */    @GetMapping ("/refundPay")    public String refundPay(String orderNo,String amount) throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        // 构造请求参数以调用接口        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeRefundModel data = new AlipayTradeRefundModel();        // 部分退款时,outRequestNo必传,同一笔交易多次退款需要保证唯一        data.outRequestNo(String.valueOf(System.currentTimeMillis()));        data.setOutTradeNo(orderNo);        data.setRefundAmount(amount);        data.setRefundReason("测试退款");        // 第三方代调用模式下请设置app_auth_token        CustomizedParams params = new CustomizedParams();        params.setAppAuthToken("&lt;-- 请填写应用授权令牌 --&gt;");        try {            AlipayTradeRefundResponseModel response = api.refund(data);            //{"buyer_logon_id":"rpv***@sandbox.com","buyer_user_id":"2088722013720112","fund_change":"Y","gmt_refund_pay":"2024-12-19 14:16:39","out_trade_no":"1734423455786","refund_fee":"15.88","send_back_fee":"0.00","trade_no":"2024121722001420110504891744"}            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeRefundDefaultResponse errorObject = (AlipayTradeRefundDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    /**     * 退款查询接口返回 refund_status=REFUND_SUCCESS 表示退款处理成功，否则表示退款没有执行成功。     * @param orderNo     * @return     * @throws ApiException     */    @GetMapping ("/refundPayQuery")    public String refundPayQuery(String orderNo,String outRequestNo) throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        // 构造请求参数以调用接口        AlipayTradeFastpayRefundApi api = new AlipayTradeFastpayRefundApi();        AlipayTradeFastpayRefundQueryModel data = new AlipayTradeFastpayRefundQueryModel();        data.setOutTradeNo(orderNo);        //部分退款需要传入，哪次退款的outRequestNo        data.setOutRequestNo(outRequestNo);        // 第三方代调用模式下请设置app_auth_token        CustomizedParams params = new CustomizedParams();        params.setAppAuthToken("&lt;-- 请填写应用授权令牌 --&gt;");        try {            AlipayTradeFastpayRefundQueryResponseModel response = api.query(data);            //{"out_request_no":"1734575090879","out_trade_no":"1734575090879","refund_amount":"5.88","refund_status":"REFUND_SUCCESS","total_amount":"5.88","trade_no":"2024121922001420110504904489"}            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeFastpayRefundQueryDefaultResponse errorObject = (AlipayTradeFastpayRefundQueryDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    @GetMapping("/closeOrder")    public String close(String orderNo) throws ApiException {        //1733990822574        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeCloseModel data = new AlipayTradeCloseModel();        // 设置订单支付时传入的商户订单号        data.setOutTradeNo(orderNo);        try {            AlipayTradeCloseResponseModel response = api.close(data);            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeCloseDefaultResponse errorObject = (AlipayTradeCloseDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    @GetMapping("/cancelOrder")    public String cancel(String orderNo) throws ApiException {        //1733990822574        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeCancelModel data = new AlipayTradeCancelModel();        // 设置订单支付时传入的商户订单号        data.setOutTradeNo(orderNo);        try {            AlipayTradeCancelResponseModel response = api.cancel(data);            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeCancelDefaultResponse errorObject = (AlipayTradeCancelDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject.getAlipayTradeCancelErrorResponseModel());        }        return "";    }    private AlipayConfig getAlipayConfig() {        AlipayConfig alipayConfig = new AlipayConfig();        //alipayConfig.setServerUrl("https://openapi.alipay.com");        alipayConfig.setServerUrl("https://openapi-sandbox.dl.alipaydev.com");        alipayConfig.setAppId("902xxxxxxx");        alipayConfig.setPrivateKey("MIIEvAIBADAxxxxx");        alipayConfig.setAlipayPublicKey("MIIBIjANxxxxxx");        return alipayConfig;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Alipay </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/06/05/hello-world/"/>
      <url>/2024/06/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建自己的专属博客</title>
      <link href="/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="教程-Hexo-Github-搭建自己的专属博客"><a href="#教程-Hexo-Github-搭建自己的专属博客" class="headerlink" title="[教程]Hexo + Github 搭建自己的专属博客"></a><strong>[教程]Hexo + Github 搭建自己的专属博客</strong></h1><p>教程来自<a href="https://blog.csdn.net/2301_76761656/article/details/137087231">【Hexo + Github 搭建自己的专属博客】_wudreamer.github-CSDN博客</a>，自己实操并修改了一些内容。</p><h2 id="1-安装Git和NodeJS"><a href="#1-安装Git和NodeJS" class="headerlink" title="1. 安装Git和NodeJS"></a><strong>1. 安装Git和NodeJS</strong></h2><p>在Windows上使用Git，可以从Git官网直接 <a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>在Git中绑定Github账号，打开“Git Bash”，在命令框中依次输入两行命令：</p><pre><code class="bash">git config --global user.name "Your Name"git config --global user.email "email@example.com"# 其中Your Name和email@example.com替换成上面注册时的账户名和邮箱</code></pre><p>由于 Hexo 是基于 Node.js 驱动的一款博客框架，所以安装NodeJS <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 并配置环境变量。安装之后可以输入以下命令查看是否安装成功：</p><pre><code class="bash">git versionnode -vnpm -v</code></pre><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a><strong>2. 安装Hexo</strong></h2><p>以上环境准备好了就可使用 npm 开始安装 Hexo 了，在命令行输入执行如下命令：</p><pre><code class="bash">npm install -g hexo-cli</code></pre><p>安装 Hexo 完成后，在指定文件夹下打开“Git Bash”，再执行下列命令，Hexo 将会在指定文件夹中新建所须要的文件：</p><pre><code class="bash">hexo init myBlogcd myBlognpm install</code></pre><p>若是上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a><a href="http://localhost:4000/"> </a>回车就能够预览效果了。</p><h2 id="3-加载主题"><a href="#3-加载主题" class="headerlink" title="3. 加载主题"></a><strong>3. 加载主题</strong></h2><p>大家可以去官网上找自己喜欢的主题下载<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><a href="https://hexo.io/themes/"> </a>，自己采用的主题是<a href="https://github.com/Siricee/hexo-theme-Chic">https://github.com/Siricee/hexo-theme-Chic</a> ，这款有明暗两种颜色。</p><p>基本大家用的最多的是NEXT主题：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a>随后将下载的主题文件夹放在 myblog/themes中，在 _config.yml文件中修改theme 为hexo-theme-Chic(注意和主题文件名一致)</p><p>本人用的是<a href="https://gitee.com/tencent_m/hexo-theme-Claudia">hexo-theme-Claudia</a>。</p><p>修改好之后在“Git Bash”中执行 hexo g 命令，然后再 hexo s，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 回车就能够预览修改主题后的效果了。</p><h2 id="4-修改主题配置"><a href="#4-修改主题配置" class="headerlink" title="4. 修改主题配置"></a><strong>4. 修改主题配置</strong></h2><p>修改在主题文件夹下的 _config.yml文件，完成自己个人的配置。</p><pre><code class="yaml"># Headernavname: Bentham's Blog# navigatior itemsnav:  Posts: /archives  Categories: /category  Tags: /tag  About: /about# faviconfavicon: /favicon.ico# Profilenickname: Jeremy Bentham### this variable is MarkDown form.description: Lorem ipsum dolor sit amet, **consectetur adipiscing elit.** &lt;br&gt;Fusce eget urna vitae velit *eleifend interdum at ac* nisi.avatar: /image/avatar.jpeg# main menu navigation## links key words should not be changed.## Complete url after key words.## Unused key can be commented out.links:  Blog: /archives  # Category:  # Tags:   # Link:  # Resume:  # Publish:  # Trophy:  # Gallery:  # RSS:  # AliPay:  ZhiHu: https://www.zhihu.com/people/sirice  # LinkedIn:  # FaceBook:  # Twitter:  # Skype:  # CodeSandBox:  # CodePen:  # Sketch:  # Gitlab:  # Dribbble:  Instagram:  Reddit:  # YouTube:  # QQ:  # Weibo:  # WeChat:  Github: https://github.com/Siricee# how links show: you have 2 choice--text or icon.links_text_enable: falselinks_icon_enable: true# Post page## Post_metapost_meta_enable: truepost_author_enable: truepost_date_enable: truepost_category_enable: true## Post copyrightpost_copyright_enable: truepost_copyright_author_enable: truepost_copyright_permalink_enable: truepost_copyright_license_enable: truepost_copyright_license_text: Copyright (c) 2019 &lt;a href="http://creativecommons.org/licenses/by-nc/4.0/"&gt;CC-BY-NC-4.0&lt;/a&gt; LICENSEpost_copyright_slogan_enable: truepost_copyright_slogan_text: Do you believe in &lt;strong&gt;DESTINY&lt;/strong&gt;?## tocpost_toc_enable: true# Pagepage_title_enable: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMMM D, YYYYtime_format: H:mm:ss# stylesheets loaded in the &lt;head&gt;stylesheets:  - /css/style.css# scripts loaded in the end of the bodyscripts:  - /js/script.js  - /js/tocbot.min.js    # tscanlin/tocbot: Build a table of contents from headings in an HTML document.    # https://github.com/tscanlin/tocbot# plugin functions## Mathjax: Math Formula Support## https://www.mathjax.orgmathjax:  enable: true  import: demand # global or demand  ## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong.  ## demand: Recommend option,if your post need fomula, you can declare 'mathjax: true' in Front-matter</code></pre><p>hexo-theme-Claudia的_config.yml文件如下：</p><pre><code class="yaml"># main menu navigationmenu:  Home: /  About: /about  Archive: /archiveswidgets:  - tag  - archive  - recent_posts  - category  - profile# social configsocial:  zhihu:  twitter: /  facebook: /  linkedin:  instagram: /  github: haojenuser:  name: Haojen  avatar: /images/avatar.jpg  location: In the dust  description: May the Force be with you  footnotes: #footnotes# documents: https://github.com/utterance/utterances# API config: https://utteranc.es/comment_utteranc:  enable: true  repo: Haojen/Claudia-theme-blog # your blog repo# documents: https://valine.js.org/quickstart.htmlcomment_valine:  enable: false  appId:  appKey:# dark# light# user-can-setappearance: auto # Default value is auto# Miscellaneousfavicon: /images/favicon.png# Google Analyticsga_track_id:ga_domain:# Baidu Analyticsba_track_id:</code></pre><h2 id="5-将博客部署在GitHub上"><a href="#5-将博客部署在GitHub上" class="headerlink" title="5. 将博客部署在GitHub上"></a><strong>5. 将博客部署在GitHub上</strong></h2><p>点击 Start project 或者下面的 new repository 建立一个新的仓库，注意<strong>Github 仅能使用一个同名仓库的代码托管一个静态站点</strong>，这里注意仓库名一定要是： 用户名.github.io</p><p>配置 SSH key ，要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 作准备。</p><pre><code class="bash">git config --global user.name "用户名"git config --global user.email "邮箱地址"ssh-keygen -t rsa -C '上面的邮箱'</code></pre><p>按照提示完成三次回车，便可生成 ssh key，采用以下指令也可以查看自己的ssh：</p><pre><code class="bash">cat ~/.ssh/id\_rsa.pub</code></pre><p>首次使用还须要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功。</p><p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p><p>登陆 Github 上添加刚刚生成的SSH key，按如下步骤添加，右上角点击头像-&gt; settings -&gt; SSH and GPG keys，建立一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认建立，这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p>此时，本地和Github的工做作得差不了，是时候把它们两个链接起来了。你也能够查看官网的部署教程。先不着急，部署以前还须要修改配置和安装部署插件。第一：打开项目根目录下的_config.yml 配置文件配置参数。拉到文件末尾，填上以下配置。</p><pre><code class="yaml">deploy:  type: git  #仓库地址，username是你的github用户名  repo: https://github.com/username/username.github.io.git   branch: master #代码分支</code></pre><p>第二要安装一个部署插件 hexo-deployer-git，打开“Git Bash”，输如以下指令：</p><pre><code class="bash"> npm install hexo-deployer-git --save </code></pre><p>最后执行如下两条命令就能够部署上传啦，如下 g 是 generate 缩写，d 是 deploy 缩写，hexo help 可以查看相关命令。 </p><pre><code class="bash">hexo g # 先生成hexo d # 部署到Github上</code></pre><p>这时用浏览器输入 用户名.github.io就可以访问刚才的网站啦。</p><h2 id="6-写文章并上传"><a href="#6-写文章并上传" class="headerlink" title="6. 写文章并上传"></a><strong>6. 写文章并上传</strong></h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档能够看 hexo 官网。新建文章，输入如下命令便可</p><pre><code class="bash">hexo new '文章标题'</code></pre><p>执行完成后能够在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdow格式的文件，具体用法能够在网上找一下，语法仍是比较简单的。同时会生成一个同名文件夹，可以把文章需要的图片放在里面。</p><pre><code class="markdown">---title: blogTestdate: 2021-08-20 18:07:21tags: Testcategories: blog1---### 1. This is a blog Test* First* Second---### 2. Show Text* **这是加粗**&gt; *这是斜体*</code></pre><p>之后依次输入以下命令：</p><pre><code class="bash">hexo g # 生成文件hexo s # 本地服务器查看网站hexo d # 部署到Github 上</code></pre><h2 id="7-配置一些特效"><a href="#7-配置一些特效" class="headerlink" title="7. 配置一些特效"></a><strong>7. 配置一些特效</strong></h2><p>雪花特效： themes\hexo-theme-Chic\layout\index.ejs中添加如下代码：</p><pre><code class="html">&lt;!-- 雪花特效 --&gt;&lt;script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/snow.js"&gt;&lt;/script&gt;</code></pre><p>蜘蛛网特效： themes\hexo-theme-Chic\layout\layout.ejs中添加如下代码：</p><pre><code class="javascript">&lt;script&gt;!function() {function n(n, e, t) {return n.getAttribute(e) || t}function e(n) {return document.getElementsByTagName(n)}function t() {var t = e("script"),o = t.length,i = t[o - 1];return {l: o,z: n(i, "zIndex", -1), //置于主页面背后o: n(i, "opacity", .5), //线条透明度c: n(i, "color", "0,0,0"), //线条颜色n: n(i, "count", 100) //线条数量}}function o() {a = m.width = window.innerWidth ||document.documentElement.clientWidth || document.body.clientWidth,c = m.height = window.innerHeight ||document.documentElement.clientHeight || document.body.clientHeight}function i() {r.clearRect(0, 0, a, c);var n, e, t, o, m, l;s.forEach(function(i, x) {for (i.x += i.xa, i.y += i.ya, i.xa *= i.x &gt; a || i.x &lt; 0 ? -1 :1, i.ya *= i.y &gt; c || i.y &lt; 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1,1), e = x + 1; e &lt; u.length; e++) n = u[e],null !== n.x &amp;&amp; null !== n.y &amp;&amp; (o = i.x - n.x, m = i.y - n.y, l= o * o + m * m, l &lt; n.max &amp;&amp; (n === y &amp;&amp; l &gt;= n.max / 2 &amp;&amp; (i.x -= .03 * o,i.y -= .03 * m), t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t /2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")", r.moveTo(i.x, i.y),r.lineTo(n.x, n.y), r.stroke()))}),x(i)}var a, c, u, m = document.createElement("canvas"),d = t(),l = "c_n" + d.l,r = m.getContext("2d"),x = window.requestAnimationFrame || window.webkitRequestAnimationFrame|| window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function(n) {window.setTimeout(n, 1e3 / 45)},w = Math.random,y = {x: null,y: null,max: 2e4};m.id = l,m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z +";opacity:" + d.o,e("body")[0].appendChild(m),o(),window.onresize = o,window.onmousemove = function(n) {n = n || window.event,y.x = n.clientX,y.y = n.clientY// 评论区采用的时Valine https://valine.js.org/ 和LeanCloud},window.onmouseout = function() {y.x = null,y.y = null};for (var s = [], f = 0; d.n &gt; f; f++) {var h = w() * a,g = w() * c,v = 2 * w() - 1,p = 2 * w() - 1;s.push({x: h,y: g,xa: v,ya: p,max: 6e3})}u = s.concat([y]),setTimeout(function() {i()},100)} ();&lt;/script&gt;</code></pre><p>hexo-theme-Claudia主题加雪花特效：</p><p>在<strong>themes\hexo-theme-Claudia\source\js</strong>目录下，添加snow.js,代码如下：</p><pre><code class="javascript">/* 控制下雪 */function snowFall(snow) {    /* 可配置属性 */    snow = snow || {};    this.maxFlake = snow.maxFlake || 200;   /* 最多片数 */    this.flakeSize = snow.flakeSize || 10;  /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1;   /* 坠落速度 */}/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function(callback) { setTimeout(callback, 1000 / 60); }; cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function(){    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)}/* 创建画布 */function snowCanvas() {    /* 添加Dom结点 */    var snowcanvas = document.createElement("canvas");    snowcanvas.id = "snowfall";    snowcanvas.width = document.body.offsetWidth;    snowcanvas.height = window.innerHeight;    snowcanvas.setAttribute("style", "position:fixed; top: 0; left: 0; z-index: -1; pointer-events: none;");    document.getElementsByTagName("body")[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext("2d");    /* 窗口大小改变的处理 */    window.onresize = function() {        // snowcanvas.width = document.body.offsetWidth;        /* snowcanvas.height = window.innerHeight */    }}/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) {    this.x = Math.floor(Math.random() * canvasWidth);   /* x坐标 */    this.y = Math.floor(Math.random() * canvasHeight);  /* y坐标 */    this.size = Math.random() * flakeSize + 2;          /* 形状 */    this.maxSize = flakeSize;                           /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed;         /* 坠落速度 */    this.fallSpeed = fallSpeed;                         /* 坠落速度 */    this.velY = this.speed;                             /* Y方向速度 */    this.velX = 0;                                      /* X方向速度 */    this.stepSize = Math.random() / 30;                 /* 步长 */    this.step = 0                                       /* 步数 */}flakeMove.prototype.update = function() {    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) {        this.velY = this.speed    }    this.velX += Math.cos(this.step += .05) * this.stepSize;     this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) {        this.reset(canvas.width, canvas.height)    }};/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) {    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;};// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) {    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, "rgba(255, 255, 255, 0.9)");  /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, "rgba(255, 255, 255, 0.5)"); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, "rgba(255, 255, 255, 0)");    /* 找16进制的RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();};/* 创建雪花-定义形状 */function createFlakes() {    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) {        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    }}/* 画雪 */function drawSnow() {    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) {        flakes[e].update();        flakes[e].render(ctx);    }    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function() {        drawSnow.apply(that);    });}/* 调用及控制方法 */window.onload = function() {      var element = document.body;      var width = element.offsetWidth;      var height = element.offsetHeight;      console.log("Width: " + width + "px");      console.log("Height: " + height + "px");            var snow = new snowFall({maxFlake:200});    snow.start();};</code></pre><p>然后可以在themes\hexo-theme-Claudia\layout目录下的index.pug引入这个js</p><pre><code class="pug">extends widget/baseblock append head    link(rel='stylesheet', href= url_for("/style/widget-post-list.css"))    script(src= url_for("/js/snow.js"))block content    include widget/widget-post-list        block sidebar            include widget/widget-search            if theme.widgets.includes('profile')                include widget/widget-profile            if theme.widgets.includes('recent_posts')                include widget/widget-recent            if theme.widgets.includes('category') &amp;&amp; site.categories.length &gt; 0                include widget/widget-categories            if theme.widgets.includes('archive')                include widget/widget-archives            if theme.widgets.includes('tag') &amp;&amp; site.tags.length &gt; 0                include widget/widget-tag            if theme.friend_links &amp;&amp; theme.friend_links.length &gt; 0                main.aside-card-container.friend-widget                    h3= _p('friends')                    section                        each link in theme.friend_links                            a(href= link.link)                                span.tag.post-item-tag(style="margin-bottom: 5px;")= link.title</code></pre><h2 id="8-代码高亮处理，以及增加复制、折叠功能"><a href="#8-代码高亮处理，以及增加复制、折叠功能" class="headerlink" title="8.代码高亮处理，以及增加复制、折叠功能"></a>8.代码高亮处理，以及增加复制、折叠功能</h2><p>hexo默认可以使用<a href="https://github.com/highlightjs/highlight.js">highlight.js</a> 或者<a href="https://github.com/PrismJS/prism">prismjs</a> 高亮库，开启相关配置见：<a href="https://hexo.io/zh-cn/docs/syntax-highlight">代码高亮 | Hexo</a>。</p><p>hexo-theme-Claudia主题自带代码高亮，但是不支持行号，只要把hexo默认的的高亮配置关闭就行：</p><pre><code class="yaml">syntax_highlighter:highlight:  enable: false  line_number: true  auto_detect: false  tab_replace: ''  wrap: false  hljs: trueprismjs:  enable: false  preprocess: true  line_number: true  tab_replace: ''</code></pre><p>或者可以自定义代码高亮配置，可以从网上找教程。</p><p>代码块增加复制、折叠功能参考：<a href="https://zhuanlan.zhihu.com/p/124888459">Hexo 博客代码块样式美化 - 知乎 (zhihu.com)</a>。</p><p>我在hexo-theme-Claudia主题的**/themes/hexo-theme-Claudia/layout/post.pug**文件引入了codeBlockFuction.js、codeBLang.js、codeCopy.js、codeShrink.js、自定义了custom.css(使用默认的高亮样式就不需要),注意font-awesome、highlightjs-line-numbers.min.js和clipboard.min.js我用cdn引入了。</p><p>hexo-theme-Claudia主题的代码分词和高亮是<strong>highlight.pack.js、highlight-theme-light.css</strong>实现的。</p><p>想要自己实现可以从官网<a href="https://highlightjs.org/download">Download a Custom Build - highlight.js (highlightjs.org)</a>下载的最新的highlight.min.js，同时可以修改highlight-theme-light.css，行号的一些样式我加在了这个css中，然后在post.js中<strong>hljs &amp;&amp; hljs.initLineNumbersOnLoad();</strong> 使用。</p><p>或者不使用highlight-theme-light.css，直接从网上找其他的<a href="https://github.com/highlightjs/highlight.js/tree/main/src/styles">highlight.js/src/styles at main · highlightjs/highlight.js (github.com)</a>，比如monokai-sublime.min.css，直接引入就可以了。post.pug代码如下：</p><pre><code class="pug">extends widget/baseblock append head  link(rel='stylesheet', href= url_for('/style/post.css'))  link(rel='stylesheet', href= url_for('/style/themes/highlight-theme-light.css'))  link(rel='stylesheet' href= url_for('https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.css'))  //link(rel='stylesheet', href= url_for('/style/themes/monokai-sublime.min.css'))  link(rel='stylesheet', href= url_for('/style/common/jquery.fancybox.min.css'))  //script(src= url_for("/js/highlight.pack.js"))    script(src= url_for("/js/highlight.min.js"))  style(type="text/css") code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }  script(src= url_for("https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"))    script(src= url_for("https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"))  script(src= url_for("https://cdn.bootcdn.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"))  script(src= url_for("/js/hightlight/codeBLang.js"))    script(src= url_for("/js/hightlight/codeBlockFuction.js"))    script(src= url_for("/js/hightlight/codeCopy.js"))    script(src= url_for("/js/hightlight/codeShrink.js"))    meta(name="description", content=truncate( strip_html(page.content), {length: 360, omission: '..'} ))  if theme.comment_valine &amp;&amp; theme.comment_valine.enable      script(src="//unpkg.com/valine/dist/Valine.min.js")block topic    div#postTopic.is-full-height        - var title = truncate( page.title, {length: 65, omission: '..'} ) || ''        p.is-full-height.is-flex-shrink-0.is-flex.is-align-items-center.is-justify-content-center= title        p.is-full-height.is-flex-shrink-0.is-flex.is-align-items-center.is-justify-content-center= __('click_back_to_the_top')block content    - var tocContent = toc(page.content, {list_number: false})    main.container.is-max-widescreen.content.section.post-page.pt-4.px-4        .columns.is-flex-desktop.is-justify-content-center.is-flex-direction-row-reverse            .column.is-3.is-hidden-mobile(class= tocContent.length &lt; 1 &amp;&amp; 'is-hidden')!= tocContent            .column.is-9                header.my-4                    if page.tags &amp;&amp; page.tags.length &gt; 0                        each tag in page.tags.toArray()                            a(href= url_for(`/tags/${tag.name}`))                                i.tag.post-item-tag= tag.name                h1.mt-0.mb-1.is-family-serif#postTitle= page.title                if page.date                    time.has-text-grey(datetime=page.date.toJSON())= date(page.date, date_format)                article.mt-2.post-content!= page.content                section.jump-container.is-flex.is-justify-content-space-between.my-6                    // em is empty placeholder                    if page.prev                        - var preContent= `${ __('prev') }: ${ page.prev.title }`                        a.button.is-default(href= url_for(page.prev.path) title= page.prev.title)                            i.iconfont.icon-prev.mr-2.has-text-grey                            span.has-text-weight-semibold= preContent                    else                        em                    if page.next                        - var nextContent= `${ __('next') }: ${ page.next.title }`                        a.button.is-default(href= url_for(page.next.path) title= page.next.title)                            span.has-text-weight-semibold= nextContent                            i.iconfont.icon-next.ml-2.has-text-grey                if theme.comment_utteranc &amp;&amp; theme.comment_utteranc.enable                    article.mt-6.comment-container                        script(                            async                            repo= theme.comment_utteranc.repo                            src= "https://utteranc.es/client.js"                            label= theme.comment_utteranc.label                            issue-term= theme.comment_utteranc.issue_term || "pathname"                            theme= theme.comment_utteranc.theme || "preferred-color-scheme"                        )                if theme.comment_valine &amp;&amp; theme.comment_valine.enable                    article.mt-6.comment-container#vcomments(                        data-comment_valine_id= theme.comment_valine.appId                        data-comment_valine_key= theme.comment_valine.appKey                    )                if theme.comment_disqus &amp;&amp; theme.comment_disqus.enable                    div#disqus_thread                    article.mt-6.comment-container#disqus                        script="var disqus_config = function () {this.page.url = '"+theme.comment_disqus.url+url_for(page.path)+"';this.page.identifier = '"+theme.comment_disqus.name+"';};"                        script="(function() {var d = document, s = d.createElement('script');s.src = 'https://"+theme.comment_disqus.name+".disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();"                        script(id="dsq-count-scr", src="//blog-pubgj2togw.disqus.com/count.js", async)block script    if theme.image_zoom &amp;&amp; theme.image_zoom.enable        script(src= url_for("/js/jquery-3.6.1.min.js"))        script(src= url_for("/js/jquery-fancybox.min.js"))        script(src= url_for("/js/img_zoom.js"))    script(src= url_for("/js/post.js"))  </code></pre><h2 id="9-图片显示及相关问题"><a href="#9-图片显示及相关问题" class="headerlink" title="9.图片显示及相关问题"></a>9.图片显示及相关问题</h2><p>图片可以使用网络图片或者图床，直接把url复制粘贴就可以显示了。如果使用本地图片，可以把图片放入同名文章的文件夹里，直接用相对路径引用，如：<strong>pic.jpg</strong>，注意不要用**/pic.jpg**，不然会被识别成绝对路径。<img src="/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/1.PNG"></p><p>因为md生成的html和图片在同一个文件夹里 。</p><p><img src="/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/2.PNG"></p><p>如果要在Typora中预览本地图片，在<strong>格式-&gt;图像-&gt;设置图片根目录</strong>，选择同名文件夹就可以了。详细操作参考：</p><p><a href="https://zhuanlan.zhihu.com/p/265077468">参考：hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p><h2 id="10-评论区"><a href="#10-评论区" class="headerlink" title="10.评论区"></a>10.评论区</h2><p>评论区采用的时Valine <a href="https://valine.js.org/">https://valine.js.org/</a><a href="https://valine.js.org/"> </a>和LeanCloud</p><h2 id="11-其他美化功能"><a href="#11-其他美化功能" class="headerlink" title="11.其他美化功能"></a>11.其他美化功能</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/69211731">Hexo 博客美化合集（不断更新） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
