<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>大文件分片上传</title><meta name="description" content="666"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- 解决403图片防盗链的问题 -->    <meta content="no-referrer" name="referrer"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><link rel="stylesheet" href="/style/custom.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.css"><!--link(rel='stylesheet', href= url_for('/style/themes/monokai-sublime.min.css'))--><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><!--script(src= url_for("/js/highlight.pack.js"))--><script src="/js/highlight.min.js"></script><style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"> </script><script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script><script src="/js/hightlight/codeBLang.js"> </script><script src="/js/hightlight/codeBlockFuction.js"> </script><script src="/js/hightlight/codeCopy.js"> </script><script src="/js/hightlight/fullScreen.js"> </script><script src="/js/hightlight/codeShrink.js"> </script><meta name="description" content="基于SpringBoot实现大文件分片上传1、前言在项目开发遇到大文件，比如视频之类的文件，直接上传速度很慢，而且受限于服务器带宽，用户体验很不好，所以需要优化，常见的解决方案就是分片上传。
2、环境SpringBoot 3.3.5 +JDK 17 +MinIO
3、实现3.1 后端分片开始做分片时，首先考虑在服务端做分片看看能否提升整体文件上传速度。首先说结论，不能，甚至可能比直接上传大文件还慢。所以大文件分片上传必须要前端配合，只在后端实现不行，但是还是说一下思路：首先通过接口拿到文件，然后对文件进行分片，然后上传，最后再合并，即使借助线程池，实现同时上传多个分片，效率还是不行，主要原因是，分片还有合并IO耗时太长。
3.2 前端分片，后端合并主要流程：前端拿到文件，然后分片，并行调用上传接口（这个是重.."><meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="ZQG的博客" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ZQG's blog  </a><iframe frameborder="0" height="20" hspace="0" scrolling="no" src="https://i.tianqi.com/?c=code&amp;a=getcode&amp;id=1&amp;icon=1" width="550"></iframe><iframe clocktype="html5" frameborder="no" scrolling="no" style="overflow:hidden;border:0;margin:0;padding:0;width:140px;height:25px;" src="https://www.clocklink.com/html5embed.php?clock=047&amp;timezone=CCT&amp;color=black&amp;size=140&amp;Title=&amp;Message=&amp;Target=&amp;From=2024,1,1,0,0,0&amp;Color=black"></iframe></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">大文件分片上传</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESpringBoot%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-text">基于SpringBoot实现大文件分片上传</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-text">1、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%8E%AF%E5%A2%83"><span class="toc-text">2、环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3、实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%90%8E%E7%AB%AF%E5%88%86%E7%89%87"><span class="toc-text">3.1 后端分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%89%8D%E7%AB%AF%E5%88%86%E7%89%87%EF%BC%8C%E5%90%8E%E7%AB%AF%E5%90%88%E5%B9%B6"><span class="toc-text">3.2 前端分片，后端合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%89%A9%E5%B1%95%EF%BC%88%E7%A7%92%E4%BC%A0%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-text">4、扩展（秒传功能）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">5、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1minio%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">5.1minio引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-minio%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-text">5.2 minio上传工具相关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.3 分片上传接口</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/SpringBoot"><i class="tag post-item-tag">SpringBoot</i></a><a href="/tags/MinIO"><i class="tag post-item-tag">MinIO</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">大文件分片上传</h1><time class="has-text-grey" datetime="2026-02-21T04:39:12.000Z">2026-02-21</time><article class="mt-2 post-content"><h1 id="基于SpringBoot实现大文件分片上传"><a href="#基于SpringBoot实现大文件分片上传" class="headerlink" title="基于SpringBoot实现大文件分片上传"></a>基于SpringBoot实现大文件分片上传</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在项目开发遇到大文件，比如视频之类的文件，直接上传速度很慢，而且受限于服务器带宽，用户体验很不好，所以需要优化，常见的解决方案就是分片上传。</p>
<h2 id="2、环境"><a href="#2、环境" class="headerlink" title="2、环境"></a>2、环境</h2><p>SpringBoot 3.3.5 +JDK 17 +MinIO</p>
<h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><h3 id="3-1-后端分片"><a href="#3-1-后端分片" class="headerlink" title="3.1 后端分片"></a>3.1 后端分片</h3><p>开始做分片时，首先考虑在服务端做分片看看能否提升整体文件上传速度。首先说结论，不能，甚至可能比直接上传大文件还慢。所以大文件分片上传必须要前端配合，只在后端实现不行，但是还是说一下思路：首先通过接口拿到文件，然后对文件进行分片，然后上传，最后再合并，即使借助线程池，实现同时上传多个分片，效率还是不行，主要原因是，分片还有合并IO耗时太长。</p>
<h3 id="3-2-前端分片，后端合并"><a href="#3-2-前端分片，后端合并" class="headerlink" title="3.2 前端分片，后端合并"></a>3.2 前端分片，后端合并</h3><p>主要流程：前端拿到文件，然后分片，<strong>并行调用上传接口</strong>（这个是重点），所有分片上传完成，调用合并接口，得到完整文件的url。分片上传效率高的核心就是：浏览器并行调用分片文件的上传接口，因为是并行，所以节省了大量时间。</p>
<p>完整功能时序图：</p>
<p> <img src="/2026/02/21/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/image-20260221125510029.png" alt="image-20260221125510029"></p>
<p><strong>断点续传</strong>：前端每次上传文件前，先调用检查接口，看看是否已上传部分的分片，只需要上传缺失的分片就可以了，这样即使因为网络或者其他什么原因导致没有上传功能，下次可以重新上传。</p>
<p><strong>文件合并</strong>：有两种实现方式，1、将分隔好的小文件上传到MinIO，直接使用MinIO的api，在MinIO中实现文件合并；2、将分隔好的小文件上传到服务器，在服务器使用javaIO将文件合并，最后再上传到MinIO。两种方式都可以。</p>
<h2 id="4、扩展（秒传功能）"><a href="#4、扩展（秒传功能）" class="headerlink" title="4、扩展（秒传功能）"></a>4、扩展（秒传功能）</h2><p>在实现文件成功上传后，可以将已上传的文件地址持久化到数据库或者放到缓存中，用文件MD5值和url作为唯一关联，这样每次上传文件前，可以先查询是否已上传文件，有则直接返回url，这就是秒传的功能。</p>
<h2 id="5、代码实现"><a href="#5、代码实现" class="headerlink" title="5、代码实现"></a>5、代码实现</h2><h3 id="5-1minio引入依赖"><a href="#5-1minio引入依赖" class="headerlink" title="5.1minio引入依赖"></a>5.1minio引入依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.minio&lt;/groupId&gt;
    &lt;artifactId&gt;minio&lt;/artifactId&gt;
    &lt;version&gt;8.2.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="5-2-minio上传工具相关代码"><a href="#5-2-minio上传工具相关代码" class="headerlink" title="5.2 minio上传工具相关代码"></a>5.2 minio上传工具相关代码</h3><pre><code class="java">package com.gotion.common.config;

import io.minio.MinioClient;
import okhttp3.ConnectionPool;
import okhttp3.OkHttpClient;
import org.apache.logging.log4j.util.Strings;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

/**
 * Minio 配置信息
 *
 */
@Configuration
@ConfigurationProperties(prefix = "minio")
public class MinioConfig {
    /**
     * 服务地址
     */
    private static String url;

    /**
     * 用户名
     */
    private static String accessKey;

    /**
     * 密码
     */
    private static String secretKey;

    /**
     * 存储桶名称
     */
    private static String bucketName;

    /**
     * 域名地址
     */
    private static String domainName;

    /**
     * 替换域名地址
     */
    private static String repalceDomainName;

    /**
     * 替换IP地址
     */
    private static String replaceIpName= Strings.EMPTY;

    public static String getUrl()
    {
        return url;
    }

    public void setUrl(String url)
    {
        MinioConfig.url = url;
    }

    public static String getAccessKey()
    {
        return accessKey;
    }

    public void setAccessKey(String accessKey)
    {
        MinioConfig.accessKey = accessKey;
    }

    public static String getSecretKey()
    {
        return secretKey;
    }

    public void setSecretKey(String secretKey)
    {
        MinioConfig.secretKey = secretKey;
    }

    public static String getBucketName()
    {
        return bucketName;
    }

    public void setBucketName(String bucketName)
    {
        MinioConfig.bucketName = bucketName;
    }

    public static String getDomainName() {
        return domainName;
    }

    public void setDomainName(String domainName) {
        MinioConfig.domainName = domainName;
    }

    public static String getRepalceDomainName() {
        return repalceDomainName;
    }

    public void setRepalceDomainName(String repalceDomainName) {
        MinioConfig.repalceDomainName = repalceDomainName;
    }

    @Bean
    public MinioClient getMinioClient()
    {
        //return MinioClient.builder().endpoint(url).credentials(accessKey, secretKey).build();
        OkHttpClient httpClient = new OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(300, TimeUnit.SECONDS)   // 上传超时
                .readTimeout(300, TimeUnit.SECONDS)    // 读取超时
                .connectionPool(new ConnectionPool(50, 30, TimeUnit.MINUTES)) // 连接池优化
                .build();

        return MinioClient.builder()
                .endpoint(url)
                .credentials(accessKey, secretKey)
                .httpClient(httpClient)
                .build();
    }

    public static String getReplaceIpName() {
        return replaceIpName;
    }

    public void setReplaceIpName(String replaceIpName) {
        MinioConfig.replaceIpName = replaceIpName;
    }
}
</code></pre>
<pre><code class="java">package com.gotion.common.utils;

import com.gotion.common.utils.spring.SpringUtils;
import io.minio.*;
import io.minio.http.Method;
import io.minio.messages.DeleteError;
import io.minio.messages.DeleteObject;
import io.minio.messages.Item;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


@Slf4j
public class MinioUtil {

    /**
     * 上传文件
     *
     * @param bucketName 桶名称
     * @param fileName
     * @throws IOException
     */
    public static String uploadFile(String bucketName, String fileName, MultipartFile multipartFile) throws IOException
    {
       String url = "";
       MinioClient minioClient = SpringUtils.getBean(MinioClient.class);
       try (InputStream inputStream = multipartFile.getInputStream())
       {
          minioClient.putObject(PutObjectArgs.builder().bucket(bucketName).object(fileName).stream(inputStream, multipartFile.getSize(), -1).contentType(multipartFile.getContentType()).build());
          url = minioClient.getPresignedObjectUrl(GetPresignedObjectUrlArgs.builder().bucket(bucketName).object(fileName).method(Method.GET).build());
          url = url.substring(0, url.indexOf('?'));
          return ServletUtils.urlDecode(url);
       }
       catch (Exception e)
       {
          throw new IOException(e.getMessage(), e);
       }
    }


    /**
     * 删除文件
     *
     * @param bucketName 桶名称
     * @param filePath   删除文件夹
     * @throws IOException
     */
    public static void deleteFiles(String bucketName, String filePath) {
       try {
          MinioClient minioClient = SpringUtils.getBean(MinioClient.class);
          Iterable&lt;Result&lt;Item&gt;&gt; fileList = minioClient.listObjects(ListObjectsArgs.builder().bucket(bucketName).prefix(filePath).recursive(false).build());
          List&lt;DeleteObject&gt; list = new ArrayList&lt;&gt;();
          for (Result&lt;Item&gt; item : fileList) {
             list.add(new DeleteObject(item.get().objectName()));
          }
          Iterable&lt;Result&lt;DeleteError&gt;&gt; iterable = minioClient.removeObjects(RemoveObjectsArgs.builder().bucket(bucketName).objects(list).build());
          for (Result&lt;DeleteError&gt; result : iterable) {
             DeleteError error = result.get();
             log.info("minio删除错误-&gt;bucketName={},objectName={},message={}", error.bucketName(), error.objectName(), error.message());
          }
       } catch (Exception e) {
          log.error("批量删除点检照片异常", e);
          throw new RuntimeException("批量删除点检照片异常");
       }
    }


    /**
     * 批量删除文件
     *
     * @param bucketName 桶名称
     * @param objectNames 删除文件
     *
     */
    public static void deleteFiles(String bucketName, List&lt;String&gt; objectNames) {
       try {
          MinioClient minioClient = SpringUtils.getBean(MinioClient.class);
          List&lt;DeleteObject&gt; objects = objectNames.stream()
                .map(DeleteObject::new)
                .collect(Collectors.toList());

          Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(
                RemoveObjectsArgs.builder()
                      .bucket(bucketName)
                      .objects(objects)
                      .build()
          );

          // 处理删除错误
          for (Result&lt;DeleteError&gt; result : results) {
             DeleteError error = result.get();
             log.error("删除文件失败: {}", error.objectName());
          }
       } catch (Exception e) {
          throw new RuntimeException("批量删除文件失败", e);
       }
    }

}
</code></pre>
<pre><code class="java">package com.gotion.bbs.util;

import com.gotion.common.config.MinioConfig;
import com.gotion.common.config.RuoYiConfig;
import com.gotion.common.exception.file.FileNameLengthLimitExceededException;
import com.gotion.common.exception.file.FileSizeLimitExceededException;
import com.gotion.common.exception.file.InvalidExtensionException;
import com.gotion.common.utils.DateUtils;
import com.gotion.common.utils.MinioUtil;
import com.gotion.common.utils.StringUtils;
import com.gotion.common.utils.file.MimeTypeUtils;
import com.gotion.common.utils.uuid.Seq;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FilenameUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Objects;

import static com.gotion.common.config.MinioConfig.getDomainName;
/**
 * 论坛文件上传工具类
 *
 *
 */
@Slf4j
public class BBSFileUploadUtils
{
    /**
     * 默认大小 55M
     */
    public static final long DEFAULT_MAX_SIZE = 55 * 1024 * 1024L;

    /**
     * 默认的文件名最大长度 100
     */
    public static final int DEFAULT_FILE_NAME_LENGTH = 100;

    /**
     * http头
     */
    public static final String HTTP_URL = "http://";

    /**
     * 默认上传的地址
     */
    private static String defaultBaseDir = RuoYiConfig.getProfile();

    public static void setDefaultBaseDir(String defaultBaseDir)
    {
        BBSFileUploadUtils.defaultBaseDir = defaultBaseDir;
    }

    public static String getDefaultBaseDir()
    {
        return defaultBaseDir;
    }

    /**
     * Minio默认上传的地址
     */
    private static final String bucketName = MinioConfig.getBucketName();

    public static String getBucketName() { return bucketName; }



    /**
     * 编码文件名
     *
     * @param file   file
     * @param folder folder
     * @return String
     */
    public static String extractFilename(MultipartFile file, String folder) {
        if (folder != null) {
            return StringUtils.format("{}/{}/{}_{}.{}", folder, DateUtils.datePath(),
                    FilenameUtils.getBaseName(file.getOriginalFilename()), Seq.getId(Seq.uploadSeqType), getExtension(file));
        }
        return StringUtils.format("{}/{}_{}.{}", DateUtils.datePath(),
                FilenameUtils.getBaseName(file.getOriginalFilename()), Seq.getId(Seq.uploadSeqType), getExtension(file));
    }


    /**
     * 文件大小校验
     *
     * @param file 上传的文件
     * @throws FileSizeLimitExceededException 如果超出最大大小
     * @throws InvalidExtensionException  文件类型校验异常
     */
    public static  void assertAllowed(MultipartFile file, String[] allowedExtension)
            throws FileSizeLimitExceededException, InvalidExtensionException
    {
        long size = file.getSize();
        if (size &gt; DEFAULT_MAX_SIZE)
        {
            throw new FileSizeLimitExceededException(DEFAULT_MAX_SIZE / 1024 / 1024);
        }

        String fileName = file.getOriginalFilename();
        String extension = getExtension(file);
        if (allowedExtension != null &amp;&amp; !isAllowedExtension(extension, allowedExtension))
        {
            if (allowedExtension == MimeTypeUtils.IMAGE_EXTENSION)
            {
                throw new InvalidExtensionException.InvalidImageExtensionException(allowedExtension, extension,
                        fileName);
            }
            else if (allowedExtension == MimeTypeUtils.FLASH_EXTENSION)
            {
                throw new InvalidExtensionException.InvalidFlashExtensionException(allowedExtension, extension,
                        fileName);
            }
            else if (allowedExtension == MimeTypeUtils.MEDIA_EXTENSION)
            {
                throw new InvalidExtensionException.InvalidMediaExtensionException(allowedExtension, extension,
                        fileName);
            }
            else if (allowedExtension == MimeTypeUtils.VIDEO_EXTENSION)
            {
                throw new InvalidExtensionException.InvalidVideoExtensionException(allowedExtension, extension,
                        fileName);
            }
            else
            {
                throw new InvalidExtensionException(allowedExtension, extension, fileName);
            }
        }
    }

    /**
     * 判断MIME类型是否是允许的MIME类型
     *
     * @param extension  扩展名
     * @param allowedExtension 允许的MIME类型
     * @return 是否允许
     */
    public static  boolean isAllowedExtension(String extension, String[] allowedExtension)
    {
        for (String str : allowedExtension)
        {
            if (str.equalsIgnoreCase(extension))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * 获取文件名的后缀
     *
     * @param file 表单文件
     * @return 后缀名
     */
    public static  String getExtension(MultipartFile file)
    {
        String extension = FilenameUtils.getExtension(file.getOriginalFilename());
        if (StringUtils.isEmpty(extension))
        {
            extension = MimeTypeUtils.getExtension(Objects.requireNonNull(file.getContentType()));
        }
        return extension;
    }

    /**
     * 分文件夹上传到Minio服务器
     *
     * @param file 上传的文件
     * @param folder 文件夹名称
     * @param allowedExtension 允许的扩展名
     * @return 文件名称
     * @throws IOException 异常
     */
    public static String uploadMinio(MultipartFile file, String folder, String[] allowedExtension) throws IOException {
        try {
            String path = uploadMinio(getBucketName(), file, allowedExtension, folder);
            // 替换ip和端口的访问方式改成域名
            String fileName = getDomainName() + path.substring(path.indexOf("/", HTTP_URL.length()));
            // 处理可能存在的栓斜杠
            return fixDoubleSlashes(fileName);
        } catch (Exception e) {
            throw new IOException(e.getMessage(), e);
        }
    }

    public static  String uploadMinio(String bucketName, MultipartFile file, String[] allowedExtension, String folder)
            throws FileSizeLimitExceededException, IOException, FileNameLengthLimitExceededException,
            InvalidExtensionException
    {
        int fileNameLength = Objects.requireNonNull(file.getOriginalFilename()).length();
        if (fileNameLength &gt; BBSFileUploadUtils.DEFAULT_FILE_NAME_LENGTH)
        {
            throw new FileNameLengthLimitExceededException(BBSFileUploadUtils.DEFAULT_FILE_NAME_LENGTH);
        }
        assertAllowed(file, allowedExtension);
        try
        {
            String fileName = extractFilename(file, folder);
            return MinioUtil.uploadFile(bucketName, fileName, file);
        }
        catch (Exception e)
        {
            throw new IOException(e.getMessage(), e);
        }
    }

    /**
     * 分文件夹上传到Minio服务器
     *
     * @param file 上传的文件
     * @param folder 文件夹名称
     * @return 文件名称
     * @throws IOException 异常
     */
    public static String uploadMinio(MultipartFile file, String folder) throws IOException {
        try {
            String path = uploadMinio(getBucketName(), file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION, folder);
            // 替换ip和端口的访问方式改成域名
            String fileName = getDomainName() + path.substring(path.indexOf("/", HTTP_URL.length()));
            // 处理可能存在的栓斜杠
            return fixDoubleSlashes(fileName);
        } catch (Exception e) {
            throw new IOException(e.getMessage(), e);
        }
    }


    public static String fixDoubleSlashes(String url) {

        if (url.startsWith("http://")) {
            String protocol = "http://";
            String rest = url.substring(7); // 移除"http://"

            rest = rest.replace("//", "/");

            return protocol + rest;
        }

        if (url.startsWith("https://")) {
            String protocol = "https://";
            String rest = url.substring(8); // 移除"http://"

            rest = rest.replace("//", "/");

            return protocol + rest;
        }

        return url.replace("//", "/");
    }


    /**
     * 删除MinIO中的文件夹（文件夹下的文件）
     *
     * @param filePath 文件名（包含路径）
     * @throws IOException 异常
     */
    public static void deleteMinio(String filePath) throws IOException {
        try {
            // 从URL中提取实际的文件路径
            String fileFolder = extractFilePathFromUrl(filePath);
            MinioUtil.deleteFiles(getBucketName(), fileFolder);
        } catch (Exception e) {
            throw new IOException("删除文件失败: " + e.getMessage(), e);
        }
    }

    /**
     * 批量删除MinIO中的文件
     * @param filePath 文件名（包含路径）
     * @throws IOException 异常
     */
    public static void deleteFilesBatch(List&lt;String&gt; filePath) throws IOException {
        try {
            // 从URL中提取实际的文件路径
            List&lt;String&gt; objectNames = extractFilePathFromUrl(filePath);
            MinioUtil.deleteFiles(getBucketName(), objectNames);
        } catch (Exception e) {
            throw new IOException("删除文件失败: " + e.getMessage(), e);
        }
    }

    /**
     *
     * 批量从URL中提取实际文件路径
     * @param filePath 文件路径列表
     *
     */
    private static List&lt;String&gt; extractFilePathFromUrl(List&lt;String&gt; filePath) {
        return filePath.stream()
                .map(BBSFileUploadUtils::extractFilePathFromUrl).toList();
    }
    /**
     * 从完整URL中提取文件夹路径
     *
     * @param fileUrl 完整的文件夹URL
     * @return 文件路径
     */
    private static String extractFilePathFromUrl(String fileUrl) {
        if (StringUtils.isEmpty(fileUrl)) {
            throw new IllegalArgumentException("文件URL不能为空");
        }

        try {
            // 移除域名部分，获取相对路径
            String domain = getDomainName();
            if (StringUtils.isNotEmpty(domain) &amp;&amp; fileUrl.startsWith(domain)) {
                String path = fileUrl.substring(domain.length());
                // 移除可能的前导斜杠
                if (path.startsWith("/")) {
                    path = path.substring(1);
                }
                // 移除bucketName部分
                String bucketName = getBucketName();
                if (StringUtils.isNotEmpty(bucketName) &amp;&amp; path.startsWith(bucketName + "/")) {
                    path = path.substring(bucketName.length() + 1);
                }
                return path;
            }

            // 如果是完整URL（http://或https://），提取路径部分
            if (fileUrl.startsWith("http://") || fileUrl.startsWith("https://")) {
                java.net.URL url = new java.net.URL(fileUrl);
                String path = url.getPath();
                // 移除前导斜杠
                if (path.startsWith("/")) {
                    path = path.substring(1);
                }
                // 移除bucketName部分
                String bucketName = getBucketName();
                if (StringUtils.isNotEmpty(bucketName) &amp;&amp; path.startsWith(bucketName + "/")) {
                    path = path.substring(bucketName.length() + 1);
                }
                return path;
            }

            // 如果已经是相对路径，移除bucketName前缀
            String cleanPath = fileUrl;
            if (cleanPath.startsWith("/")) {
                cleanPath = cleanPath.substring(1);
            }
            String bucketName = getBucketName();
            if (StringUtils.isNotEmpty(bucketName) &amp;&amp; cleanPath.startsWith(bucketName + "/")) {
                cleanPath = cleanPath.substring(bucketName.length() + 1);
            }

            return cleanPath;
        } catch (Exception e) {
            throw new IllegalArgumentException("无效的文件URL格式: " + fileUrl, e);
        }
    }


}
</code></pre>
<h3 id="5-3-分片上传接口"><a href="#5-3-分片上传接口" class="headerlink" title="5.3 分片上传接口"></a>5.3 分片上传接口</h3><pre><code class="java">package com.gotion.bbs.service.impl;

import com.gotion.bbs.domain.vo.FileMergeReqVO;
import com.gotion.bbs.util.BBSFileUploadUtils;
import com.gotion.common.config.MinioConfig;
import com.gotion.common.utils.DateUtils;
import com.gotion.common.utils.MinioUtil;
import com.gotion.common.utils.ServletUtils;
import com.gotion.common.utils.StringUtils;
import com.gotion.common.utils.file.MimeTypeUtils;
import com.gotion.common.utils.spring.SpringUtils;
import com.gotion.common.utils.uuid.Seq;
import io.minio.*;
import io.minio.errors.*;
import io.minio.http.Method;
import io.minio.messages.DeleteError;
import io.minio.messages.DeleteObject;
import io.minio.messages.Item;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FilenameUtils;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import static com.gotion.bbs.util.BBSFileUploadUtils.HTTP_URL;
import static com.gotion.common.config.MinioConfig.getDomainName;
@Slf4j
@Service
public class FileUploadService {


    private final String bucketName = MinioConfig.getBucketName();

    private static final String FILE_PATH_BBS ="/bbs";
    private static final String FILE_PATH_TEMP ="bbs/temp/";

    /**
     * 创建 MinIO 客户端
     *
     * @return MinioClient 实例
     */
    private MinioClient createMinioClient() {
        return  SpringUtils.getBean(MinioClient.class);
    }

    /**
     * 如果存储桶不存在，则创建存储桶
     */
    public void createBucketIfNotExists() throws IOException, NoSuchAlgorithmException, InvalidKeyException {
        MinioClient minioClient = createMinioClient();
        try {
            boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());
            if (!found) {
                minioClient.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build());
            }
        } catch (MinioException e) {
            throw new IOException("Error checking or creating bucket: " + e.getMessage(), e);
        }
    }

    /**
     * 上传文件分片到MinIO
     *
     * @param fileId   文件标识符
     * @param filePart 文件分片
     * @return 分片对象名称
     */
    public String uploadFilePart(String fileId, String fileName, MultipartFile filePart, Integer chunkIndex) throws IOException {
        // 构建分片对象名称
        String objectName = FILE_PATH_TEMP + fileId + "/" + fileName + '-' + chunkIndex;
        String url = MinioUtil.uploadFile(bucketName, objectName, filePart);
        return BBSFileUploadUtils.fixDoubleSlashes(url);
//        MinioClient minioClient = createMinioClient();
//        try {
//            // 构建分片对象名称
//            String objectName = "/bbs/temp/"+fileId + "/" + fileName + '-' + chunkIndex;
//            // 设置上传参数
//            PutObjectArgs putObjectArgs = PutObjectArgs.builder()
//                    .bucket(bucketName)
//                    .object(objectName)
//                    .stream(filePart.getInputStream(), filePart.getSize(), -1)
//                    .contentType(filePart.getContentType())
//                    .build();
//            // 上传文件分片
//            minioClient.putObject(putObjectArgs);
//            return objectName;
//        } catch (MinioException e) {
//            throw new IOException("Error uploading file part: " + e.getMessage(), e);
//        }
    }

    private String handleUrl(String url) {
        url = ServletUtils.urlDecode(url);
        url = url.substring(0, url.indexOf('?'));
        String newUrl = getDomainName() + url.substring(url.indexOf("/", HTTP_URL.length()));
        return BBSFileUploadUtils.fixDoubleSlashes(newUrl);
    }

    /**
     * 合并多个文件分片为一个完整文件
     */
    public String mergeFileParts(FileMergeReqVO reqVO) throws IOException, NoSuchAlgorithmException, InvalidKeyException {
        MinioClient minioClient = createMinioClient();
        ThreadPoolTaskExecutor executor = SpringUtils.getBean("threadPoolTaskExecutor");
        try {
            // 构建最终文件对象名称
            String finalObjectName = extractFilename(reqVO.getFileName(), FILE_PATH_BBS);

            // 1. 对分片按序号排序（确保合并顺序正确）,minio会跳过最后一个分片的大小校验，如果顺序是乱的，最后一个分片可能会校验失败（最后一个分片总是小于等于分片大小的）
            List&lt;String&gt; sortedPartNames = reqVO.getPartNames().stream()
                    .sorted(Comparator.comparingInt(name -&gt; {
                        // 提取分片序号（如 "48.mp4-9" → 9）
                        String indexStr = name.substring(name.lastIndexOf("-") + 1);
                        return Integer.parseInt(indexStr);
                    }))
                    .toList();
            // 构建ComposeSource数组
            List&lt;ComposeSource&gt; sources = sortedPartNames.stream().map(name -&gt;
                    ComposeSource.builder().bucket(bucketName).object(FILE_PATH_TEMP + name).build()).toList();

            // 设置合并参数
            ComposeObjectArgs composeObjectArgs = ComposeObjectArgs.builder()
                    .bucket(bucketName)
                    .object(finalObjectName)
                    .sources(sources)
                    .build();
            log.info("合并分片列表: {}", reqVO.getPartNames());
            // 合并文件分片
            minioClient.composeObject(composeObjectArgs);

            // 生成文件访问URL（去除URL中的签名参数）
            String presignedUrl = minioClient.getPresignedObjectUrl(
                    GetPresignedObjectUrlArgs.builder()
                            .bucket(bucketName)
                            .object(finalObjectName)
                            .method(Method.GET)
                            .build());
            // 异步清理分片（不阻塞主流程）
            CompletableFuture.runAsync(() -&gt; cleanupPartsAsync(reqVO.getPartNames(), minioClient), executor);
            // 删除合并后的分片
//            for (String partName : reqVO.getPartNames()) {
//                minioClient.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(partName).build());
//            }
            return handleUrl(presignedUrl);

        } catch (MinioException e) {
            throw new IOException("Error merging file parts: " + e.getMessage(), e);
        }
    }


    /**
     * 编码文件名
     *
     * @param fileName   fileName
     * @param folder folder
     * @return String
     */
    public  String extractFilename(String fileName, String folder) {
        if (folder != null) {
            return StringUtils.format("{}/{}/{}_{}.{}", folder, DateUtils.datePath(),
                    FilenameUtils.getBaseName(fileName), Seq.getId(Seq.uploadSeqType), getExtension(fileName));
        }
        return StringUtils.format("{}/{}_{}.{}", DateUtils.datePath(),
                FilenameUtils.getBaseName(fileName), Seq.getId(Seq.uploadSeqType), getExtension(fileName));
    }

    /**
     * 获取文件名的后缀
     *
     * @param originalFilename 表单文件名
     * @return 后缀名
     */
    public String getExtension(String originalFilename)
    {
        String extension = FilenameUtils.getExtension(originalFilename);
        if (StringUtils.isEmpty(extension))
        {
            extension = MimeTypeUtils.getExtension(Objects.requireNonNull(originalFilename));
        }
        return extension;
    }

    /**
     * 异步批量清理分片（提高效率）
     */
    private void cleanupPartsAsync(List&lt;String&gt; partNames, MinioClient minioClient) {
        if (partNames == null || partNames.isEmpty()) return;

        try {
            // 批量删除分片
            List&lt;DeleteObject&gt; objects = partNames.stream()
                    .map(fileName -&gt; new DeleteObject(FILE_PATH_TEMP + fileName))
                    .collect(Collectors.toList());

            Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(
                    RemoveObjectsArgs.builder()
                            .bucket(bucketName)
                            .objects(objects)
                            .build()
            );

            // 记录删除错误（非阻塞）
            for (Result&lt;DeleteError&gt; result : results) {
                try {
                    DeleteError error = result.get();
                    log.error("分片删除失败: {},原因：{}", error.objectName(), error.message());
                } catch (Exception e) {
                    log.error("处理分片删除结果异常: {}", e.getMessage());
                }
            }
        } catch (Exception e) {
            log.error("批量清理分片异常: {}", e.getMessage());
        }
    }

    /**
     * 删除指定文件
     *
     * @param fileName 文件名
     */
    public void deleteFile(String fileName) throws IOException, NoSuchAlgorithmException, InvalidKeyException {
        MinioClient minioClient = createMinioClient();
        try {
            // 删除文件
            minioClient.removeObject(RemoveObjectArgs.builder().bucket(bucketName).object(fileName).build());
        } catch (MinioException e) {
            throw new IOException("Error deleting file: " + e.getMessage(), e);
        }
    }

    public List&lt;Integer&gt; uploadFilePartCheck(String fileId) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {
        MinioClient minioClient = createMinioClient();
        // MinIO 临时分片存储路径（示例：temp/{fileId}/fileName-chunk）
        String prefix = FILE_PATH_TEMP + fileId + "/";

        // 查询 MinIO 中已存在的分片
        List&lt;Integer&gt; uploadedChunks = new ArrayList&lt;&gt;();
        Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(
                ListObjectsArgs.builder()
                        .bucket(bucketName) // 替换为你的桶名
                        .prefix(prefix)
                        .build()
        );

        // 解析分片序号（从 objectName 中提取 fileName-chunk 的数字部分）
        for (Result&lt;Item&gt; result : results) {
            Item item = result.get();
            String objectName = item.objectName();
            int chunkIndex = extractChunkIndex(objectName); // 提取分片索引
            if (chunkIndex &gt;= 0) {
                uploadedChunks.add(chunkIndex);
            }
        }

        return uploadedChunks;
    }
    private int extractChunkIndex(String objectName) {
        try {
            String[] parts = objectName.split("-");
            return Integer.parseInt(parts[parts.length - 1]);
        } catch (Exception e) {
            return -1; // 无效分片名
        }
    }

}
</code></pre>
<pre><code class="java">package com.gotion.bbs.controller;


import com.google.common.base.Stopwatch;
import com.gotion.bbs.domain.vo.FileMergeReqVO;
import com.gotion.bbs.service.impl.FileUploadService;
import com.gotion.bbs.util.BBSFileUploadUtils;
import com.gotion.bbs.util.BBSFileUploadUtils2;
import com.gotion.common.core.domain.AjaxResult;
import com.gotion.common.utils.StringUtils;
import com.gotion.common.utils.file.FileUtils;
import com.gotion.framework.config.ServerConfig;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.http.HttpStatus;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * @author zqg
 * @description:
 * @date: 2025/8/7 17:42
 */
@Slf4j
@RestController
@RequestMapping("/bbs")
public class BbsFileUploadController {


    @Resource
    private FileUploadService fileUploadService;
    private static final String FILE_PATH_BBS ="/bbs";


    @Resource
    private ServerConfig serverConfig;

    private static final String FILE_DELIMETER = ",";

    /**
     * 测试上传,后端分片，再上传，最后合并。该方案不行，速度甚至比单独上传大文件都慢。文件分片必须放到前端，然后并行调用分片上传接口
     */
    @PostMapping("/uploadLargeFileParallel")
    public AjaxResult uploadLargeFileParallel(MultipartFile file) {
        try {
            // 上传并返回新文件名称
            //String fileName = BBSFileUploadUtils2.uploadLargeFile(file,FILE_PATH_BBS+"/test");
            String fileName = BBSFileUploadUtils2.uploadLargeFileParallel(file,FILE_PATH_BBS+"/test");
            AjaxResult ajax = AjaxResult.success();
            ajax.put("url", fileName);
            ajax.put("fileName", fileName);
            ajax.put("newFileName", FileUtils.getName(fileName));
            ajax.put("originalFilename", file.getOriginalFilename());
            return ajax;
        } catch (Exception e) {
            return AjaxResult.error(e.getMessage());
        }
    }



    /**
     * 社区文件上传请求（单个）
     * 不校验文件格式
     */
    @PostMapping("/upload")
    public AjaxResult uploadFile(MultipartFile file) {
        try {
            // 上传并返回新文件名称
            log.info("文件上传开始：{},时间戳{}",file.getOriginalFilename(), System.currentTimeMillis());
            Stopwatch stopwatch = Stopwatch.createStarted();
            String fileName = BBSFileUploadUtils.uploadMinio(file,FILE_PATH_BBS,null);
            stopwatch.stop();
            log.info("文件上传结束：{},时间戳{}，耗时：{}",file.getOriginalFilename(), System.currentTimeMillis(),stopwatch.elapsed(TimeUnit.MILLISECONDS));
            AjaxResult ajax = AjaxResult.success();
            ajax.put("url", fileName);
            ajax.put("fileName", fileName);
            ajax.put("newFileName", FileUtils.getName(fileName));
            ajax.put("originalFilename", file.getOriginalFilename());
            return ajax;
        } catch (Exception e) {
            return AjaxResult.error(e.getMessage());
        }
    }

    /**
     * 社区文件上传请求（多个）
     */
    @PostMapping("/uploads")
    public AjaxResult uploadFiles(List&lt;MultipartFile&gt; files) {
        try {
            // 上传文件路径
            List&lt;String&gt; urls = new ArrayList&lt;&gt;();
            List&lt;String&gt; fileNames = new ArrayList&lt;&gt;();
            List&lt;String&gt; newFileNames = new ArrayList&lt;&gt;();
            List&lt;String&gt; originalFilenames = new ArrayList&lt;&gt;();
            for (MultipartFile file : files) {
                // 上传并返回新文件名称
                String fileName = BBSFileUploadUtils.uploadMinio(
                        file,
                        FILE_PATH_BBS,null
                );
                String url = serverConfig.getUrl() + fileName;
                urls.add(url);
                fileNames.add(fileName);
                newFileNames.add(FileUtils.getName(fileName));
                originalFilenames.add(file.getOriginalFilename());
            }
            AjaxResult ajax = AjaxResult.success();
            ajax.put("urls", StringUtils.join(urls, FILE_DELIMETER));
            ajax.put("fileNames", StringUtils.join(fileNames, FILE_DELIMETER));
            ajax.put("newFileNames", StringUtils.join(newFileNames, FILE_DELIMETER));
            ajax.put("originalFilenames", StringUtils.join(originalFilenames, FILE_DELIMETER));
            return ajax;
        } catch (Exception e) {
            return AjaxResult.error(e.getMessage());
        }
    }

    /**
     *
     * 删除minio文件夹（文件夹下的所有文件）
     * 例如：https://mom.gotion.com.cn:9199/oatest-minio/school-oa/bbs/v1/
     */
    @PostMapping("/delete")
    public AjaxResult deleteFile(@RequestParam String filePath) {
        // 参数校验
        if (filePath == null || filePath.trim().isEmpty()) {
            return AjaxResult.error("文件名不能为空");
        }

        // 防止路径遍历攻击
        // 安全校验：检查是否为合法的文件路径
        if (filePath.contains("../") || filePath.startsWith("/")) {
            return AjaxResult.error("文件名不合法");
        }
        try {
            BBSFileUploadUtils.deleteMinio(filePath);
            // 记录操作日志
            log.info("文件删除成功: {}", filePath);
            return AjaxResult.success();
        } catch (Exception e) {
            // 记录错误日志
            log.error("文件删除失败: {}", filePath, e);
            return AjaxResult.error("文件删除失败");
        }
    }

    /**
     * 批量删除minio文件
     * 例如：https://mom.gotion.com.cn:9199/oatest-minio/school-oa/bbs/2025/08/14/1.mp4
     */
    @PostMapping("/deleteBatch")
    public AjaxResult deleteFiles(@RequestParam List&lt;String&gt; filePath) {
        // 参数校验
        if (CollectionUtils.isEmpty(filePath)) {
            return AjaxResult.error("文件名不能为空");
        }
        for (String path : filePath) {
            // 防止路径遍历攻击
            // 安全校验：检查是否为合法的文件路径
            if (path.contains("../") || path.startsWith("/")) {
                return AjaxResult.error("文件名不合法");
            }
        }
        try {
            BBSFileUploadUtils.deleteFilesBatch(filePath);
            // 记录操作日志
            log.info("文件批量删除成功: {}", filePath);
            return AjaxResult.success();
        } catch (Exception e) {
            // 记录错误日志
            log.error("文件批量删除失败: {}", filePath, e);
            return AjaxResult.error("文件批量删除失败");
        }
    }

    @GetMapping("/upload/part/check")
    public AjaxResult uploadFilePartCheck(String fileId) throws Exception {
        log.info("文件上传检查：{}",fileId);
        return AjaxResult.success(fileUploadService.uploadFilePartCheck(fileId));
    }



    /**
     * 上传文件分片
     *
     * @param fileId      文件标识符
     * @param filePart    文件分片
     * @param chunkIndex  当前分片索引
     * @return 响应状态
     */
    @PostMapping("/upload/part/{fileId}")
    public AjaxResult uploadFilePart(
            @PathVariable String fileId,
            @RequestParam String fileName,
            @RequestParam MultipartFile filePart,
            @RequestParam int chunkIndex) {

        try {
            // 上传文件分片
            String objectName = fileUploadService.uploadFilePart(fileId,fileName, filePart, chunkIndex);
            AjaxResult ajax = AjaxResult.success();
            return ajax.put("url", objectName);
        } catch (IOException e) {
            return AjaxResult.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Error uploading file part: " + e.getMessage());
        }
    }

    /**
     * 合并文件分片
     *
     * @param reqVO 参数
     * @return 响应状态
     */
    @PostMapping("/merge")
    public AjaxResult mergeFileParts(@RequestBody @Validated FileMergeReqVO reqVO) {
        try {
            String url = fileUploadService.mergeFileParts(reqVO);
            AjaxResult ajax = AjaxResult.success();
            return ajax.put("url", url);
        } catch (IOException | NoSuchAlgorithmException | InvalidKeyException e) {
            return AjaxResult.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Error merging file parts: " + e.getMessage());
        }
    }



}
</code></pre>
<p>前端核心组件文件：</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class="upload-container"&gt;
    &lt;!-- 上传区域 --&gt;
    &lt;div 
      class="upload-area" 
      @click="selectFile" 
      :class="{ dragging: isDragging }"
    &gt;
      &lt;input 
        type="file" 
        ref="fileInput" 
        class="file-input" 
        @change="handleFileChange"
        @dragover.prevent="isDragging = true"
        @dragleave.prevent="isDragging = false"
        @drop.prevent="handleDrop"
      &gt;
      &lt;div class="upload-hint"&gt;
        &lt;el-icon class="upload-icon"&gt;
          &lt;UploadFilled /&gt;
        &lt;/el-icon&gt;
        &lt;p&gt;点击或拖拽文件到此处上传&lt;/p&gt;
        &lt;p class="text-sm text-gray-500"&gt;支持大文件分片上传，自动断点续传（分片大小：5MB）实际会根据文件大小动态调整&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 上传进度 --&gt;
    &lt;div v-if="uploading" class="progress-card"&gt;
      &lt;div class="file-info"&gt;
        &lt;span class="file-name"&gt;{{ fileName }}&lt;/span&gt;
        &lt;span class="file-size"&gt;{{ formatFileSize(fileSize) }}&lt;/span&gt;
      &lt;/div&gt;
      &lt;!-- 进度条 --&gt;
      &lt;el-progress 
        :percentage="progress" 
        :status="uploadSuccess ? 'success' : (errorMessage ? 'exception' : '')"
        class="progress-bar"
      /&gt;
      &lt;!-- 进度统计 --&gt;
      &lt;div class="progress-stats"&gt;
        &lt;span&gt;{{ progress }}%&lt;/span&gt;
        &lt;span&gt;{{ formatFileSize(uploadedSize) }} / {{ formatFileSize(fileSize) }}&lt;/span&gt;
      &lt;/div&gt;
      &lt;!-- 操作按钮 --&gt;
      &lt;div class="upload-controls"&gt;
        &lt;el-button 
          @click="toggleUpload" 
          size="small" 
          :icon="paused ? UploadFilled : VideoPause"
          type="primary"
        &gt;
          {{ paused ? '继续' : '暂停' }}
        &lt;/el-button&gt;
        &lt;el-button 
          @click="cancelUpload" 
          size="small" 
          icon="DeleteFilled"
          type="danger"
          style="margin-left: 8px"
        &gt;
          取消
        &lt;/el-button&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 上传成功 --&gt;
    &lt;div v-if="uploadSuccess &amp;&amp; !uploading " class="result-card success"&gt;
      &lt;el-icon color="#42b983"&gt;&lt;Check/&gt;&lt;/el-icon&gt;
      &lt;span&gt;文件上传成功！&lt;/span&gt;
      &lt;el-link 
        :href="fileUrl" 
        target="_blank" 
        type="primary"
        style="margin-left: 8px"
        
      &gt;
        查看文件
      &lt;/el-link&gt;
    &lt;/div&gt;

    &lt;!-- 上传失败 --&gt;
    &lt;div v-if="errorMessage &amp;&amp; !uploadSuccess" class="result-card error"&gt;
      &lt;el-icon color="#f56c6c"&gt;&lt;WarningFilled /&gt;&lt;/el-icon&gt;
      &lt;span&gt;{{ errorMessage }}&lt;/span&gt;
      &lt;el-button 
        @click="retryUpload" 
        size="small" 
        type="primary"
        style="margin-left: 8px"
      &gt;
        重试
      &lt;/el-button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue'
import { 
  ElProgress,
  ElButton,
  ElIcon,
  ElLink,
  ElMessage
} from 'element-plus'
import { UploadFilled, VideoPause,Check,WarningFilled } from '@element-plus/icons-vue'
import SparkMD5 from 'spark-md5'
import request from '../utils/request'
// 声明自定义事件（传递给父组件）
const emit = defineEmits(['upload-success', 'upload-error'])

// DOM 引用
const fileInput = ref(null)

// 状态管理
const file = ref(null) // 当前选择的文件
const fileName = ref('') // 文件名
const fileSize = ref(0) // 文件大小（字节）
const fileId = ref('') // 文件唯一标识（MD5）
const chunkSize = ref(5 * 1024 * 1024) // 分片大小：5MB
const totalChunks = ref(0) // 总分片数
const uploadedChunks = ref(new Set()) // 已上传分片索引
const chunksToUpload = ref([]) // 待上传分片索引
const uploading = ref(false) // 是否正在上传
const paused = ref(false) // 是否暂停
const progress = ref(0) // 上传进度（%）
const uploadedSize = ref(0) // 已上传大小（字节）
const isDragging = ref(false) // 是否拖拽中
const uploadSuccess = ref(false) // 上传成功
const errorMessage = ref('') // 错误信息
const fileUrl = ref('') // 上传成功后的文件URL
const abortControllers = ref(new Map()) // 取消请求控制器
const currentUploads = ref(0) // 当前并发上传数
const maxConcurrent = ref(6) // 最大并发数

// 初始化：检查 MinIO 存储桶（可选，后端已处理则可删除）
onMounted(() =&gt; {
  // request.get('/createBucketIfNotExists').catch(err =&gt; {
  //   console.warn('检查存储桶失败：', err)
  // })
})

// 选择文件
const selectFile = () =&gt; {
  fileInput.value.click()
}

// 处理文件选择
const handleFileChange = (e) =&gt; {
  const selectedFile = e.target.files[0]
  if (selectedFile) {
    initUpload(selectedFile)
  }
  // 重置 input，支持重复选择同一文件
  fileInput.value.value = ''
}

// 处理拖拽文件
const handleDrop = (e) =&gt; {
  isDragging.value = false
  const droppedFile = e.dataTransfer.files[0]
  if (droppedFile) {
    initUpload(droppedFile)
  }
}

// 初始化上传（重置状态 + 计算文件MD5）
const initUpload = (selectedFile) =&gt; {
  // 重置所有状态
  resetState()
  
  // 设置文件基础信息
  file.value = selectedFile
  fileName.value = selectedFile.name
  fileSize.value = selectedFile.size
  // 动态设置分片大小（根据文件大小）
  chunkSize.value = calculateChunkSize(fileSize.value)
// 小文件直接完整上传，不计算MD5和分片
  if (chunkSize.value === 0 || fileSize.value &lt;= chunkSize.value) {
    uploadEntireFile(); // 直接上传整个文件
  } else {
    calculateFileMD5(); // 大文件走分片逻辑
  }
}

// 动态计算分片大小
const calculateChunkSize = (fileSize) =&gt; {
  const MB = 1024 * 1024
  if (fileSize &lt; 10 * MB) {
    return fileSize // 小于10MB：不分片（整个文件作为1个分片）
  } else if (fileSize &lt; 50 * MB) {
    return 5 * MB // 10MB~50MB：分片5MB
  } else if (fileSize &lt; 100 * MB) {
    return 10 * MB // 50MB~100MB：分片10MB
  } else if (fileSize &lt; 500 * MB) {
    return 20 * MB // 100MB~500MB：分片20MB
  } else {
    return 50 * MB // 大于500MB：分片50MB
  }
}

// 计算文件MD5（用于唯一标识和断点续传）
const calculateFileMD5 = () =&gt; {
  const spark = new SparkMD5.ArrayBuffer()
  const reader = new FileReader()
  const md5ChunkSize = 2 * 1024 * 1024 // 计算MD5的分片大小：2MB
  let offset = 0 // 读取偏移量
  let loaded = 0 // 已读取大小

  // 显示准备中提示
  const loadingMsg = ElMessage({
    message: '正在准备文件，请稍候...',
    type: 'info',
    duration: 0
  })

  // 读取完成回调
  reader.onload = (e) =&gt; {
    spark.append(e.target.result)
    loaded += e.target.result.byteLength

    // 更新准备进度
    const prepareProgress = Math.round((loaded / fileSize.value) * 100)
    if (prepareProgress &lt; 100) {
      ElMessage.closeAll()
      ElMessage({
        message: `正在准备文件：${prepareProgress}%`,
        type: 'info',
        duration: 0
      })
    }

    // 继续读取下一分片
    offset += md5ChunkSize
    if (offset &lt; fileSize.value) {
      readNextMD5Chunk(reader, offset, md5ChunkSize)
    } else {
      // MD5计算完成
      fileId.value = spark.end()
      ElMessage.closeAll()
      ElMessage.success('文件准备完成，开始上传')

      // 计算总分片数
      totalChunks.value = Math.ceil(fileSize.value / chunkSize.value)

      // 检查已上传分片（断点续传）
      checkUploadedChunks()
    }
  }

  // 读取错误回调
  reader.onerror = () =&gt; {
    ElMessage.closeAll()
    errorMessage.value = '文件读取失败，请重试'
    emit('upload-error', '文件读取失败')
  }

  // 开始读取第一个分片
  readNextMD5Chunk(reader, offset, md5ChunkSize)
}

// 读取下一个分片用于计算MD5
const readNextMD5Chunk = (reader, offset, size) =&gt; {
  const blob = file.value.slice(offset, offset + size)
  reader.readAsArrayBuffer(blob)
}
// 直接上传完整文件（不分片）
const uploadEntireFile = () =&gt; {
  uploading.value = true;
  progress.value = 0;

  const formData = new FormData();
  formData.append('file', file.value);
  //formData.append('fileName', fileName.value);

  request({
    url: '/bbs/upload', // 新增的后端接口
    method: 'POST',
    data: formData,
     headers: { 'Content-Type': 'multipart/form-data' },
    onUploadProgress: (e) =&gt; {
      progress.value = Math.round((e.loaded / e.total) * 100);
    }
  })
  .then((response) =&gt; {
    console.log(response)
    uploadSuccess.value = true;
    fileUrl.value = response.url; // 假设后端返回文件URL
    emit('upload-success', {
      name: fileName.value,
      url: fileUrl.value,
      size: fileSize.value,
      fileId: file.value.name + '-' + fileSize.value // 简易唯一标识
    });
  })
  .catch((err) =&gt; {
    errorMessage.value = '上传失败：' + err.message;
    emit('upload-error', errorMessage.value);
  })
  .finally(() =&gt; {
    uploading.value = false;
  });
};
// 检查已上传分片（断点续传核心）
const checkUploadedChunks = () =&gt; {
  if (!fileId.value) return

  // 调用后端接口查询已上传分片
  request.get(`/bbs/upload/part/check?fileId=${fileId.value}`)
    .then((uploadedIndexes) =&gt; {
      // 记录已上传分片
      uploadedIndexes.forEach(index =&gt; uploadedChunks.value.add(Number(index)))

      // 计算已上传大小和进度
      uploadedSize.value = uploadedChunks.value.size * chunkSize.value
      progress.value = Math.round((uploadedChunks.value.size / totalChunks.value) * 100)

      // 生成待上传分片列表
      chunksToUpload.value = []
      for (let i = 0; i &lt; totalChunks.value; i++) {
        if (!uploadedChunks.value.has(i)) {
          chunksToUpload.value.push(i)
        }
      }

      // 所有分片已上传：直接合并
      if (uploadedChunks.value.size === totalChunks.value) {
        mergeChunks()
      } else {
        // 开始上传
        uploading.value = true
        startUploading()
      }
    })
    .catch((err) =&gt; {
      errorMessage.value = '查询已上传分片失败：' + err.message
      emit('upload-error', errorMessage.value)
    })
}

// 开始并发上传分片
const startUploading = () =&gt; {
  // if (paused.value) {
  //   paused.value = false
  // }

  // 控制并发：不超过 maxConcurrent
  while (currentUploads.value &lt; maxConcurrent.value &amp;&amp; chunksToUpload.value.length &gt; 0) {
    const chunkIndex = chunksToUpload.value.shift()
    uploadSingleChunk(chunkIndex)
  }
}

// 上传单个分片
const uploadSingleChunk = (chunkIndex) =&gt; {
  if (!file.value || paused.value) return

  currentUploads.value++

  // 计算分片起止位置
  const start = chunkIndex * chunkSize.value
  const end = Math.min(start + chunkSize.value, fileSize.value)
  const chunkBlob = file.value.slice(start, end)

  // 构建 FormData
  const formData = new FormData()
  formData.append('filePart', chunkBlob)
  formData.append('fileName', fileName.value)
  formData.append('chunkIndex', chunkIndex)
  //formData.append('totalChunks', totalChunks.value)

  // 创建取消控制器
  const controller = new AbortController()
  abortControllers.value.set(chunkIndex, controller)

  // 上传分片
  request({
    url: `/bbs/upload/part/${fileId.value}`,
    method: 'POST',
    data: formData,
    headers: { 'Content-Type': 'multipart/form-data' },
    signal: controller.signal,
    // 监听上传进度
    onUploadProgress: (progressEvent) =&gt; {
      const chunkLoaded = progressEvent.loaded
      const chunkTotal = progressEvent.total || (end - start)
      const chunkProgress = chunkLoaded / chunkTotal

      // 计算总进度
      const totalLoaded = uploadedSize.value + (chunkProgress * (end - start))
      progress.value = Math.round((totalLoaded / fileSize.value) * 100)
    }
  })
  .then(() =&gt; {
    // 分片上传成功
    uploadedChunks.value.add(chunkIndex)
    uploadedSize.value += (end - start)
    progress.value = Math.round((uploadedChunks.value.size / totalChunks.value) * 100)

    // 所有分片上传完成：合并
    if (uploadedChunks.value.size === totalChunks.value) {
      mergeChunks()
      return
    }

    // 继续上传下一个分片
    startUploading()
  })
.catch((err) =&gt; {
  // ✅ 1. 判断是否是取消（暂停）
  const isCanceled = 
    err.name === 'AbortError' || 
    err.name === 'CanceledError' ||
    err.message?.toLowerCase().includes('canceled') ||
    err.message?.toLowerCase().includes('aborted')

  // ✅ 2. 暂停状态，需要把分片放回队列
  if (isCanceled &amp;&amp; paused) {
    chunksToUpload.value.unshift(chunkIndex)
  }

  // ✅ 3. 只有真实错误才提示
  if (!isCanceled) {
    errorMessage.value = `分片 ${chunkIndex + 1} 上传失败：${err.message}`
    ElMessage.error(errorMessage.value)
    emit('upload-error', errorMessage.value)
  }

  // ✅ 4. 静默处理取消操作
})
  // .catch((err) =&gt; {
  //   // 排除手动取消的错误
  //   console.log('错误===》',err.name)
  //   if (err.name !== 'AbortError') {
  //     chunksToUpload.value.unshift(chunkIndex) // 重新加入待上传队列
  //     errorMessage.value = `分片 ${chunkIndex + 1} 上传失败：${err.message}`
  //     emit('upload-error', errorMessage.value)
  //   }
  // })
  .finally(() =&gt; {
    currentUploads.value--
    abortControllers.value.delete(chunkIndex)

     //nextTick(startUploading)
  })
}

// 合并分片
const mergeChunks = () =&gt; {
  // 构建合并请求参数
  const mergeParams = {
    fileId: fileId.value,
    fileName: fileName.value,
    totalChunks: totalChunks.value,
    // 生成已上传分片名称列表（对应后端 FILE_PATH_TEMP 路径）
    partNames: Array.from(uploadedChunks.value).map(index =&gt; 
      `${fileId.value}/${fileName.value}-${index}`
    )
  }

  // 调用后端合并接口
  request.post('/bbs/merge', mergeParams)
    .then((fileUrlResp) =&gt; {
      console.log('合并成功===&gt;',fileUrlResp)
      // 合并成功
      uploadSuccess.value = true
      uploading.value = false
      fileUrl.value = fileUrlResp.url

      ElMessage.closeAll()
      ElMessage.success('文件上传成功！')

      // 传递成功事件给父组件
      emit('upload-success', {
        name: fileName.value,
        url: fileUrl.value,
        size: fileSize.value,
        fileId: fileId.value
      })
    })
    .catch((err) =&gt; {
      errorMessage.value = '文件合并失败：' + err.message
      uploading.value = false
      emit('upload-error', errorMessage.value)
    })
}

// 暂停/继续上传
const toggleUpload = () =&gt; {
  if (paused.value) {
    // 继续上传
    paused.value = false
    startUploading()
  } else {
    // 暂停上传：取消所有正在进行的请求
    paused.value = true
    abortControllers.value.forEach(controller =&gt; controller.abort())
    abortControllers.value.clear()
    currentUploads.value = 0
  }
}

// 取消上传
const cancelUpload = () =&gt; {
  //可以调用后端接口，删除已经上传的部分分片文件
  // 取消所有请求
  abortControllers.value.forEach(controller =&gt; controller.abort())
  // 重置状态
  resetState()
  ElMessage.info('上传已取消')
}

// 重试上传
// const retryUpload = () =&gt; {
//   errorMessage.value = ''
//   if (file.value) {
//     checkUploadedChunks()
//   }
// }
// 重试上传 - 完整版本
const retryUpload = () =&gt; {
  errorMessage.value = ''
  if (file.value) {
    // 显示重试提示
    ElMessage.info('正在重新上传...')
    
    // 重置上传状态
    resetUploadState()
    
    // 重新计算分片大小
    const currentChunkSize = calculateChunkSize(fileSize.value)
    chunkSize.value = currentChunkSize
    
    if (currentChunkSize === 0 || fileSize.value &lt;= currentChunkSize) {
      // 小文件：直接上传
      uploadEntireFile()
    } else {
      // 大文件：如果已有MD5则直接检查分片，否则重新计算MD5
      if (fileId.value) {
        checkUploadedChunks()
      } else {
        calculateFileMD5()
      }
    }
  }
}

// 重置上传状态（保留文件基本信息）
const resetUploadState = () =&gt; {
  totalChunks.value = 0
  uploadedChunks.value.clear()
  chunksToUpload.value = []
  uploading.value = false
  paused.value = false
  progress.value = 0
  uploadedSize.value = 0
  uploadSuccess.value = false
  errorMessage.value = ''
  fileUrl.value = ''
  abortControllers.value.clear()
  currentUploads.value = 0
}
// 重置所有状态
const resetState = () =&gt; {
  file.value = null
  fileName.value = ''
  fileSize.value = 0
  fileId.value = ''
  totalChunks.value = 0
  uploadedChunks.value.clear()
  chunksToUpload.value = []
  uploading.value = false
  paused.value = false
  progress.value = 0
  uploadedSize.value = 0
  uploadSuccess.value = false
  errorMessage.value = ''
  fileUrl.value = ''
  abortControllers.value.clear()
  currentUploads.value = 0
}

// 格式化文件大小（字节 → KB/MB/GB）
const formatFileSize = (bytes) =&gt; {
  if (bytes === 0) return '0 B'
  const k = 1024
  const units = ['B', 'KB', 'MB', 'GB', 'TB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return `${(bytes / Math.pow(k, i)).toFixed(2)} ${units[i]}`
}

&lt;/script&gt;

&lt;style scoped&gt;
.upload-container {
  width: 100%;
}

/* 上传区域 */
.upload-area {
  border: 2px dashed #dcdfe6;
  border-radius: 8px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s;
  background-color: #fff;
}

.upload-area.dragging {
  border-color: #42b983;
  background-color: rgba(66, 185, 131, 0.05);
}

.file-input {
  display: none;
}

.upload-hint {
  color: #606266;
}

.upload-icon {
  font-size: 48px;
  color: #42b983;
  margin-bottom: 16px;
}

.text-sm {
  font-size: 12px;
  margin-top: 8px;
}

.text-gray-500 {
  color: #909399;
}

/* 进度卡片 */
.progress-card {
  margin-top: 16px;
  padding: 16px;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.file-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  font-size: 14px;
}

.file-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 60%;
}

.file-size {
  color: #909399;
}

.progress-bar {
  margin: 8px 0;
}

.progress-stats {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #909399;
  margin-bottom: 12px;
}

/* 结果卡片 */
.result-card {
  margin-top: 16px;
  padding: 12px 16px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  font-size: 14px;
}

.success {
  background-color: rgba(66, 185, 131, 0.1);
  color: #359e6f;
}

.error {
  background-color: rgba(245, 108, 108, 0.1);
  color: #e45252;
}
&lt;/style&gt;
</code></pre>
<p>前端代码demo：<a target="_blank" rel="noopener" href="https://gitee.com/zqg2233/vue-study/tree/master/FileChunkUpload">zqg2233/vue-study</a></p>
<p>最后，如果是分片上传到服务器，在服务器上合并成完整文件，可参考下面的工具类：</p>
<pre><code class="java">package com.gotion.system.utils;

import cn.hutool.core.util.IdUtil;
import com.gotion.common.config.MinioConfig;
import com.gotion.common.utils.SecurityUtils;
import com.gotion.common.utils.file.FileUploadUtils;
import com.gotion.common.utils.spring.SpringUtils;
import com.gotion.system.domain.SysFileStorage;
import com.gotion.system.service.ISysFileService;
import io.minio.*;
import io.minio.http.Method;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.multipart.MultipartFile;
import ws.schild.jave.MultimediaObject;
import ws.schild.jave.info.MultimediaInfo;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * 分片上传工具类
 *
 */
@Slf4j
public class ChunkUploadUtils {

    /**
     * 临时文件存储目录
     */
    private static final String CHUNK_TEMP_DIR = System.getProperty("java.io.tmpdir") + "/chunk_upload/";

    /**
     * 上传文件分片
     *
     * @param file        文件分片
     * @param identifier  文件唯一标识
     * @param chunkNumber 分片序号
     * @return 是否上传成功
     */
    public static boolean uploadChunk(MultipartFile file, String identifier, Integer chunkNumber) {
        try {
            // 创建临时目录
            Path tempDir = Paths.get(CHUNK_TEMP_DIR, identifier);
            if (!Files.exists(tempDir)) {
                Files.createDirectories(tempDir);
            }

            // 保存分片文件
            Path chunkPath = tempDir.resolve("chunk_" + chunkNumber);
            file.transferTo(chunkPath);
            return true;
        } catch (Exception e) {
            log.error("上传文件分片失败", e);
            return false;
        }
    }

    /**
     * 检查分片是否已上传
     *
     * @param identifier  文件唯一标识
     * @param chunkNumber 分片序号
     * @return 是否已上传
     */
    public static boolean checkChunk(String identifier, Integer chunkNumber) {
        try {
            Path chunkPath = Paths.get(CHUNK_TEMP_DIR, identifier, "chunk_" + chunkNumber);
            return Files.exists(chunkPath);
        } catch (Exception e) {
            log.error("检查分片是否存在失败", e);
            return false;
        }
    }

    /**
     * 合并分片文件
     */
    public static SysFileStorage mergeChunks(String identifier, Integer totalChunks, String filename, String folder, ISysFileService iSysFileService) {
        Path mergedFilePath = null;
        try {
            // 创建临时目录
            Path tempDir = Paths.get(CHUNK_TEMP_DIR, identifier);
            if (!Files.exists(tempDir)) {
                Files.createDirectories(tempDir);
            }

            // 创建合并后的文件路径
            String mergedFileName = FileUploadUtils.extractFilename(new MockMultipartFile(filename), folder);
            mergedFilePath = Paths.get(CHUNK_TEMP_DIR, identifier, mergedFileName);

            if (!Files.exists(mergedFilePath.getParent())) {
                Files.createDirectories(mergedFilePath.getParent());
            }

            // 合并所有分片 - 使用缓冲流提高性能
            long totalSize = 0;
            try (BufferedOutputStream outputStream = new BufferedOutputStream(
                    Files.newOutputStream(mergedFilePath,
                            StandardOpenOption.CREATE,
                            StandardOpenOption.WRITE,
                            StandardOpenOption.TRUNCATE_EXISTING))) {

                for (int i = 1; i &lt;= totalChunks; i++) {
                    Path chunkPath = Paths.get(CHUNK_TEMP_DIR, identifier, "chunk_" + i);
                    if (Files.exists(chunkPath)) {
                        try (BufferedInputStream chunkStream = new BufferedInputStream(Files.newInputStream(chunkPath))) {
                            byte[] buffer = new byte[8192]; // 8KB缓冲区
                            int bytesRead;
                            while ((bytesRead = chunkStream.read(buffer)) != -1) {
                                outputStream.write(buffer, 0, bytesRead);
                                totalSize += bytesRead;
                            }
                        }
                        log.info("已合并分片: {}, 大小: {} bytes", chunkPath, Files.size(chunkPath));
                    } else {
                        log.error("分片不存在: {}", chunkPath);
                        throw new RuntimeException("分片不存在: " + chunkPath);
                    }
                }
            }

            // 强制刷新到磁盘并验证文件
            long fileSize = Files.size(mergedFilePath);
            log.info("文件合并完成: {}, 大小: {} bytes, 计算大小: {} bytes",
                    mergedFilePath, fileSize, totalSize);

            if (fileSize != totalSize) {
                throw new RuntimeException("文件大小不匹配，可能合并过程中出现错误");
            }

            // 获取文件类型信息
            String contentType = Files.probeContentType(mergedFilePath);
            if (contentType == null) {
                contentType = getContentTypeByFilename(filename);
            }

            String fileExtension = getFileExtension(filename);
            log.info("文件类型: {}, 文件扩展名: {}", contentType, fileExtension);

            // === 新增：如果是视频文件，获取视频时长 ===
            double duration = 0;
            try {
                if (isVideoFile(fileExtension)) {
                    duration = getVideoDurationWithJave(mergedFilePath);
                }
                log.info("视频时长: {} 秒", duration);
            } catch (Exception e) {
                log.warn("获取视频时长失败: {}", e.getMessage());
            }

        // 上传到Minio - 重新打开文件流确保独立性
        MinioClient minioClient = SpringUtils.getBean(MinioClient.class);
        InputStream uploadInputStream = null;
        try {
            uploadInputStream = new BufferedInputStream(Files.newInputStream(mergedFilePath));

            ObjectWriteResponse response = minioClient.putObject(PutObjectArgs.builder()
                    .bucket(MinioConfig.getBucketName())
                    .object(mergedFileName)
                    .stream(uploadInputStream, fileSize, -1)
                    .contentType(contentType)
                    .build());

            log.info("文件上传成功: {}, ETag: {}", response.object(), response.etag());

            // 生成直接访问URL而不是预签名URL（更稳定）
            String baseUrl = MinioConfig.getDomainName(); // 替换为您的MinIO地址
            String directUrl = baseUrl + "/" + MinioConfig.getBucketName() + "/" + mergedFileName;

//                // 或者使用预签名URL但处理编码问题
//                String presignedUrl = minioClient.getPresignedObjectUrl(
//                        GetPresignedObjectUrlArgs.builder()
//                                .bucket(MinioConfig.getBucketName())
//                                .object(mergedFileName)
//                                .method(Method.GET)
//                                .expiry(24 * 60 * 60) // 24小时有效期
//                                .build());

            log.info("生成直接访问URL: {}", directUrl);
//                log.info("生成预签名URL: {}", presignedUrl);

            // 保存文件信息到数据库
            SysFileStorage sysFileStorage = new SysFileStorage();
            sysFileStorage.setFileName(filename);
            sysFileStorage.setFileId(IdUtil.getSnowflakeNextId());
            sysFileStorage.setFileUrl(directUrl); // 使用直接URL
            sysFileStorage.setFilePath(mergedFileName);
            sysFileStorage.setFileSize(fileSize);
            sysFileStorage.setCreateBy(SecurityUtils.getUserId() != null ? SecurityUtils.getUserId().toString() : "system");
            sysFileStorage.setCreateTime(new Date());
            sysFileStorage.setFileType(fileExtension);
            sysFileStorage.setDuration(String.valueOf(duration));
            sysFileStorage.setContentType(contentType);
            sysFileStorage.setStatus("0");

            // 保存到数据库
            iSysFileService.insertFile(sysFileStorage);

            log.info("文件信息保存到数据库成功，文件ID: {}", sysFileStorage.getFileId());
            return sysFileStorage;

        } finally {
            // 确保上传流关闭
            if (uploadInputStream != null) {
                try {
                    uploadInputStream.close();
                } catch (IOException e) {
                    log.warn("关闭上传流时发生错误: {}", e.getMessage());
                }
            }
        }
    } catch(
    Exception e)

    {
        log.error("合并分片文件失败", e);
        // 记录更详细的错误信息
        if (mergedFilePath != null &amp;&amp; Files.exists(mergedFilePath)) {
            try {
                log.error("合并后的文件大小: {} bytes", Files.size(mergedFilePath));
            } catch (IOException ioException) {
                log.error("无法获取合并文件大小");
            }
        }
        return null;
    } finally
    {
        // 清理临时文件
        cleanupTempFiles(identifier);
    }
}

/**
 * 根据文件名获取文件扩展名
 */
private static String getFileExtension(String filename) {
    if (filename == null || filename.lastIndexOf(".") == -1) {
        return "";
    }
    return filename.substring(filename.lastIndexOf(".") + 1).toLowerCase();
}

/**
 * 根据文件名获取Content-Type
 * 当Files.probeContentType无法识别时使用
 */
private static String getContentTypeByFilename(String filename) {
    String extension = getFileExtension(filename);
    Map&lt;String, String&gt; contentTypeMap = new HashMap&lt;&gt;();

    // 常见文件类型的MIME类型映射
    contentTypeMap.put("txt", "text/plain");
    contentTypeMap.put("pdf", "application/pdf");
    contentTypeMap.put("doc", "application/msword");
    contentTypeMap.put("docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
    contentTypeMap.put("xls", "application/vnd.ms-excel");
    contentTypeMap.put("xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    contentTypeMap.put("ppt", "application/vnd.ms-powerpoint");
    contentTypeMap.put("pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation");
    contentTypeMap.put("jpg", "image/jpeg");
    contentTypeMap.put("jpeg", "image/jpeg");
    contentTypeMap.put("png", "image/png");
    contentTypeMap.put("gif", "image/gif");
    contentTypeMap.put("bmp", "image/bmp");
    contentTypeMap.put("mp4", "video/mp4");
    contentTypeMap.put("avi", "video/x-msvideo");
    contentTypeMap.put("mov", "video/quicktime");
    contentTypeMap.put("zip", "application/zip");
    contentTypeMap.put("rar", "application/x-rar-compressed");
    contentTypeMap.put("js", "application/javascript");
    contentTypeMap.put("css", "text/css");
    contentTypeMap.put("html", "text/html");
    contentTypeMap.put("json", "application/json");
    contentTypeMap.put("xml", "application/xml");

    return contentTypeMap.getOrDefault(extension, "application/octet-stream");
}


/**
 * 清理临时文件
 *
 * @param identifier 文件唯一标识
 */
public static void cleanupTempFiles(String identifier) {
    try {
        Path tempDir = Paths.get(CHUNK_TEMP_DIR, identifier);
        if (Files.exists(tempDir)) {
            Files.walk(tempDir)
                    .sorted(java.util.Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(java.io.File::delete);
        }
    } catch (Exception e) {
        log.error("清理临时文件失败", e);
    }
}

/**
 * Mock MultipartFile实现类，用于创建文件名
 */
private static class MockMultipartFile implements MultipartFile {
    private final String name;

    public MockMultipartFile(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getOriginalFilename() {
        return name;
    }

    @Override
    public String getContentType() {
        return null;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public long getSize() {
        return 0;
    }

    @Override
    public byte[] getBytes() throws IOException {
        return new byte[0];
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return null;
    }

    @Override
    public void transferTo(Path dest) throws IOException, IllegalStateException {
    }

    @Override
    public void transferTo(java.io.File dest) throws IOException, IllegalStateException {
    }
}


public static String getFileExtensionByName(String filename) {
    if (filename == null || filename.isEmpty()) {
        return null;
    }
    int lastDotIndex = filename.lastIndexOf('.');
    if (lastDotIndex &gt; 0 &amp;&amp; lastDotIndex &lt; filename.length() - 1) {
        return filename.substring(lastDotIndex + 1);
    }
    return null;
}


/**
 * 判断是否为视频文件
 */
private static boolean isVideoFile(String fileExtension) {
    if (fileExtension == null) return false;

    Set&lt;String&gt; videoExtensions = Set.of(
            "mp4", "avi", "mov", "wmv", "flv", "mkv", "webm",
            "m4v", "3gp", "mpg", "mpeg", "ts", "mts"
    );

    return videoExtensions.contains(fileExtension.toLowerCase());
}

/**
 * 使用JAVE2获取视频时长
 */
private static Double getVideoDurationWithJave(Path videoPath) {
    try {
        File source = videoPath.toFile();
        MultimediaObject multimediaObject = new MultimediaObject(source);
        MultimediaInfo info = multimediaObject.getInfo();

        // 获取时长（毫秒）
        long durationInMillis = info.getDuration();

        // 转换为秒
        return durationInMillis / 1000.0;
    } catch (Exception e) {
        throw new RuntimeException("获取视频时长失败: " + e.getMessage(), e);
    }
}
}
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2025/04/09/SpringBoot%E6%8E%A5%E5%85%A5%E8%85%BE%E8%AE%AF%E7%94%B5%E5%AD%90%E7%AD%BE/" title="SpringBoot接入腾讯电子签"><span class="has-text-weight-semibold">Next: SpringBoot接入腾讯电子签</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="zhangqingguo/zhangqingguo.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangqingguo"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> ZQG 2026</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"> </script></body></html>