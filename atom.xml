<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZQG的博客</title>
  
  <subtitle>zzz</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-27T06:41:42.758Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ZQG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python学习</title>
    <link href="http://example.com/2025/03/27/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2025/03/27/python%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-27T06:23:46.000Z</published>
    <updated>2025-03-27T06:41:42.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言">1、前言</h2><p>一直想学习python，于是在工作之余看免费的教程学习，但是因为工作忙或者自律性不够，总是断断续续，所以想记录一下学习笔记，方便复习和督促自己坚持学下去。视频教程来自：<a href="https://www.bilibili.com/video/BV1wD4y1o7AS/">https://www.bilibili.com/video/BV1wD4y1o7AS/</a></p><h2 id="2、学习内容">2、学习内容</h2><h3 id="1、python简介及开发环境">1、python简介及开发环境</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、前言&quot;&gt;1、前言&lt;/h2&gt;
&lt;p&gt;一直想学习python，于是在工作之余看免费的教程学习，但是因为工作忙或者自律性不够，总是断断续续，所以想记录一下学习笔记，方便复习和督促自己坚持学下去。视频教程来自：&lt;a href=&quot;https://www.bilibili</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/category/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot接入itext5生成pdf</title>
    <link href="http://example.com/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/"/>
    <id>http://example.com/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/</id>
    <published>2025-02-27T03:30:05.000Z</published>
    <updated>2025-03-18T09:02:48.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot集成itext5，实现pdf生成"><a href="#SpringBoot集成itext5，实现pdf生成" class="headerlink" title="SpringBoot集成itext5，实现pdf生成"></a>SpringBoot集成itext5，实现pdf生成</h1><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在项目开发中有需要生成pdf文件的功能，常见的方案如下：</p><ol><li>html作为模板，（Thymeleaf、freemaker等模板引擎）渲染数据，最后生成pdf</li><li>使用pdf模板（使用如：Adobe Acrobat编辑器，创建一个带有表单字段的PDF），填充数据，最后生成pdf</li><li>使用pdf模板（使用占位符，比如${name}），用数据替换占位符，最后生成pdf。比较复杂，不容易实现，不建议。</li></ol><p>如何得到pdf文件，主要有两种方法，一种是写代码生成，还有就是用pdf转换工具，比如wkhtmltopdf之类的。由于在项目中考虑到，使用html的方案，在修改模板时对用户不友好，所以采用了方案2：pdf模板+表单+填充数据。</p><p>工具使用<strong>itext5</strong>，因为itext7免费使用受到了某些限制，必须遵循 AGPL 开源协议，或购买商业许可证。还有其他免费的，如：<strong>Apache PDFBox</strong>，特点如下：</p><table><thead><tr><th align="left">技术</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>iText</strong></td><td align="left">功能强大，支持复杂 PDF 操作</td><td align="left">复杂 PDF 生成</td></tr><tr><td align="left"><strong>Apache PDFBox</strong></td><td align="left">免费，简单易用</td><td align="left">简单 PDF 生成</td></tr><tr><td align="left"><strong>Thymeleaf + Flying Saucer</strong></td><td align="left">基于 HTML 模板生成 PDF</td><td align="left">需要 HTML 模板的场景</td></tr><tr><td align="left"><strong>OpenPDF</strong></td><td align="left">iText 的免费分支，轻量级</td><td align="left">简单 PDF 生成</td></tr><tr><td align="left"><strong>JFreeReport + JFreeChart</strong></td><td align="left">支持生成带图表的 PDF</td><td align="left">需要图表的 PDF 生成</td></tr></tbody></table><h2 id="2、开发过程"><a href="#2、开发过程" class="headerlink" title="2、开发过程"></a>2、开发过程</h2><p>环境：SpringBoot 2.7.6、JDK1.8、itext 5.x</p><h3 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;    &lt;artifactId&gt;itextpdf&lt;/artifactId&gt;    &lt;version&gt;5.5.9&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--中文字体问题解决--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.itextpdf&lt;/groupId&gt;    &lt;artifactId&gt;itext-asian&lt;/artifactId&gt;    &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="准备好pdf，并且设置好表单字段。"><a href="#准备好pdf，并且设置好表单字段。" class="headerlink" title="准备好pdf，并且设置好表单字段。"></a>准备好pdf，并且设置好表单字段。</h3><p>直接打卡Adobe Acrobat,创建一个空白pdf，然后在工具里面，点击准备表单。实际上，在创建pdf时，可以选择word文件，因为直接编辑pdf格式很难调整，而格式调整好的word转成pdf就好办多了，在相应对方添加表单域就可以了。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227155017718.png" alt="image-20250227155017718"></p><p>按钮一栏可以自行摸索，添加相应的域，这里就不多解释了。注意pic字段，我用的依然是文本域，而不是图片域，因为代码不一样，这个后面再说。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227162640729.png" alt="image-20250227162640729"></p><p>注意，复选框要设置选中显示的值，也就是图中的导出值，样式也可以设置。</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>PdfUtils的主要方法如下：</p><pre><code class="java">/** * 通过pdf模板输出到流 * * @param templateFile 模板 * @param dataMap      input数据 * @param picData      image图片 * @param checkboxMap  checkbox勾选框 * @param params       设置属性,字体大小、颜色 textfont/textcolor/textsize等 * @param outputStream 输出流 */public static void output(String templateFile, Map&lt;String, Object&gt; dataMap, Map&lt;String, byte[]&gt;picData,                          Map&lt;String, byte[]&gt; picData2,Map&lt;String, String&gt; checkboxMap,                           Map&lt;String,Object&gt; params,OutputStream outputStream) {    PdfStamper ps = null;    PdfReader reader = null;    try {        reader = new PdfReader(templateFile);        ps = new PdfStamper(reader, outputStream);        AcroFields form = ps.getAcroFields();        BaseFont bf = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);        form.addSubstitutionFont(bf);        if (ObjectUtils.isNotEmpty(dataMap)) {            for (String key : dataMap.keySet()) {                form.setField(key, String.valueOf(dataMap.getOrDefault(key, "")));            }        }        //不能编辑        ps.setFormFlattening(true);        if (ObjectUtils.isNotEmpty(checkboxMap)) {            for (String key : checkboxMap.keySet()) {                form.setField(key, checkboxMap.get(key), true);            }        }        PdfStamper stamper = ps;        if (ObjectUtils.isNotEmpty(picData)) {            picData.forEach((filedName, imgSrc) -&gt; {                List&lt;AcroFields.FieldPosition&gt; fieldPositions = form.getFieldPositions(filedName);                for (AcroFields.FieldPosition fieldPosition : fieldPositions) {                    int pageNo = fieldPosition.page;                    Rectangle signRect = fieldPosition.position;                    float x = signRect.getLeft();                    float y = signRect.getBottom();                    try {                        Image image = Image.getInstance(imgSrc);                        PdfContentByte under = stamper.getOverContent(pageNo);                        image.scaleToFit(signRect.getWidth(), signRect.getHeight());                        image.setAbsolutePosition(x, y);                        under.addImage(image);                    } catch (BadElementException e) {                        log.error("pdf模板，文档元素错误 ", e);                    } catch (IOException e) {                        log.error("pdf模板，IO错误 ", e);                    } catch (DocumentException e) {                        log.error("pdf模板，文档操作错误 ", e);                    }                }            });        }        if (!ObjectUtils.isEmpty(picData2)) {                picData2.forEach((filedName, imgSrc) -&gt; {                    List&lt;AcroFields.FieldPosition&gt; fieldPositions = form.getFieldPositions(filedName);                    for (AcroFields.FieldPosition fieldPosition : fieldPositions) {                        int pageNo = fieldPosition.page;                        Rectangle signRect = fieldPosition.position;                        float x = signRect.getLeft();                        float y = signRect.getBottom();                        try {                            URL url = new URL(imgSrc);                            Image image = Image.getInstance(url);                            PdfContentByte under = stamper.getOverContent(pageNo);                            image.scaleToFit(signRect.getWidth(), signRect.getHeight());                            image.setAbsolutePosition(x, y);                            under.addImage(image);                        } catch (BadElementException e) {                            e.printStackTrace();                        } catch (IOException e) {                            e.printStackTrace();                        } catch (DocumentException e) {                            e.printStackTrace();                        }                    }                });            }    } catch (Exception e) {        log.error("pdf模板填充数据异常 ", e);    } finally {        if (Objects.nonNull(ps)) {            try {                ps.close();            } catch (Exception e) {                log.error("pdf模板关闭异常 ", e);            }        }        if (Objects.nonNull(reader)) {            try {                reader.close();            } catch (Exception e) {                log.error("pdf模板关闭异常 ", e);            }        }    }}</code></pre><p>参数说明：</p><table><thead><tr><th>参数名称</th><th>参数类型</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>templateFile</td><td>String</td><td>/xx/xx/template.pdf</td><td>pdf模板,全路径</td></tr><tr><td>dataMap</td><td>Map&lt;String, Object&gt;</td><td>{  “name”: “John”,  “age”: 30,  “address”: “北京”}</td><td>文本字段数据的map</td></tr><tr><td>picData</td><td>Map&lt;String, byte[]&gt;</td><td>{“pic1”:”xxx”}</td><td>图片的数据map,其中byte[]是图片文件转成的字节数组</td></tr><tr><td>picData2</td><td>Map&lt;String, String&gt;</td><td>{“pic2”:”xxx”}</td><td>图片的数据map,其中值是图片的url地址</td></tr><tr><td>checkboxMap</td><td>Map&lt;String, String&gt;</td><td>{“checkbox1”:”1”}</td><td>复选框的数据map。1代表选中，这个是在编辑pdf模板时设置的。</td></tr><tr><td>params</td><td>Map&lt;String,Object&gt;</td><td>{“textsize”:”12f”}</td><td>设置属性,字体大小、颜色 textfont/textcolor/textsize等</td></tr><tr><td>outputStream</td><td>OutputStream</td><td></td><td>生成的pdf后，输出流</td></tr><tr><td>…</td><td></td><td></td><td></td></tr></tbody></table><p>接口代码：</p><pre><code class="java">@GetMapping("/previewPdf")public void previewPdf(HttpServletRequest request, HttpServletResponse response) throws IOException {    String templateFile = "D:\\workspace\\IdeaProjects\\pdfDemo\\src\\main\\resources\\static\\template.pdf";    Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;();    dataMap.put("name", "张小凡");    dataMap.put("age", "101");    dataMap.put("address", "上海市宛平南路600号");    dataMap.put("year", LocalDate.now().getYear());    dataMap.put("month", LocalDate.now().getMonthValue());    dataMap.put("day", LocalDate.now().getDayOfMonth());    response.setCharacterEncoding("utf-8");    response.setContentType("application/pdf");    Map&lt;String, byte[]&gt; picMap = new HashMap&lt;&gt;();    byte[] imageToBytes = ImageUtil.imageToBytes("D:\\workspace\\IdeaProjects\\pdfDemo\\src\\main\\resources\\static\\33981008.jpg");    picMap.put("pic", imageToBytes);    Map&lt;String, String&gt; picMap2 = new HashMap&lt;&gt;();    picMap2.put("pic2", "https://tse3-mm.cn.bing.net/th/id/OIP-C.jdP04yEoxG10mcywseQj7gAAAA?rs=1&amp;pid=ImgDetMain");    Map&lt;String, String&gt; checkboxMap = new HashMap&lt;&gt;();    checkboxMap.put("smoke", "1");    checkboxMap.put("drink", "1");    checkboxMap.put("hair", "0");    String fileName = new String("测试预览pdf文件".getBytes(), "ISO-8859-1");//避免中文乱码    response.setHeader("Content-Disposition", "inline;filename=".concat(String.valueOf(fileName) + ".pdf"));    PdfUtil.output(templateFile, dataMap, picMap, picMap2,checkboxMap, response.getOutputStream());}</code></pre><p>下载的接口只要修改一行代码：</p><pre><code class="java">response.setHeader("Content-Disposition", "attachment;filename=".concat(fileName + ".pdf"));</code></pre><h3 id="结果展示："><a href="#结果展示：" class="headerlink" title="结果展示："></a>结果展示：</h3><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227164234458.png" alt="image-20250227164234458"></p><p>ok，完美</p><h2 id="3、代码解释以及一些问题"><a href="#3、代码解释以及一些问题" class="headerlink" title="3、代码解释以及一些问题"></a>3、代码解释以及一些问题</h2><h3 id="获取表单的所有字段："><a href="#获取表单的所有字段：" class="headerlink" title="获取表单的所有字段："></a>获取表单的所有字段：</h3><pre><code class="java">AcroFields form = ps.getAcroFields();</code></pre><h3 id="创建BaseFont对象-用于加载字体"><a href="#创建BaseFont对象-用于加载字体" class="headerlink" title="创建BaseFont对象,用于加载字体"></a>创建BaseFont对象,用于加载字体</h3><pre><code class="java">BaseFont bf = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);</code></pre><p>第一个参数name，是字体名称。”STSongStd-Light” 来自iTextAsian.jar，iTextAsian.jar 里面预制了各种字体,用于中日韩等文字的显示问题。”UniGB-UCS2-H”是对应的字符编码。BaseFont.NOT_EMBEDDED 字体不会嵌入到PDF文件中（没有保存），可能会导致不同电脑显示不正确。BaseFont.EMBEDDED 使用的字体会嵌入（保存）到PDF文件中，这样文件会更大一些，这样PDF文件显示就是跨平台的</p><p><img src="https://img-blog.csdnimg.cn/20190825093623848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbWFkZWVl,size_16,color_FFFFFF,t_70" alt="aaa"></p><p>添加一个替代字体。这种方法用于指定一个或多个备用字体，当PDF中的字段需要显示的字符在原始字体中找不到时，iText将尝试使用这些备用字体显示字符.</p><pre><code class="java">form.addSubstitutionFont(bf);</code></pre><h3 id="设置字段值以及字体样式、大小等："><a href="#设置字段值以及字体样式、大小等：" class="headerlink" title="设置字段值以及字体样式、大小等："></a>设置字段值以及字体样式、大小等：</h3><pre><code class="java">form.setField(key, String.valueOf(dataMap.getOrDefault(key, "")));form.setFieldProperty(key, "textfont", bf,null);form.setFieldProperty(key, "textsize", 15.95f,null);//重新生成字段以应用属性更改form.regenerateField(key);</code></pre><p>注意：form.regenerateField(key)；这行代码是必须的，不然设置不会生效。</p><p>设置文本域不能编辑：</p><pre><code class="java">//不能编辑ps.setFormFlattening(true);</code></pre><h3 id="图片展示的两种实现："><a href="#图片展示的两种实现：" class="headerlink" title="图片展示的两种实现："></a>图片展示的两种实现：</h3><p>1、图片流的实现</p><pre><code class="java">Image image = Image.getInstance(imgSrc);PdfContentByte under = stamper.getOverContent(pageNo);image.scaleToFit(signRect.getWidth(), signRect.getHeight());image.setAbsolutePosition(x, y);under.addImage(image);</code></pre><p>2、图片url的实现:</p><pre><code class="java">URL url = new URL(imgSrc);Image image = Image.getInstance(url);PdfContentByte under = stamper.getOverContent(pageNo);image.scaleToFit(signRect.getWidth(), signRect.getHeight());image.setAbsolutePosition(x, y);under.addImage(image);</code></pre><h3 id="字体的问题："><a href="#字体的问题：" class="headerlink" title="字体的问题："></a>字体的问题：</h3><p>如果想使用iTextAsian不包含的字体怎么办？</p><h4 id="1、使用Windows系统下的字体"><a href="#1、使用Windows系统下的字体" class="headerlink" title="1、使用Windows系统下的字体"></a>1、使用Windows系统下的字体</h4><p>path是字体文件的全路径。</p><pre><code class="java"> String path = "C:\\Windows\\Fonts\\simhei.ttf"; BaseFont font = BaseFont.createFont(path, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</code></pre><p>Windows系统下的字体有的是.ttf类型，有的是.ttc类型。ttc类型的是组合字体，里面包含了几个字体的集合。若想使用ttc类型的文件，可以打开ttc文件，点击右上角下一个，看看你需要的是第几个字体，在声明字体的时候标注索引就好了。</p><pre><code class="java"> String path = "C:\\Windows\\Fonts\\simhei.ttf 0"; BaseFont font = BaseFont.createFont(path, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);</code></pre><h4 id="2、使用外部的字体"><a href="#2、使用外部的字体" class="headerlink" title="2、使用外部的字体"></a>2、使用外部的字体</h4><p>自己从网上下载字体，然后放在项目的classpath路径下：比如我的黑体文件路径：src/main/resources/fonts/simhei.ttf</p><pre><code class="java">BaseFont bf = BaseFont.createFont("/fonts/simhei.ttf", BaseFont.IDENTITY_H, BaseFont.EMBEDDED);</code></pre><p>或者使用字体流的方式：</p><pre><code class="java">// 使用类加载器获取字体文件的输入流InputStream fontStream = PdfUtil.class.getResourceAsStream("/fonts/simsun.ttf");if (Objects.isNull(fontStream)) {    throw new RuntimeException("找不到字体文件");}byte[] fontBytes = IoUtil.readBytes(fontStream);// 使用输入流创建BaseFont对象BaseFont bf = BaseFont.createFont("simsun.ttf", BaseFont.IDENTITY_H, BaseFont.EMBEDDED, true, fontBytes, null);</code></pre><p>注意：这个时候name参数是字体的文件名称带后缀。</p><p>这种方式是比较推荐的，因为项目部署到不同平台，服务器自带的字体可能不支持，所以最好是放在项目中，然后嵌入pdf中。</p><h4 id="3、使用iTextAsian的字体，或者itext自带字体（不支持中文）"><a href="#3、使用iTextAsian的字体，或者itext自带字体（不支持中文）" class="headerlink" title="3、使用iTextAsian的字体，或者itext自带字体（不支持中文）"></a>3、使用iTextAsian的字体，或者itext自带字体（不支持中文）</h4><pre><code class="java">BaseFont bf = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);</code></pre><pre><code class="java">BaseFont bf = BaseFont.createFont(BaseFont.HELVETICA, "Cp1252", BaseFont.NOT_EMBEDDED);</code></pre><h3 id="浏览器预览时，标签页的问题："><a href="#浏览器预览时，标签页的问题：" class="headerlink" title="浏览器预览时，标签页的问题："></a>浏览器预览时，标签页的问题：</h3><pre><code class="java">String fileName = new String("测试预览pdf文件".getBytes(), "ISO-8859-1");//避免中文乱码response.setHeader("Content-Disposition", "inline;filename=".concat(String.valueOf(fileName) + ".pdf"));</code></pre><p>虽然代码中设置了fileName，但是标签页却无法展示。</p><p>原因是标签页默认展示的是文档属性里面的标题。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250227180135113.png" alt="image-20250227180135113"></p><p>如果不想修改文档属性的标题，可以在代码中修改重新设置标题。</p><pre><code class="java">// 获取文档信息  Map&lt;String, String&gt; info = reader.getInfo();  if (info == null) {      info = new HashMap&lt;&gt;();  }  // 修改标题，默认显示在浏览器的标签页上，如果不设置，标签页会显示原先文档属性的标题（adobe，打开文件，属性，设置标题）  info.put("Title", "这是一个pdf");  // 设置文档信息  ps.setMoreInfo(info);</code></pre><p>效果：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250228142139535.png" alt="image-20250228142139535"></p><h2 id="4、使用itext5实现html转pdf"><a href="#4、使用itext5实现html转pdf" class="headerlink" title="4、使用itext5实现html转pdf"></a>4、使用itext5实现html转pdf</h2><p>由于pdf模板无法做到word那样根据内容大小自动换行，只能提前预估内容，设置文本域高度和宽度，特别是下划线上填充内容时，一行显示不下，不能自动换行，所以一些情况下，pdf模板填充内容无法满足需求。这时候考虑使用word模板然后转pdf，或者使用html转pdf。</p><p>itext5可以实现html转pdf。引入新的依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.itextpdf.tool&lt;/groupId&gt;    &lt;artifactId&gt;xmlworker&lt;/artifactId&gt;    &lt;version&gt;5.5.13.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>html可以是一个真实的文件，也可以是html字符串，还可以用模板引擎。最后都是转成流参数。简单实例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="UTF-8"/&gt;    &lt;style&gt;        body {            font-family: "SimSun", "Microsoft YaHei", sans-serif;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style="text-align: center"&gt;标题&lt;/h1&gt;&lt;p&gt;这是一段测试文本！&lt;/p&gt;&lt;p style="text-align: left;color: red"&gt;这是第二段测试文本！&lt;/p&gt;&lt;div&gt;    &lt;img src="http://www.baidu.com/img/bdlogo.gif" alt="百度" title="百度" width="100" height="100"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="java">@GetMapping("/previewPdf7")public void previewPdf7(HttpServletRequest request, HttpServletResponse response) throws IOException, DocumentException {    // 创建 PDF 文档    Document document = new Document();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PdfWriter writer = PdfWriter.getInstance(document, baos);    document.open();    // 读取 HTML 文件   // FileInputStream htmlFile = new FileInputStream("input.html");    String html = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";    InputStream htmlStream = new ByteArrayInputStream(html.getBytes(StandardCharsets.UTF_8));    // 从类路径加载 HTML 文件    InputStream htmlFile = MyPdfController.class.getResourceAsStream("/static/index2.html");    document.addTitle("html转pdf测试");    FontProvider asianFontProvider = new FontProvider() {        @Override        public boolean isRegistered(String s) {            return false;        }        @Override        public Font getFont(String s, String s1, boolean b, float v, int i, BaseColor baseColor) {            BaseFont bfChinese = null;            try {                bfChinese = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);            } catch (DocumentException | IOException e) {                throw new RuntimeException(e);            }            return new Font(bfChinese, v, i, baseColor);        }    };    // 使用 XMLWorkerHelper 将 HTML 转换为 PDF   // XMLWorkerHelper.getInstance().parseXHtml(writer, document, htmlFile, StandardCharsets.UTF_8, new AsianFontProvider());    XMLWorkerHelper.getInstance().parseXHtml(writer, document, htmlFile, StandardCharsets.UTF_8, asianFontProvider);    // 关闭文档    document.close();    // 获取 PDF 字节流    byte[] pdfBytes = baos.toByteArray();    response.setCharacterEncoding(StandardCharsets.UTF_8.toString());    response.setContentType(MediaType.APPLICATION_PDF_VALUE);    String fileName = new String("test".getBytes(), StandardCharsets.ISO_8859_1);    response.setHeader(Header.CONTENT_DISPOSITION.getValue(), "inline;filename=".concat(fileName + ".pdf"));    // 将 PDF 字节流写入响应输出流    OutputStream out = response.getOutputStream();    out.write(pdfBytes);    out.flush();    out.close();}</code></pre><p>注意中文的问题，需要FontProvider加载中文字体才能显示中文，否则会乱码。也可以单独写一个中文的class，然后，当成参数，传给parseXHtml方法。比如：</p><pre><code class="java">/** * 用于中文显示的Provider */class AsianFontProvider extends XMLWorkerFontProvider {    @Override    public Font getFont(final String fontname, String encoding, float size, final int style) {        try {            BaseFont bfChinese = BaseFont.createFont("STSongStd-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);            return new Font(bfChinese, size, style);        } catch (Exception e) {        }        return super.getFont(fontname, encoding, size, style);    }}</code></pre><p>字体可以是iTextAsian中的，也可以自定义加载字体，这个和前面的一样。效果如下：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318160427999.png" alt="image-20250318160427999"></p><p>到这里还没结束，简单的html和简单样式可以，但是稍微复杂的样式，itext5就不支持了，所以样式多的html用itext5效果很不好。比如这样一个html页面转成pdf后，效果很差。</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318161132356.png" alt="image-20250318161132356"></p><p>pdf：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318161321981.png" alt="image-20250318161321981"></p><p>最重要的是表格显示不全，也许调整html样式可以解决，但是太麻烦，itext5对css样式支持有限是主要问题。text7支持更多的css样式，但是有开源协议的限制。</p><p>继续尝试其他的转pdf工具，比如：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt;    &lt;artifactId&gt;flying-saucer-pdf-itext5&lt;/artifactId&gt;    &lt;version&gt;9.1.22&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>但是效果一样不好，而且需要在html中指定字体，不然中文显示不出来。</p><pre><code class="html">&lt;style&gt;    body {        font-family: "SimSun", "Microsoft YaHei", sans-serif;    }&lt;/style&gt;</code></pre><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318162158739.png" alt="image-20250318162158739"></p><p>最后使用wkhtmltox工具，经过测试，这个工具转pdf效果好，所以采用这个方案，缺点是需要在服务器上安装工具、还有字体。</p><p>用工具转pdf后，可以直接保存到服务器上，也可以返回文件流。</p><pre><code class="java">@GetMapping("/previewPdf8")public void previewPdf8(HttpServletResponse response) {    response.setCharacterEncoding(StandardCharsets.UTF_8.toString());    response.setContentType(MediaType.APPLICATION_PDF_VALUE);    // HTML 内容    String htmlContent = "&lt;!DOCTYPE html&gt;\n" +            "&lt;html&gt;\n" +            "&lt;head&gt;\n" +            "    &lt;meta charset=\"UTF-8\"/&gt;\n" +            "&lt;/head&gt;\n" +            "&lt;body&gt; &lt;div data-v-137a61c0=\"\" style=\"text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 30px;\"&gt; xxx患者病历单 &lt;/div&gt;&lt;table data-v-137a61c0=\"\" cellspacing=\"0\" style=\"width: 100%; border-collapse: collapse;\"&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" colspan=\"6\" style=\"background: lightblue; line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;患者基本信息&lt;/td&gt;&lt;/tr&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;姓名&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;test012&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;性别&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;男&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;证件号&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;年龄&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;婚姻&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt; &lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;身高&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr data-v-137a61c0=\"\" style=\"border: 1px solid rgb(102, 102, 102); min-height: 40px;\"&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;体重&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt; &lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;民族&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 100px;\"&gt;就诊ID&lt;/td&gt;&lt;td data-v-137a61c0=\"\" style=\"line-height: 30px; padding: 5px 10px; border-spacing: 0px; border-right: 1px solid rgb(102, 102, 102); font-size: 14px; width: 200px;\"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;div data-v-137a61c0=\"\" style=\"font-size: 12px; color: rgb(102, 102, 102); margin: 20px 0px;\"&gt; 注：远程诊疗是异地医疗咨询活动，门诊医师与申请门诊医师之间的关系属于医学知识的咨询关系，对病人的诊断与治疗的决定权属于收治病人的医疗机构（引自原卫生部卫办发[1999]第2号）。 &lt;/div&gt;" +            "&lt;/body&gt;\n" +            "&lt;/html&gt;";    // 调用 wkhtmltopdf 将 HTML 字符串转换为 PDF 字节流    try {        byte[] pdfBytes = htmlToPdf(htmlContent);        System.out.println("PDF 生成成功！大小: " + pdfBytes.length + " 字节");        //避免中文乱码        String fileName = new String("test".getBytes(), StandardCharsets.ISO_8859_1);        response.setHeader("Content-Disposition", "inline;filename=".concat(fileName) + ".pdf");        OutputStream outputStream = response.getOutputStream();        outputStream.write(pdfBytes);        outputStream.flush();        outputStream.close();    } catch (IOException | InterruptedException e) {        e.printStackTrace();    }}public  byte[] htmlToPdf(String htmlContent) throws IOException, InterruptedException {    // 创建 ProcessBuilder    ProcessBuilder processBuilder = new ProcessBuilder("wkhtmltopdf", "-", "-");    processBuilder.redirectErrorStream(true);    // 启动进程    Process process = processBuilder.start();    // 将 HTML 内容写入进程的标准输入    try (OutputStream stdin = process.getOutputStream();         BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(stdin))) {        writer.write(htmlContent);    }    // 捕获进程的标准输出（PDF 字节流）    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    try (InputStream stdout = process.getInputStream()) {        byte[] buffer = new byte[1024];        int length;        while ((length = stdout.read(buffer)) != -1) {            outputStream.write(buffer, 0, length);        }    }    // 等待进程完成    int exitCode = process.waitFor();    if (exitCode != 0) {        throw new IOException("wkhtmltopdf 进程执行失败，退出码: " + exitCode);    }    // 返回 PDF 字节流    return outputStream.toByteArray();}</code></pre><p>效果如下：</p><p><img src="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/image-20250318162816661.png" alt="image-20250318162816661"></p><p>工具的效果还是比较好的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot集成itext5，实现pdf生成&quot;&gt;&lt;a href=&quot;#SpringBoot集成itext5，实现pdf生成&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot集成itext5，实现pdf生成&quot;&gt;&lt;/a&gt;SpringBo</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/category/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
    <category term="itext5" scheme="http://example.com/tags/itext5/"/>
    
    <category term="pdf" scheme="http://example.com/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>Vue2学习</title>
    <link href="http://example.com/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-01-23T01:20:56.000Z</published>
    <updated>2025-03-29T08:37:31.699Z</updated>
    
    <content type="html"><![CDATA[<h1>Vue2学习</h1><p>视频教程来自尚硅谷：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH/?vd_source=51c1f9b29ad3cdfa95187e2976f09cef">尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通_哔哩哔哩_bilibili</a>,vue2文档：<a href="https://v2.cn.vuejs.org/v2/guide/">介绍 — Vue.js</a></p><h2 id="1-vue基础知识和原理">1. vue基础知识和原理</h2><h3 id="1-1-初识vue">1.1 初识vue</h3><ul><li><p>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象</p></li><li><p>app容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法</p></li><li><p>app容器里的代码被称为【Vue模板】</p></li><li><p>Vue实例和容器是一一对应的,不能一对多和多对一</p></li><li><p>真实开发中只有一个Vue实例，并且会配合着组件一起使用</p></li><li>是Vue的语法：插值表达式，可以读取到data中的所有属性</li><li><p>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新(Vue实现的响应式)<br>代码：这里是直接引入开发版本的vue.js,可以去官网下载</p></li></ul><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;01&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--容器和vue实例是一对一的，不能一对多和多对一--&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}} {{op}} {{wifu}}&lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--关闭生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            op: 'BC',            wifu: 'YM'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-2-模板语法">1.2 模板语法</h3><p>Vue模板语法有2大类:</p><ul><li>插值语法：</li></ul><p>​    功能：用于解析<strong>标签体</strong>内容</p><p>​    写法：，xxx是js表达式，且可以直接读取到data中的所有属性</p><ul><li>指令语法:</li></ul><p>​    功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）</p><p>​    举例：v-bind:href=“xxx” 或 简写为 :href=“xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;插值语法&lt;/h1&gt;    &lt;h2&gt;Hello,{{name}}&lt;/h2&gt;    &lt;hr/&gt;    &lt;h1&gt;指令语法&lt;/h1&gt;    &lt;a v-bind:href="link.url"&gt;去{{link.title}}&lt;/a&gt;    &lt;!-- v-bind简写 --&gt;    &lt;br/&gt;    &lt;a :href="link.url"&gt;去{{link.title}}2&lt;/a&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            link:{                title: '百度',                url: 'https://www.baidu.com'            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-3-数据绑定">1.3 数据绑定</h3><p>Vue中有2种数据绑定的方式：</p><ul><li>单向绑定(v-bind)：数据只能从data流向页面</li><li>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data</li></ul><p>注意：</p><p>1.双向绑定一般都应用在表单类元素上（如：input、select等）</p><p>2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模板语法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    单向数据绑定：&lt;input type="text" v-bind:value="name"&gt;&lt;br/&gt;    双向数据绑定：&lt;input type="text" v-model:value="name"&gt;&lt;br/&gt;    &lt;!--    简写--&gt;    单向数据绑定2：&lt;input type="text" :value="name"&gt;&lt;br/&gt;    &lt;!-- 简写 v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值--&gt;    双向数据绑定2：&lt;input type="text" v-model="name"&gt;&lt;br/&gt;    &lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-4-el与data的两种写法">1.4 el与data的两种写法</h3><p>el有2种写法</p><ul><li>new Vue时候配置el属性</li><li>先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值</li></ul><p>data有2种写法</p><ul><li><p>对象式</p></li><li><p>函数式</p><p>注意：在组件中，data必须使用函数式。一个重要原则：由Vue管理的函数不能是箭头函数，因为这样写this就不再是Vue实例了。</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;el和data的两种写法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}} &lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    //el的两种写法    /*    const vm = new Vue({       // el: '#app',//第一种写法        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG'        }    });    console.log(vm);    vm.$mount('#app') //第二种写法,挂载容器*/    // data的两种写法    const vm2 = new Vue({        el: '#app',        // data: { //第一种写法，对象        //     name: 'ZQG'        // }        // 第二种写法，函数式        // data: function () {}        data() {            console.log(this)            return {                name: 'ZQG'            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ul><h3 id="1-5-MVVM模型">1.5 MVVM模型</h3><ul><li><p>M：模型(Model) ：data中的数据</p></li><li><p>V：视图(View) ：模板代码</p></li></ul><ul><li>VM：视图模型(ViewModel)：Vue实例</li></ul><p><img src="https://img-blog.csdnimg.cn/02f5aad7bfc440789dfa852b370f740d.webp" alt="mvvm"></p><p>data中的所有属性都在vm中。</p><p>vm的所有属性，包括Vue原型上所有属性，Vue模板都可以直接使用。</p><h3 id="1-6-数据代理">1.6 数据代理</h3><p>通过一个对象代理对另一个对象中的属性的操作(读/写)。</p><p>主要通过js方法：Object.defineProperty()实现的，需要先去了解Object.defineProperty()相关知识，属性标志，属性描述符，getter，setter.</p><p>简单介绍一下：</p><p>属性标志:</p><p>对象属性（properties），除 value 外，还有三个特殊的特性（attributes），也就是所谓的“标志”</p><p>writable — 如果为 true，则值可以被修改，否则它是只可读的，默认为false<br>enumerable — 如果为 true，则表示是可以遍历的，可以在for… .in Object.keys()中遍历出来，默认为false<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以，默认为false</p><pre><code class="language-javascript">&lt;script type="text/javascript"&gt;    let num = 18;    let person = {        name: 'ZQG',        //age: 18,        sex: '男'    };    Object.defineProperty(person, 'age',{         value: num,        // enumerable: true, // 是否可枚举，默认为false        // configurable: true,// 是否可以删除,默认为false        // writable: true// 能否修改,默认为false    })  console.log(person);&lt;/script&gt;</code></pre><p>如图：</p><p><img src="image-20250123165409650.png" alt="image-20250123165409650"></p><p>如果不将相应的配置设置为true，修改不起作用，删除也返回false，也无法枚举。</p><p>使用getter和setter时：</p><pre><code class="language-javascript">&lt;script type="text/javascript"&gt;    let num = 18;    let person = {        name: 'ZQG',        //age: 18,        sex: '男'    };    Object.defineProperty(person, 'age',{         //value: num,        // enumerable: true, // 是否可枚举，默认为false        // configurable: true,// 是否可以删除,默认为false        // writable: true// 能否修改,默认为false        get() {            console.log('读取age属性');//person.age 起作用            return num;        },        set(value) {            console.log('设置age属性,值是：', value);//person.age = 20 起作用            num = value;        }    })  console.log(person);&lt;/script&gt;</code></pre><p><img src="image-20250123170003588.png" alt="image-20250123170003588"></p><p>每次访问person.age时，会触发getter函数，返回num值；当设置person.age = xx值时，会把值设置给num，这样再次读取会返回最新的num值，（直接设置num值，获取age值也是返回设置后的num值）这样就实现了数据代理。</p><p><strong>Vue中的数据代理</strong></p><p>Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写）<br>Vue中数据代理的好处：更加方便的操作data中的数据<br>基本原理：<br>通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>为每一个添加到vm上的属性，都指定一个getter/setter。<br>在getter/setter内部去操作（读/写）data中对应的属性。</p><p>我们代码中的data实际和Vue实例中的_data是相等的，所以取值，Vue为了代码写的方便，通过数据代理将_data的属性值，直接放在vm中，所以直接取值用就可以了。</p><p>验证代码：为了验证data和我们代码中的数据（person）是一样的，所以把person定义在外面，这样可以直接可以_data==person作比较</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;数据代理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}},{{age}},{{sex}}&lt;/h1&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    let person = {        name: 'ZQG',        age: 18,        sex: '男'    };  const vm = new Vue({      el: '#app',      data: person  });  console.log(vm)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="image-20250123175247017.png" alt="image-20250123175247017"></p><p><img src="image-20250123175508777.png" alt="image-20250123175508777"></p><p><img src="image-20250123175744591.png" alt="image-20250123175744591"></p><h3 id="1-7-事件处理">1.7 事件处理</h3><p>事件的基本使用：</p><ul><li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名</li><li>事件的回调需要配置在methods对象中，最终会在vm上</li><li>methods中配置的函数不要用箭头函数，这会导致this不再是vm了</li><li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象</li><li>@click=“show” 和@click=“show($event)”，效果一致，但是后者可以传参</li></ul><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;事件处理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}}，欢迎来到{{address}}&lt;/h1&gt;    &lt;button v-on:click="showInfo"&gt;点我&lt;/button&gt;    &lt;button @click="showInfo"&gt;点我2（不传参）&lt;/button&gt;    &lt;button @click="showInfo3($event,666)"&gt;点我3（传参）&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',        data: {            name: 'ZQG',            address: '支配剧场'        },        methods: {            showInfo: function (event) {                alert('Hello,Vue!');                console.log(event);// event对象                console.log(this);// this指向当前Vue实例            },            showInfo3(event, num) {                console.log(event.target.innerText);// event对象                //console.log(this);// this指向当前Vue实例                alert(num)            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Vue中的事件修饰符</p><ul><li>prevent：阻止默认事件（常用）</li><li>stop：阻止事件冒泡（常用）</li><li>once：事件只触发一次（常用）</li><li>capture: 使用事件的捕获模式</li><li>self: 只有event.target是当前的操作元素时才触发事件</li><li>passive: 事件的默认行为立即执行，无需等待事件回调完毕</li></ul><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;事件处理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;    &lt;style type="text/css"&gt;        * {            margin-top: 10px;        }        .dd{            width: 100px;            height: 80px;            background-color: red;        }        .aa{            width: 100px;            height: 60px;            background-color: skyblue;        }        .bb{            width: 100px;            height: 20px;            background-color: green;        }        .ll{            width: 150px;            height: 100px;            background-color: orange;            overflow: auto;        }        li{            height: 50px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}}，欢迎来到{{address}}&lt;/h1&gt;    &lt;!--    阻止事件--&gt;    &lt;a href="https://www.baidu.com" @click.prevent="showInfo"&gt;点我跳转&lt;/a&gt;    &lt;div class="dd" @click="showInfo"&gt;    &lt;!--   阻止事件冒泡     --&gt;       &lt;button @click.stop="showInfo"&gt;点我&lt;/button&gt;         &lt;!--   修饰符可以连续写--&gt;        &lt;a href="https://www.baidu.com" @click.prevent.stop="showInfo"&gt;点我跳转&lt;/a&gt;    &lt;/div&gt;    &lt;!--    事件只触发一次--&gt;    &lt;button @click.once="showInfo"&gt;点我&lt;/button&gt;    &lt;!-- 原本： 事件捕获=》事件冒泡（调用）,所以打印2再打印1. 使用capture后：在捕获的时候就会调用，此时先打印1后打印2 --&gt;    &lt;div class="aa" @click.capture="showMsg(1)"&gt;        div1        &lt;div class="bb" @click="showMsg(2)"&gt;            div2        &lt;/div&gt;    &lt;/div&gt;    &lt;div class="dd" @click.self="showInfo"&gt;        &lt;!--   只有event.target是当前的操作元素时才触发事件     --&gt;        &lt;button @click="showInfo"&gt;点我&lt;/button&gt;    &lt;/div&gt;&lt;!--    @scroll 滚动条,@wheel 鼠标滚轮--&gt;    &lt;ul @wheel.passive="work" class="ll"&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',        data: {            name: 'ZQG',            address: '支配剧场'        },        methods: {            showInfo: function (event) {                alert('Hello,Vue!');                console.log(event);// event对象                console.log(this);// this指向当前Vue实例            },            showMsg: function (msg) {                alert(msg);            },            work: function (event) {                for (let i = 0; i &lt; 10000; i++) {                    console.log('#');                }            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-8-键盘事件">1.8 键盘事件</h3><p>键盘事件语法糖：@keydown，@keyup</p><p>1.Vue中常用的按键别名：</p><ul><li>回车 =&gt; enter</li><li>删除 =&gt; delete(捕获删除和退格键)</li><li>退出 =&gt; esc</li><li>空格 =&gt; space</li><li>换行 =&gt; tab (特殊，必须配合keydown去使用)</li><li>上 =&gt; up</li><li>下 =&gt;down</li><li>左 =&gt;left</li><li>右 =&gt;right</li></ul><p>2.Vue未提供别名的键，可以使用按键的原始key值去绑定,但是要注意转为kebab-case（短横线命名）</p><p>3.系统修饰键(用法特殊):ctrl,alt,shift,meta</p><p>​3.1配合keyup使用：按下修饰键的同时，再按下其他键，随后释放，事件才会触发</p><p>​3.2配合keydown使用：正常触发</p><p>4.可以使用keyCode去指定具体的按键（不推荐）</p><p>5.Vue.config.keyCode.自定义键名=键码，可以定制按键别名</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;键盘事件&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;h1&gt;Hello,{{name}}&lt;/h1&gt;    &lt;input type="text" placeholder="按下回车提示输入" @keyup="showInfo"&gt;    &lt;input type="text" placeholder="按下tab提示输入" @keydown.tab="showInfo"&gt;        &lt;!--  连写 ctrl + y --&gt;    &lt;input type="text" placeholder="按下ctrl提示输入" @keyup.ctrl.y="showInfo"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    Vue.config.productionTip = false;    Vue.config.keyCodes.dsb = 13;//自定义按键,dsb替换成enter @keyup.dsb="",不推荐使用    let person = {        name: 'ZQG'    };  new Vue({      el: '#app',      data: person,      methods: {          showInfo(e) {              console.log(e.key,e.keyCode,e.target.value)          }      }  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-9-计算属性">1.9 计算属性</h3><p>定义：要用的属性不存在，要通过已有属性计算得来。<br>原理：底层借助了Objcet.defineProperty方法提供的getter和setter<br>get函数什么时候执行？<br>(1).初次读取时会执行一次<br>(2).当依赖的数据发生改变时会被再次调用<br>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便<br>备注：<br>计算属性最终会出现在vm上，直接读取使用即可<br>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;姓名案例&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    姓: &lt;input type="text" v-model="firstName"/&gt;&lt;br&gt;    名：&lt;input type="text" v-model="lastName"/&gt;&lt;br&gt;    全名：&lt;span&gt;{{fullName}}&lt;/span&gt;&lt;br&gt;    全名：&lt;span&gt;{{fullName2}}&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            firstName: 'ZQG',            lastName: 'YM'        },        computed:{            fullName:{                //初次读取fullName时，get方法会调用一次                // 所依赖的数据发生变化时，get方法会调用一次                //其他情况，会读取缓存的数据                get(){                    console.log('get调用');                    console.log(this);                    return this.firstName + '-' + this.lastName;                },                //set方法不是必须写的，如果计算属性确定没有修改的场景，可以不写set                // 当fullName被修改时，set方法会调用一次                set(value){                    const names = value.split('-');                    this.firstName = names[0];                    this.lastName = names[1];                }            },            //简写，不包含set方法            fullName2() {                return this.firstName + '-' + this.lastName;            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-10-监视属性">1.10 监视属性</h3><p>监视属性watch：</p><ul><li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li><li>监视的属性必须存在，才能进行监视</li><li>监视的两种写法：<ul><li>(1).new Vue时传入watch配置</li><li>(2).通过vm.$watch监视</li></ul></li></ul><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;天气案例&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--容器和vue实例是一对一的，不能一对多和多对一--&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;    &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            isHot: true,        },        computed: {            info() {                return this.isHot ? '炎热' : '凉爽';            }        },        methods: {            changeWeather() {                this.isHot = !this.isHot;            }        },        watch: {            isHot: {                // 监听isHot属性的变化                handler(newValue, oldValue) {                    console.log('isHot', newValue, oldValue);                },                immediate: true, //初始化时执行handler,默认false                deep: true //深度监听            },            //简写，不需要immediate，deep时            // 监听isHot属性的变化            isHot(newValue, oldValue) {                console.log('isHot', newValue, oldValue);            }            //info，计算属性也可以被监听            // info: {            //     // 监听info属性的变化            //     handler(newValue, oldValue) {            //         console.log('info', newValue, oldValue);            //     },            //     immediate: true, //初始化时执行handler,默认false            //     deep: true //深度监听            // }        }    });    // 监听isHot属性的变化   /* vm.$watch('isHot', {        handler(newValue, oldValue) {            console.log('isHot', newValue, oldValue);        },        immediate: true, //初始化时执行handler,默认false        deep: true //深度监听    });  */    //简写，不需要配置immediate，deep时    vm.$watch('isHot',function (newValue, oldValue) {        console.log('isHot改变了', newValue, oldValue);    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>(1).Vue中的watch默认不监测对象内部值的改变（一层）<br>(2).配置deep:true可以监测对象内部值改变（多层）<br>备注：</p><p>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以</p><p>(2).使用watch时根据数据的具体结构，决定是否采用深度监视</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;天气案例-深度监视&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--容器和vue实例是一对一的，不能一对多和多对一--&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;    &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;    &lt;hr&gt;    &lt;h2&gt;a的值是{{num.a}}&lt;/h2&gt;    &lt;button @click="num.a++"&gt;点我a+1&lt;/button&gt;    &lt;hr&gt;    &lt;h2&gt;b的值是{{num.b}}&lt;/h2&gt;    &lt;button @click="num.b++"&gt;点我b+1&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            isHot: true,            num:{                a:1,                b:2            }        },        computed: {            info() {                return this.isHot ? '炎热' : '凉爽';            }        },        methods: {            changeWeather() {                this.isHot = !this.isHot;            }        },        watch: {            isHot: {                // 监听isHot属性的变化                handler(newValue, oldValue) {                    console.log('isHot', newValue, oldValue);                },                immediate: true, //初始化时执行handler,默认false                deep: true //深度监听            },            // 监听多级结构中某个属性，num.a属性的变化            'num.a':{                handler(newValue, oldValue) {                    console.log('num.a改变了', newValue, oldValue);                },            },            // 监听多级结构中所有属性的变化            num:{                handler(newValue, oldValue) {                    console.log("num改变了");                },                deep: true//深度监听            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>computed和watch之间的区别：</p><p>computed能完成的功能，watch都可以完成<br>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作<br>两个重要的小原则：</p><p>1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象</p><p>2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;姓名案例-watch写法&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    姓: &lt;input type="text" v-model="firstName"/&gt;&lt;br&gt;    名：&lt;input type="text" v-model="lastName"/&gt;&lt;br&gt;    全名：&lt;span&gt;{{fullName}}&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            firstName: 'ZQG',            lastName: 'YM',            fullName: 'ZQG-YM'        },       watch:{            firstName(newValue,oldValue){                setTimeout(()=&gt;{                    this.fullName = newValue +'-'+ this.lastName;                },1000)            },            lastName(newValue,oldValue){                this.fullName = this.firstName +'-'+ newValue;            }       }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-11-绑定样式">1.11 绑定样式</h3><h4 id="class样式"><strong>class样式</strong></h4><p>写法：:class=“xxx” xxx可以是字符串、对象、数。</p><p>所以分为三种写法，字符串写法，数组写法，对象写法</p><p><strong>字符串写法</strong></p><p>字符串写法适用于：类名不确定，要动态获取。</p><p><strong>数组写法</strong></p><p>数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p><p><strong>对象写法</strong></p><p>对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><h4 id="style样式"><strong>style样式</strong></h4><p>有两种写法，对象写法，数组写法.</p><p>:style = “{forntSize:xxx}” ,xxx时动态值</p><p>:style=“[a,b]”  a,b是样式对象</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;绑定样式&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;    &lt;style&gt;        .basic{            text-align: center;            width: 400px;            height: 100px;            border: 1px solid black;        }        .happy{            background-color: yellow;            border: 4px solid red;        }        .sad{            border: 4px solid blue;            background-color: gray;        }        .normal{            background-color: skyblue;        }        .zqg1{            background-color: yellowgreen;        }        .zqg2{            font-size: 30px;            text-shadow:2px 2px 10px red;        }        .zqg3{            border-radius: 20px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;&lt;!--    字符串写法，适用于：类名不确定，要动态获取--&gt;    &lt;div class="basic" :class="mood" @click="changeMood"&gt;{{name}}&lt;/div&gt;    &lt;br/&gt;&lt;!--   数组写法，适用于：要绑定多个样式，个数不确定，名字也不确定--&gt;    &lt;div class="basic" :class="arr"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;&lt;!--    对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用--&gt;    &lt;div class="basic" :class="classObj"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;    &lt;div class="basic" :style="styleObj"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;    &lt;div class="basic" :style="styleArr"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            mood:'normal',            arr:['zqg1','zqg2','zqg3'],            classObj:{                zqg1:true,                zqg2:false,                zqg3:true            },            styleObj:{                color:'red',                fontSize:'35px',                backgroundColor:'orange'            },            styleArr:[{color:'blue', fontSize: '45px'},{backgroundColor:'gray'}]        },        methods: {            changeMood: function () {                const arr = ['happy', 'sad','normal'];                this.mood = arr[Math.floor(Math.random() * arr.length)];            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-12-条件渲染">1.12 条件渲染</h3><h4 id="v-if">v-if</h4><p>写法：</p><p>(1).v-if=“表达式”</p><p>(2).v-else-if=“表达式”</p><p>(3).v-else=“表达式”</p><p>适用于：切换频率较低的场景</p><p>特点：不展示的DOM元素直接被移除</p><p>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”</p><h4 id="v-show"><strong>v-show</strong></h4><ul><li>写法：v-show=“表达式”</li><li>适用于：切换频率较高的场景</li><li>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉(display:none)</li></ul><p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到;v-if 是实打实地改变dom元素，v-show 是隐藏或显示dom元素</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;条件渲染&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2 v-show="condition"&gt;你好，{{name}}&lt;/h2&gt;    &lt;br/&gt;    &lt;h2 v-show="1===1"&gt;你好，{{name}}&lt;/h2&gt;    &lt;hr&gt;    &lt;h2 v-if="1===1"&gt;你好，{{name}}&lt;/h2&gt;    &lt;hr&gt;    &lt;h2&gt;当前i的值是：{{i}}&lt;/h2&gt;    &lt;button @click="i++"&gt;点我++&lt;/button&gt;    &lt;div v-if ="i === 1"&gt;Angular&lt;/div&gt;    &lt;div v-else-if ="i === 2 "&gt;React&lt;/div&gt;    &lt;div v-else-if="i === 3"&gt;Vue&lt;/div&gt;    &lt;div v-else&gt;666&lt;/div&gt;&lt;!--  template只能和v-if配合使用  --&gt;    &lt;template v-if="i === 4"&gt;        &lt;h2&gt;zqg&lt;/h2&gt;        &lt;h2&gt;bc&lt;/h2&gt;        &lt;h2&gt;ym&lt;/h2&gt;    &lt;/template&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据            name: 'ZQG',            condition: true,            i: 0        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-13-列表渲染">1.13 列表渲染</h3><h4 id="v-for指令">v-for指令</h4><ul><li>用于展示列表数据</li><li>语法：v-for=“(item, index) in xxx” :key=“yyy”</li><li>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li></ul><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表渲染&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt; &lt;ul&gt;     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;     &lt;hr/&gt;     &lt;li v-for="(p,index) in persons" :key="index"&gt;{{p.name}}-{{p.age}}&lt;/li&gt; &lt;/ul&gt;    &lt;hr/&gt;    &lt;h2&gt;汽车信息&lt;/h2&gt;    &lt;li v-for="(value,key,index) in car" :key="key"&gt;        {{index}}-{{key}}-{{value}}    &lt;/li&gt;    &lt;hr/&gt;    &lt;h2&gt;字符串信息&lt;/h2&gt;    &lt;li v-for="(value,index) in str" :key="index"&gt;        {{index}}--{{value}}    &lt;/li&gt;    &lt;hr&gt;    &lt;h2&gt;遍历次数&lt;/h2&gt;    &lt;li v-for="(value,index) in 5" :key="index"&gt;        {{index}} -- {{value}}    &lt;/li&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: 'zqg', age: 18},               {id: '002', name: 'bc',age: 19},               {id: '003', name: 'ym',age: 20},           ],            car: {                name: '奔驰',                price: '1000000',                color: '黑色'            },            str: 'hello world'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="key的原理">key的原理</h4><p>可以先了解一下虚拟DOM和真实DOM，以及它们之间的差异：<a href="https://juejin.cn/post/6844903895467032589">深入剖析：Vue核心之虚拟DOM使用 Vue 做项目也有两年时间了，对 Vue 的 api也用的比较得心应手了，虽然对 - 掘金</a></p><p><strong>虚拟DOM中key的作用</strong></p><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p><ol><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><p>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p><p>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key:</p><p>创建新的真实DOM，随后渲染到到页面。</p></li></ol><p><strong>用index作为key可能会引发的问题：</strong></p><ol><li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作：</p><p>会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p></li><li><p>如果结构中还包含输入类的DOM：</p><p>会产生错误DOM更新==&gt;界面有问题。</p></li></ol><p><strong>开发中如何选择key：</strong></p><ol><li>最好使用每条数据的唯一标识作为key，如id，身份证号，手机号，学号等。</li><li>如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表展示，可以使用index作为key。</li></ol><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表渲染-key的原理&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;button @click.once="add"&gt;添加一个老张&lt;/button&gt; &lt;ul&gt;     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}} &lt;input type="text"&gt;&lt;/li&gt;     &lt;hr/&gt;     &lt;li v-for="(p,index) in persons" :key="index"&gt;{{p.name}}-{{p.age}} &lt;input type="text"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: 'zqg', age: 18},               {id: '002', name: 'bc',age: 19},               {id: '003', name: 'ym',age: 20},           ]        },        methods: {            add() {                const p = {id: '004', name: '老张', age: 30};                this.persons.unshift(p);            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Vue中key原理图：</p><p>index作为key时：注意，如果不指定key，Vue会默认用index作为key。</p><p><img src="image-20250210160230853.png" alt="image-20250210160230853"></p><p>因为老刘被插到第一个，重刷了 key 的值，vue Diff 算法根据 key 的值判断虚拟DOM 全部发生了改变，然后全部重新生成新的真实 DOM（key所对应的input输入框，算法比对是一样的，所以直接复用了，这导致页面上输入框对不上）。实际上，张三，李四，王五并没有发生更改，是可以直接复用之前的真实 DOM，而因为 key 的错乱，导致要全部重新生成，造成了性能的浪费。</p><p>使用唯一标识作为key时：</p><p><img src="image-20250210160037121.png" alt="image-20250210160037121"></p><h3 id="1-14-列表过滤">1.14 列表过滤</h3><p>watch和computed都可以实现，computed更简单方便</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表过滤&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type="text" v-model="keyword" placeholder="请输入名字"&gt; &lt;ul&gt;     &lt;li v-for="p in filterPersons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: '马冬梅', age: 18},               {id: '002', name: '周冬雨',age: 19},               {id: '003', name: '周杰伦',age: 20},               {id: '004', name: '温兆伦',age: 25}           ],            //filterPersons:[],            keyword: ''        },        computed: {            filterPersons() {                return this.persons.filter(p =&gt; p.name.indexOf(this.keyword) !== -1);            }        },        /*        watch: {            keyword:{                immediate: true,                handler(newValue, oldValue) {                    this.filterPersons = this.persons.filter(p =&gt; p.name.indexOf(newValue) !== -1);                }            }        }        */    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-15-列表排序">1.15 列表排序</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;列表排序&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;input type="text" v-model="keyword" placeholder="请输入名字"&gt;    &lt;button @click="sortType=1"&gt;年龄升序&lt;/button&gt;    &lt;button @click="sortType=2"&gt;年龄降序&lt;/button&gt;    &lt;button @click="sortType=0"&gt;原顺序&lt;/button&gt; &lt;ul&gt;     &lt;li v-for="p in filterPersons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;     &lt;hr/&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: '马冬梅', age: 28},               {id: '002', name: '周冬雨',age: 19},               {id: '003', name: '周杰伦',age: 20},               {id: '004', name: '温兆伦',age: 25}           ],            keyword: '',            sortType:0 //0:原顺序，1：升序，2：降序        },        computed: {            filterPersons() {                return this.persons.filter(p =&gt; p.name.indexOf(this.keyword) !== -1).sort(                    (p1, p2) =&gt; {                        if (this.sortType === 1) {                            return p1.age - p2.age;                        } else if (this.sortType === 2) {                            return p2.age - p1.age;                        } else {                            return 0;                        }                    }                );            }        },    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-16-Vue监测数据的原理">1.16 Vue监测数据的原理</h3><h4 id="监测对象数据：">监测对象数据：</h4><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;更新时的问题&lt;/title&gt;    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--准备好一个容器--&gt;&lt;div id="app"&gt;    &lt;h2&gt;人员列表&lt;/h2&gt;    &lt;button @click="updateYm"&gt;更新ym&lt;/button&gt; &lt;ul&gt;     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt; &lt;/ul&gt;    &lt;button @click="addGender"&gt;添加性别&lt;/button&gt;    &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt;    &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt;    &lt;h3&gt;性别：{{student.gender}}&lt;/h3&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;    &lt;!--生产环境提示--&gt;    Vue.config.productionTip = false;    const vm = new Vue({        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串        data: { //数据,给el 容器中的元素提供数据           persons: [               {id: '001', name: 'zqg', age: 18},               {id: '002', name: 'bc',age: 19},               {id: '003', name: 'ym',age: 20},           ],            student:{                name:'lyf',                age:18            }        },        methods:{            updateYm(){                //this.persons[2].name = 'lyf' //成功，生效                this.persons[0]={id: '001', name: 'zzz', age: 10}//失效，因为vue对数组的变更进行了监听，如果直接修改数组中的某一个对象，vue是无法知道这个数组发生了变化，所以需要使用数组的方法进行操作，如：push、pop、shift、unshift、splice等            },            addGender(){                //Vue.set(this.student,'gender','男')                this.$set(this.student,'gender','女')            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>现象：直接修改person数组中某个对象的某个属性值室，Vue可以监测到并解析模板重新渲染，但是把某个对象改了（替换），代码是执行了，内存中的数据夜修改成功了，但是页面没有变化，说明Vue没有监测到。</p><p>Vue 监测数据变化的原理：</p><p>加工data中的数据（主要是添加响应式的getter和setter方法，用的是Object.defineProperty()方法）==&gt;把加工后的对象传给_data,也就是vm._data = data  ==&gt; 属性值改变会调用set方法，在set方法中去解析模板，生成虚拟DOM，新旧DOM比较，更新页面。</p><p>简单模拟实现一下：</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模拟数据监测&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" &gt;    let data = {        name:'zqg',        address:'bj',    }    //创建一个监视的实例对象，用于监视data中属性的变化，（Vue实际做的更多，更完善）    const obs = new Observer(data)    console.log(obs)    //准备一个vm实例对象    let vm = {}    vm._data = data = obs        function Observer(obj){        //汇总对象中所有的属性形成一个数组        const keys = Object.keys(obj)        //遍历        keys.forEach((k) =&gt; {            Object.defineProperty(this, k, {                get() {                    return obj[k]                },                set(val) {                    console.log(`${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)                    obj[k] = val                }            })        })    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>Vue.set 的使用</strong></p><p>Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index，value)</p><p>用法：</p><p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式<strong>对象</strong>上添加新 property，因为 Vue 无法探测普通的新增 property (比如 vm.myObject.newProperty = ‘xx’)</p><p><img src="image-20250212180852337.png" alt="image-20250212180852337"></p><h4 id="监测数组：">监测数组：</h4><p>vue 没有为数组中的元素生成 getter 和 setter，所以监测不到数据的更改（根据index替换元素的值），也不会引起页面的更新。</p><p>想要Vue监测到数据变化，需要使用数组的方法进行操作，如：push、pop、shift、unshift、splice等。（这些方法已经被Vue包装了）</p><p><img src="image-20250213112714047.png" alt="image-20250213112714047"></p><p>除了用数组方法，当然还可以用Vue.set()或者vm.$set()来修改数组元素。</p><h4 id="总结：">总结：</h4><p><strong>Vue监视数据的原理：</strong></p><p>vue会监视data中所有层次的数据。</p><p><strong>如何监测对象中的数据？</strong></p><p>通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><p>对象中后追加的属性，Vue默认不做响应式处理，如需给后添加的属性做响应式，请使用如下API：</p><p>Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index，value)</p><p><strong>如何监测数组中的数据？</strong></p><p>通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>1、调用原生对应的方法对数组进行更新<br>2、重新解析模板，进而更新页面<br><strong>在Vue修改数组中的某个元素一定要用如下方法：</strong></p><p>1、使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>2、Vue.set() 或 vm.$set()</p><p><strong>注意：Vue.set() 或 vm.$set() 不能给vm对象和根数据对象_data，添加响应式的属性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Vue2学习&lt;/h1&gt;
&lt;p&gt;视频教程来自尚硅谷：&lt;a href=&quot;https://www.bilibili.com/video/BV1Zy4y1K7SH/?vd_source=51c1f9b29ad3cdfa95187e2976f09cef&quot;&gt;尚硅谷Vue2.0+Vue</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/category/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue2" scheme="http://example.com/tags/Vue2/"/>
    
    <category term="学习笔记，前端" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>支付宝V3接口接入</title>
    <link href="http://example.com/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/"/>
    <id>http://example.com/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/</id>
    <published>2024-12-25T07:18:26.000Z</published>
    <updated>2024-12-26T06:51:39.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot项目接入支付宝v3接口"><a href="#SpringBoot项目接入支付宝v3接口" class="headerlink" title="SpringBoot项目接入支付宝v3接口"></a>SpringBoot项目接入支付宝v3接口</h1><h2 id="1、接入准备"><a href="#1、接入准备" class="headerlink" title="1、接入准备"></a>1、接入准备</h2><p>首先到<a href="https://open.alipay.com/">支付宝开放平台</a>注册或者登录，选择移动/网页支付，按照页面的指引进行接入（正式生产环境是必须要申请账号、创建应用、配置相关参数等）。如果只是开发测试，可以使用支付宝提供的沙箱环境，下面的所有的内容都是基于沙箱环境的。</p><p>打开<a href="https://open.alipay.com/develop/manage">控制台首页 - 开放平台</a>，选择开发工具里的沙箱，可以查看支付宝分配给你的沙箱环境账号信息，特别是公钥和私钥，或者证书。本次开发，我用的是公钥和私钥的接口加签方式，使用证书也可以，只不过在1.0和2.0版本的接口，公私钥和证书的代码有些许不同，貌似在3.0版本中，代码都一样，只要在AlipayConfig中给相应字段赋值接可以了。</p><p>总之，接入准备的步骤，详细看支付宝官方文档，这里就不详细介绍了。</p><h2 id="2、开发环境"><a href="#2、开发环境" class="headerlink" title="2、开发环境"></a>2、开发环境</h2><p>开发工具：idea + maven</p><pre><code class="properties">SpringBoot.version=2.7.8alipay-sdk-java-v3.version=3.1.22.ALL</code></pre><p>在pom文件引入支付宝v3版本的依赖：（注意如果SpringBoot的版本过低，会导致OkHttp的版本变低，导致接口调用失败，要么直接强制指定OkHttp的版本为alipay-sdk-java-v3中引用的，如4.9.3，要么升级SpringBoot的版本，2.7.8是没问题的）</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;    &lt;artifactId&gt;alipay-sdk-java-v3&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="3、编写测试代码"><a href="#3、编写测试代码" class="headerlink" title="3、编写测试代码"></a>3、编写测试代码</h2><h3 id="3-1-支付宝接口的配置信息"><a href="#3-1-支付宝接口的配置信息" class="headerlink" title="3.1 支付宝接口的配置信息"></a>3.1 支付宝接口的配置信息</h3><p>实际项目开发，配置信息放在配置文件中，如果用证书，证书一定要妥善保管，一般放在服务器里。这里直接就写死了，配置信息来自支付宝的沙箱账号信息。</p><pre><code class="java">private AlipayConfig getAlipayConfig() {    AlipayConfig alipayConfig = new AlipayConfig();    //alipayConfig.setServerUrl("https://openapi.alipay.com");    alipayConfig.setServerUrl("https://openapi-sandbox.dl.alipaydev.com");    alipayConfig.setAppId("9021xxxxxxxxxxxxx");    alipayConfig.setPrivateKey("MIIEvAIBADANxxxxxxxxxxxxxxx");    alipayConfig.setAlipayPublicKey("MIIBIjANBgxxxxxxxxxxxxxxx");    return alipayConfig;}</code></pre><h3 id="3-2-电脑网站支付"><a href="#3-2-电脑网站支付" class="headerlink" title="3.2 电脑网站支付"></a>3.2 电脑网站支付</h3><p>这个就是常见的在电脑浏览器上点击支付，会出现二维码或者登录支付宝账户，扫码或者输入支付密码然后支付完成。详细文档：<a href="https://opendocs.alipay.com/open-v3/05w3qc">产品介绍 - 支付宝文档中心</a></p><p>支付宝的文档十分详细，但是初次接入肯定会有点眼花缭乱，下面我挑一些重点的内容来将和我踩过的一些坑。</p><h4 id="支付流程："><a href="#支付流程：" class="headerlink" title="支付流程："></a>支付流程：</h4><p>电脑网站支付的支付接口 <a href="https://opendocs.alipay.com/open-v3/0e5a81?scene=22">alipay.trade.page.pay</a>（统一收单下单并支付页面接口）调用时序图如下：</p><p><img src="https://gw.alipayobjects.com/os/skylark-tools/public/files/0ba3e82ad37ecf8649ee4219cfe9d16b.png%26originHeight%3D2023%26originWidth%3D2815%26size%3D526149%26status%3Ddone%26width%3D2815" alt="流程图"></p><p><strong>调用流程如下</strong>：</p><ol><li>商家系统调用 <a href="https://opendocs.alipay.com/open-v3/0e5a81?scene=22">alipay.trade.page.pay</a>（统一收单下单并支付页面接口）向支付宝发起支付请求，支付宝对商家请求参数进行校验，而后重新定向至用户登录页面。</li><li>用户确认支付后，支付宝通过 get 请求 returnUrl（商户入参传入），返回同步返回参数。</li><li>交易成功后，支付宝通过 post 请求 notifyUrl（商户入参传入），返回异步通知参数。</li><li>若由于网络等原因，导致商家系统没有收到异步通知，商家可自行调用 <a href="https://opendocs.alipay.com/open-v3/0e5a7y">alipay.trade.query</a>（统一收单交易查询接口）查询交易以及支付信息（商家也可以直接调用该查询接口，不需要依赖异步通知）。</li></ol><p><strong>注意</strong>： </p><ul><li>由于同步返回的不可靠性，支付结果必须以异步通知或查询接口返回为准，不能依赖同步跳转。</li><li>商家系统接收到异步通知以后，必须通过验签（验证通知中的 sign 参数）来确保支付通知是由支付宝发送的。详细验签规则可查看 <a href="https://opendocs.alipay.com/open-v3/05w3qh?pathHash=78bd7a2c#s7">异步通知验签</a>。</li><li>接收到异步通知并验签通过后，请务必核对通知中的 app_id、out_trade_no、total_amount 等参数值是否与请求中的一致，并根据 trade_status 进行后续业务处理。</li><li>在支付宝端，partnerId 与 out_trade_no 唯一对应一笔单据，商家端保证不同次支付 out_trade_no 不可重复；若重复，支付宝会关联到原单据，基本信息一致的情况下会以原单据为准进行支付。</li></ul><h4 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h4><p>开放平台提供了支持主流开发语言的 SDK 接入的方式。对于页面跳转类 API，SDK 不会也无法像系统调用类 API 一样自动请求支付宝并获得结果，而是在接受 request 请求对象后，为开发者生成前台页面请求需要的完整 form 表单的 html（包含自动提交脚本），商家直接将这个表单的 String 输出到 http response 中即可。</p><p><strong>注意：</strong></p><ul><li>付款页面生成的付款码每 <strong>2 分钟</strong> 会自动刷新一次。</li><li>电脑网站支付后使用 <a href="https://opendocs.alipay.com/open-v3/repo-021o7g?ref=api_v3">商家分账</a> 完成分账，查询结果需使用 <a href="https://opendocs.alipay.com/open-v3/0e5a7y">alipay.trade.query</a>（统一收单交易查询接口） <code>query_options</code> 传入 <code>trade_settle_info</code> 查询分账信息，不能使用 alipay.trade.order.settle.query（交易分账查询接口）查询。</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p>文档中的代码很长，但是最关键的是代码没有展示如何设置<strong>return_url</strong>和<strong>notify_url</strong>两个参数，这就有点坑了，return_url是支付完成了跳转回原来系统的地址，notify_url是接收支持成功的异步通知的，我自己试了几次没成功，然后再支付宝社区找答案，于是：</p><p><img src="/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/image-20241225163338921.png" alt="图1"></p><p>也就是说<strong>return_url</strong>和<strong>notify_url</strong>都放在<strong>bizContent</strong>业务参数中，结果还是不对。。。。。。，后来找技术支持，说还是要和bizContent同级，也就是放在<strong>bizParams</strong>中，这真是，说虽然是V3接口，但是还是走的V2的逻辑，好吧。关键的代码如下：</p><pre><code class="java"> ApiClient defaultClient = Configuration.getDefaultApiClient(); // 初始化alipay参数（全局设置一次） defaultClient.setAlipayConfig(getAlipayConfig()); GenericExecuteApi api = new GenericExecuteApi(); // 构造请求参数以调用接口 Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;(); // 设置商户订单号 bizContent.put("out_trade_no", String.valueOf(System.currentTimeMillis())); // 设置订单总金额 bizContent.put("total_amount", "6.88"); // 设置订单标题 bizContent.put("subject", "测试电脑网站支付"); // 设置产品码 bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY"); // 设置订单附加信息 bizContent.put("body", "谢谢谢谢"); // 设置PC扫码支付的方式 bizContent.put("qr_pay_mode", "2"); bizParams.put("biz_content", bizContent); //return_url 必须是 http 或 https 开头的完整的 url 地址。 //return_url 地址后不可带自定义参数。 //设置 return_url 时不要进行转义、urlencode 等数据处理。 //当面付和APP支付不支持 return_url 参数，即使设置了也没有任何效果。 //同步通知参数只可参考，不能作为判断是否支付成功的依据。 bizParams.put("return_url", "https://docs.open.alipay.com"); bizParams.put("notify_url", "http://xxxxx/pay/pcNotify"); try {        System.out.println(JSON.serialize(bizParams));        // 如果是第三方代调用模式，请设置app_auth_token（应用授权令牌）        String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "POST", bizParams);        // 如果需要返回GET请求，请使用        // String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "GET", bizParams);        System.out.println(pageRedirectionData);        return pageRedirectionData;    } catch (ApiException e) {        System.out.println("调用失败");    }</code></pre><p>电脑网站支付就可以了。</p><h3 id="3-3-APP支付"><a href="#3-3-APP支付" class="headerlink" title="3.3 APP支付"></a>3.3 APP支付</h3><p>这个是最常见的了，在商家APP中集成支付宝SDK，然后支付。<a href="https://opendocs.alipay.com/open-v3/05vuxe?pathHash=3444d649">产品介绍 - 支付宝文档中心</a>，后端调用app支付接口，返回订单的加密信息给前端，然后前端调用支付接口，完成支付。</p><p>交互流程:</p><p><img src="http://mdn.alipayobjects.com/afts/img/A*TKy2TKpVL3wAAAAAAAAAAAAAAa8wAA/original?bz=openpt_doc&amp;t=4msaCTXlxU0OKJWNkWsscvHbSGcA6jWukIuBa4lIU0UDAAAAZAAAMK8AAAAA" alt="p2"></p><p>以下对重点步骤做简要说明：</p><ul><li>第 1 步用户在商户 App 客户端/小程序中购买商品下单。</li><li>第 2 步商户订单信息由商户 App 客户端/小程序发送到服务端。</li><li>第 3 步商家服务端调用 <a href="https://opendocs.alipay.com/open-v3/429e4d75_alipay.trade.app.pay">alipay.trade.app.pay（app支付接口2.0接口）</a>通过支付宝服务端 SDK 获取 orderStr（orderStr 中包含了订单信息和签名）。</li><li>第 4 步商家将 orderStr 发送给商户 App 客户端/小程序。</li><li>第 5 步商家在客户端/小程序发起请求，将 orderStr 发送给支付宝。</li><li>第 6 步进行支付预下单：支付宝客户端将会按照商家客户端提供的请求参数进行支付预下单。正常场景下，会唤起支付宝收银台等待用户核身；异常场景下，会返回异常信息。</li><li>第 11 步返回商家 App/小程序：用户在支付宝 App 完成支付后，会跳转回商家页面，并返回最终的支付结果（即同步通知），可查看 <a href="https://opendocs.alipay.com/open-v3/05vuxo">同步通知说明</a>。</li><li>第 13 步支付结果异步通知，支付宝会根据步骤3 传入的异步通知地址 notify_url，发送异步通知，可查看 <a href="https://opendocs.alipay.com/open-v3/05vuxp">异步通知说明</a>。</li></ul><p>除了正向支付流程外，支付宝也提供交易查询、关闭、退款、退款查询以及对账等配套 API。</p><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><pre><code class="java"> ApiClient defaultClient = Configuration.getDefaultApiClient(); // 初始化alipay参数（全局设置一次） defaultClient.setAlipayConfig(getAlipayConfig()); GenericExecuteApi api = new GenericExecuteApi(); // 构造请求参数以调用接口 Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;(); // 设置商户订单号 bizContent.put("out_trade_no", "70501111111S001111119"); // 设置订单总金额 bizContent.put("total_amount", "9.00"); // 设置订单标题 bizContent.put("subject", "大乐透"); // 设置产品码 bizContent.put("product_code", "QUICK_MSECURITY_PAY"); // 设置订单附加信息 bizContent.put("body", "Iphone6 16G"); // 设置订单绝对超时时间 bizContent.put("time_expire", "2024-12-31 10:05:00"); // 设置建议使用time_expire字段 bizContent.put("timeout_express", "90m"); bizParams.put("biz_content", bizContent); // 同步回调指定的页面 app不需要// bizParams.put("return_url", "https://docs.open.alipay.com"); bizParams.put("notify_url", "http://xxxxx/pay/appNotify"); try {     String orderStr = api.sdkExecute("alipay.trade.app.pay", bizParams);     System.out.println(orderStr);     return orderStr; } catch (ApiException e) {     System.out.println("调用失败"); }</code></pre><h3 id="3-4-手机网站支付"><a href="#3-4-手机网站支付" class="headerlink" title="3.4 手机网站支付"></a>3.4 手机网站支付</h3><p><a href="https://opendocs.alipay.com/open-v3/05w4kp?pathHash=f3e513ea">产品介绍 - 支付宝文档中心</a>,手机网站支付是指商家在移动端网页展示商品或服务，用户在商家页面确认使用支付宝支付后，浏览器自动跳转支付宝 App 或支付宝网页完成付款的支付产品。该产品在签约完成后，需要技术集成方可使用。代码和电脑网站支付差不多。</p><p>建议手机网站支付转Native支付，也就是唤起支付宝APP支付，而不是在H5页面进行支付。<a href="https://opendocs.alipay.com/open-v3/05w4kw?pathHash=386b48c6">手机网站支付转Native支付（推荐） - 支付宝文档中心</a></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/179989/1668414529588-da8c06d7-41da-49b2-a967-00d05d01ff33.png" alt="p2"></p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><p>手机网站支付与手机网站转 Native 支付的主要区别为：</p><ul><li>如果用户手机安装了支付宝客户端，手机网站转 Native 支付方式将跳转到支付宝客户端中进行订单支付，用户体验和支付成功率均优于手机网站支付方式。除此之外，还能使用手机网站支付没有提供的指纹支付、手环支付、手表支付、免密支付等功能。 </li><li>如果用户手机没有安装支付宝客户端，将在 SDK 提供的 Web-view 中打开 H5 页面进行支付。即便如此，由于 SDK 与服务端的交互携带账号信息，仍比不携带任何账号信息的普通手机网站支付体验更好。</li></ul><h4 id="如何实现手机网站转Native支付"><a href="#如何实现手机网站转Native支付" class="headerlink" title="如何实现手机网站转Native支付"></a>如何实现手机网站转Native支付</h4><p>要实现上述功能需接入支付宝提供的 SDK。接入过程十分简单，可以以上述 Demo 为参考，该 Demo 程序只有一个功能：创建一个 Web-view，在 Web-view 中拦截每个 URL，然后调用 SDK 提供的接口检查该 URL 是否是有效的支付宝订单支付 URL，如果是则将该 URL 传给 SDK 提供的支付接口进行支付。</p><h3 id="3-5-退款接口"><a href="#3-5-退款接口" class="headerlink" title="3.5 退款接口"></a>3.5 退款接口</h3><p>退款接口没啥好说的，主要是区分部分退款和全额退款交易状态的不同，参数传递的些许差异。<a href="https://opendocs.alipay.com/open-v3/da960891_alipay.trade.refund?scene=common&amp;pathHash=f692c2c5">统一收单交易退款接口 - 支付宝文档中心</a>。先上代码：</p><pre><code class="java">@GetMapping ("/refundPay")public String refundPay(String orderNo,String amount) throws ApiException {    ApiClient defaultClient = Configuration.getDefaultApiClient();    // 初始化alipay参数（全局设置一次）    defaultClient.setAlipayConfig(getAlipayConfig());    // 构造请求参数以调用接口    AlipayTradeApi api = new AlipayTradeApi();    AlipayTradeRefundModel data = new AlipayTradeRefundModel();    // 部分退款时,outRequestNo必传,同一笔交易多次退款需要保证唯一    data.outRequestNo(String.valueOf(System.currentTimeMillis()));    data.setOutTradeNo(orderNo);    data.setRefundAmount(amount);    data.setRefundReason("测试退款");    // 第三方代调用模式下请设置app_auth_token    CustomizedParams params = new CustomizedParams();    params.setAppAuthToken("&lt;-- 请填写应用授权令牌 --&gt;");    try {        AlipayTradeRefundResponseModel response = api.refund(data);        //{"buyer_logon_id":"rpv***@sandbox.com","buyer_user_id":"2088722013720112","fund_change":"Y","gmt_refund_pay":"2024-12-19 14:16:39","out_trade_no":"1734423455786","refund_fee":"15.88","send_back_fee":"0.00","trade_no":"2024121722001420110504891744"}        System.out.println("调用成功:" + JSON.serialize(response));        return JSON.serialize(response);    } catch (ApiException e) {        AlipayTradeRefundDefaultResponse errorObject = (AlipayTradeRefundDefaultResponse) e.getErrorObject();        System.out.println("调用失败:" + errorObject);    }    return "";}</code></pre><p>首先全额退款时，<strong>trade_no(支付宝交易号)<strong>和</strong>out_trade_no(商户订单号)<strong>二选一传入,<strong>refund_amount</strong>是必传的，退款成功后，交易状态变为：</strong>TRADE_CLOSED</strong>；</p><p>部分退款时，参数在全额基础上，加了<strong>out_request_no</strong>退款请求号,必传。 标识一次退款请求，需要保证在交易号下唯一，如需部分退款，则此参数必传。 注：针对同一次退款请求，如果调用接口失败或异常了，重试时需要保证退款请求号不能变更，防止该笔交易重复退款。支付宝会保证同样的退款请求号多次请求只会退一次。部分退款成功后，交易状态仍为 <strong>TRADE_SUCCESS</strong>。</p><p>APP、手机网站支付退款成功会触发异步通知，就是在调用pay接口时传入的notify_url，电脑网站只有部分退款时有通知（交易状态<strong>TRADE_SUCCESS</strong>）。但是不同的交易状态触发机制不同，后面会详说。退款是否成功建议还是调用<a href="https://opendocs.alipay.com/open-v3/b95db51d_alipay.trade.fastpay.refund.query?scene=common&amp;pathHash=013d131b">统一收单交易退款查询接口 - 支付宝文档中心</a>来确认，异步通知虽然也可以，但是判断条件有点复杂，而且会和支付成功时的通知业务耦合在一起，还要判断是全额退款和部分退款，所以，异步通知接口只用来接收支付成功的消息比较好，退款可以根据退款接口返回的字段<strong>fund_change=Y</strong>判断，再结合退款查询接口。</p><h4 id="退款说明"><a href="#退款说明" class="headerlink" title="退款说明"></a>退款说明</h4><ul><li><strong>退款周期：</strong>12 个月，即交易发生后 12 个月内可发起退款，超过 12 个月则不可发起退款。</li><li><strong>退款方式：</strong>资金原路返回用户账号。</li><li><strong>退款退费：</strong>退款时手续费不退回。</li><li>一笔退款失败后重新提交，要采用原来的退款单号。</li><li>总退款金额不能超过用户实际支付金额。</li><li>退款信息以退款接口同步返回或者 <a href="https://opendocs.alipay.com/open-v3/0e5a7x">alipay.trade.fastpay.refund.query</a>（统一收单交易退款查询接口）为准。</li></ul><p>退款存在退到银行卡场景下时，开发者需要先订阅 <a href="https://opendocs.alipay.com/open-v3/05w4la?pathHash=da33cafe&amp;scene=common">alipay.trade.refund.depositback.completed</a>（收单退款冲退完成通知）如果是使用 <a href="https://opendocs.alipay.com/open-v3/064zh9?pathHash=a9c7a1f2">From 蚂蚁消息服务</a> 需要先设置好应用网关地址，支付宝会根据银行回执消息发送退款完成信息至应用网关地址。具体消息订阅步骤可查看 <a href="https://opendocs.alipay.com/open-v3/064zh9?pathHash=a9c7a1f2#%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF">订阅消息</a>。</p><h3 id="3-6-订单查询接口"><a href="#3-6-订单查询接口" class="headerlink" title="3.6 订单查询接口"></a>3.6 订单查询接口</h3><p><a href="https://opendocs.alipay.com/open-v3/cd439c70_alipay.trade.query?scene=23&amp;pathHash=525a8e13">统一收单交易查询接口 - 支付宝文档中心</a>,直接查就可以了。</p><h3 id="3-7-交易关闭接口"><a href="#3-7-交易关闭接口" class="headerlink" title="3.7 交易关闭接口"></a>3.7 交易关闭接口</h3><p>通常交易关闭是通过 alipay.trade.page.pay 中的超时时间来控制，支付宝也提供给商家 <a href="https://opendocs.alipay.com/open-v3/0e5a80">alipay.trade.close</a>（统一收单交易关闭接口）。若用户一直未支付，商家可以调用该接口关闭指定交易；成功关闭交易后该交易不可支付。</p><h3 id="3-8-异步通知接口"><a href="#3-8-异步通知接口" class="headerlink" title="3.8 异步通知接口"></a>3.8 异步通知接口</h3><p>支付成功和退款成功都会触发异步通知，建议只处理支付成功的通知，这样的话电脑网站支付和app支付可以用同一个notify_url，同一个接口，如果处理退款的通知，电脑网站支付和app支付触发条件不一样，判断条件也不一样，会有一些复杂的场景，比如：部分退款时，最后一笔退款会改变交易状态为TRADE_CLOSED，而没有退完时，状态仍是TRADE_SUCCESS，需要各种条件判断，所以退款还是调用退款查询接口比较好，建议在退款后10s后调用，可以用MQ延时消息处理。</p><p>我写了两个异步通知方法，简单判断了通知类型，但是肯定没有包含所有情况。代码如下：</p><pre><code class="java">@PostMapping("/pcNotify")public String notifyPay(HttpServletRequest request) throws ApiException {    System.out.println("电脑网站收到异步通知=====支付宝回调");    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();    Map&lt;String, String[]&gt; requestParams = request.getParameterMap();    for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = iter.next();        String[] values = requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        params.put(name, valueStr);    }    //{"gmt_create":"2024-12-19 14:04:16","charset":"UTF-8","gmt_payment":"2024-12-19 14:04:31","notify_time":"2024-12-19 14:04:33","subject":"测试电脑网站支付","sign":"XAzGwc/dZ6ON1TwXvw92GnhF7X4PTZNJ6h6TfH/5T0sgfTtIRVgnny150B7Ip1xHgjpuNoz+T8XlMpMNgvkpxNlcWmlbDfs72Ls/OyyV7ttEKgRos4VWKIrojJ1Apy06H9kie6cCfmBC3mmW9Gh+QAh5oejdZDSq+NDgJIjBlz8S6x85GEQ0BprcVHDfPKubaOWl5nCri7YKxTPOLZcqwTgV9mWXzoIa9hSp32bqyTiLtDlM1h5Z7IJKuj9/EhKuOAz6PF/vws/lftp9gzG3bJVkwwP4z50neyJNWzENIHIKQoGDInZF+T2yNyJJ0YPg/x8LejPzyfdkHjM9bZjBEA\u003d\u003d","buyer_id":"2088722013720112","invoice_amount":"6.88","version":"1.0","notify_id":"2024121901222140432120110505059148","fund_bill_list":"[{\"amount\":\"6.88\",\"fundChannel\":\"ALIPAYACCOUNT\"}]","notify_type":"trade_status_sync","out_trade_no":"1734588234593","total_amount":"6.88","trade_status":"TRADE_SUCCESS","trade_no":"2024121922001420110504898164","auth_app_id":"9021000128652691","receipt_amount":"6.88","point_amount":"0.00","buyer_pay_amount":"6.88","app_id":"9021000128652691","sign_type":"RSA2","seller_id":"2088721013742803"}    System.out.println(JSON.serialize(params));    // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）    boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");    if (verified) {        //todo 参数验证，out_trade_no，total_amount等        //1. 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。        //2. 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）。        //3. 校验通知中的 seller_id（或者 seller_email ) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个seller_id/seller_email）。        //4. 验证 app_id 是否为该商家本身。        System.out.println("支付异步验签成功");        String tradeStatus = params.get("trade_status");        //总退款金额        String refundFee = params.get("refund_fee");        //交易退款时间        String gmtRefund = params.get("gmt_refund");        if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){            //只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功。            if ("TRADE_SUCCESS".equals(tradeStatus) || "TRADE_FINISHED".equals(tradeStatus)) {                System.out.println("支付成功异步通知");            }        }else {            System.out.println("退款异步通知");            String gmtClose = params.get("gmt_close");            if ("TRADE_SUCCESS".equals(tradeStatus)) {                //最后一次部分退款没有通知，因为状态已经变成TRADE_CLOSED                System.out.println("部分退款异步通知");            }            //电脑网站支付应该不会有全额退款通知，因为TRADE_CLOSED不会触发异步通知            if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                System.out.println("全额退款异步通知");            }        }        return "success";    }else {        System.out.println("验签失败，支付失败");        return "failure";    }}@PostMapping("/appNotify")public String notifyAppPay(HttpServletRequest request) throws ApiException {    System.out.println("app收到异步通知=====支付宝回调");    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();    Map&lt;String, String[]&gt; requestParams = request.getParameterMap();    for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = iter.next();        String[] values = requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        params.put(name, valueStr);    }    System.out.println(JSON.serialize(params));    // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）    boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");    if (verified) {        System.out.println("支付异步验签成功");        String tradeStatus = params.get("trade_status");        //总退款金额        String refundFee = params.get("refund_fee");        //交易退款时间        String gmtRefund = params.get("gmt_refund");        if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("支付成功异步通知");            }            if ("TRADE_CLOSED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }            if ("TRADE_FINISHED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }        }else {            System.out.println("退款异步通知");            String gmtClose = params.get("gmt_close");            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("部分退款异步通知");            }            //全额退款，或者最后一次部分退款            if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                System.out.println("全额退款异步通知");            }        }        return "success";    }else {        System.out.println("支付异步验签失败，支付失败");        return "failure";    }}</code></pre><h3 id="3-9-一些要注意的信息"><a href="#3-9-一些要注意的信息" class="headerlink" title="3.9 一些要注意的信息"></a>3.9 一些要注意的信息</h3><h4 id="交易状态流程"><a href="#交易状态流程" class="headerlink" title="交易状态流程"></a>交易状态流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/179989/1662454282907-29e733cb-88ce-443a-b045-47ffef16ab67.png" alt="p3"></p><p>随着订单支付成功、退款、关闭等操作，订单交易的每一个环节 trade_status（交易状态）也不同。</p><ol><li>交易创建成功后，用户支付成功，交易状态转为 <strong>TRADE_SUCCESS（交易成功）</strong>。</li><li>交易成功后，规定退款时间内没有退款，交易状态转为 <strong>TRADE_FINISHED（交易完成）</strong>。</li><li>交易支付成功后，交易部分退款，交易状态仍为 <strong>TRADE_SUCCESS（交易成功）</strong>。</li><li>交易成功后，交易全额退款，交易状态转为 <strong>TRADE_CLOSED（交易关闭）</strong>。</li><li>交易创建成功后，用户未付款交易超时关闭，交易状态转为 <strong>TRADE_CLOSED（交易关闭）</strong>。</li><li>交易创建成功后，用户支付成功后，若用户商品不支持退款，交易状态直接转为 <strong>TRADE_FINISHED（交易完成）</strong>。</li></ol><p><strong>注意</strong>：交易成功后部分退款，交易状态仍为 TRADE_SUCCESS（交易成功）。</p><p>如果一直部分退款退完所有交易金额则交易状态转为 TRADE_CLOSED（交易关闭）。</p><p>如果未退完所有交易金额，超过有效退款时间后交易状态转为 TRADE_FINISHED（交易完成）不可退款。</p><h4 id="异步通知："><a href="#异步通知：" class="headerlink" title="异步通知："></a>异步通知：</h4><p>先上代码：</p><pre><code class="java">@PostMapping("/appNotify")public String notifyAppPay(HttpServletRequest request) throws ApiException {    System.out.println("app收到异步通知=====支付宝回调");    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();    Map&lt;String, String[]&gt; requestParams = request.getParameterMap();    for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = iter.next();        String[] values = requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        params.put(name, valueStr);    }    System.out.println(JSON.serialize(params));    // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）    boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");    if (verified) {        System.out.println("支付异步验签成功");        String tradeStatus = params.get("trade_status");        //总退款金额        String refundFee = params.get("refund_fee");        //交易退款时间        String gmtRefund = params.get("gmt_refund");        if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("支付成功异步通知");            }            if ("TRADE_CLOSED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }            if ("TRADE_FINISHED".equals(tradeStatus)) {                System.out.println("交易关闭异步通知");            }        }else {            System.out.println("退款异步通知");            String gmtClose = params.get("gmt_close");            if ("TRADE_SUCCESS".equals(tradeStatus)) {                System.out.println("部分退款异步通知");            }            //全额退款，或者最后一次部分退款            if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                System.out.println("全额退款异步通知");            }        }        return "success";    }else {        System.out.println("支付异步验签失败，支付失败");        return "failure";    }}</code></pre><p>交易退款接口触发异步通知:<a href="https://opendocs.alipay.com/open-v3/05w4kp?pathHash=f3e513ea">产品介绍 - 支付宝文档中心</a>，前面已经说了，退款不建议在异步通知中处理，可以调用退款查询接口来判断，</p><p><a href="https://opendocs.alipay.com/support/01rawa">如何判断退款是否成功 - 支付宝文档中心</a>。</p><p>这里的交易退款接口是指统一收单交易退款接口（<a href="https://docs.open.alipay.com/api_1/alipay.trade.refund">alipay.trade.refund</a>），统一收单交易退款接口本身接口不支持设置 notify_url 参数，因此退款导致触发的异步通知是发送到支付接口中设置的 notify_url。</p><p>历史版本的退款接口 refund_fastpay_by_platform_pwd（即时到账有密退款接口）不同于新版本的统一收单交易退款接口（alipay.trade.refund）。历史版本的退款接口本身支持设置 notify_url，但由于历史接口目前不支持签约，无法使用等情况，本文只阐述新版本的统一收单交易退款接口（alipay.trade.refund）是否会触发异步通知。</p><p>以下是交易状态说明：</p><p><img src="https://gw.alipayobjects.com/zos/workflow/workflow/202002261582698731390_3381f68343d8db05198d25bbf1eb6049.png" alt="img"></p><h4 id="触发异步通知条件"><a href="#触发异步通知条件" class="headerlink" title="触发异步通知条件"></a>触发异步通知条件</h4><p>异步通知是根据交易状态的改变进行触发的，不同的支付产品触发异步通知的条件不同。</p><table><thead><tr><th>产品</th><th>触发异步通知条件</th></tr></thead><tbody><tr><td>当面付</td><td>当面付的支付接口，详见 <a href="https://docs.open.alipay.com/194/103296/#s1">当面付异步通知-仅用于扫码支付</a>默认 TRADE_SUCCESS（交易成功）触发。TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）、WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr><tr><td>App 支付</td><td>App 支付接口，详见 <a href="https://docs.open.alipay.com/204/105301/#s2">App 支付异步通知触发条件</a>默认 TRADE_SUCCESS（交易成功）、TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）三种状态均会触发异步通知。WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr><tr><td>手机网站支付</td><td>手机网站支付接口，详见<a href="https://docs.open.alipay.com/203/105286/#s2">手机网站支付结果异步通知触发条件</a>默认 TRADE_SUCCESS（交易成功）、TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）三种状态均会触发异步通知。WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr><tr><td>电脑网站支付</td><td>电脑网站支付接口，详见<a href="https://docs.open.alipay.com/270/105902/#s2">电脑网站支付异步通知触发条件</a>默认 TRADE_SUCCESS（交易成功）状态触发异步通知。TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）、WAIT_BUYER_PAY（交易创建）不触发异步通知。</td></tr></tbody></table><h4 id="退款是否会收到异步"><a href="#退款是否会收到异步" class="headerlink" title="退款是否会收到异步"></a>退款是否会收到异步</h4><p>根据退款的行为可分为全额退款和部分退款。</p><ul><li>全额退款，交易状态变为 TRADE_CLOSED（交易关闭）。只有 App 支付和手机网站支付交易状态变为 TRADE_CLOSED（交易关闭）会触发异步通知。</li><li>部分退款，交易状态仍为 TRADE_SUCCESS（交易成功）。当面付、电脑网站支付、App 支付和手机网站支付交易状态为 TRADE_SUCCESS（交易成功）都会触发异步通知。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于不同操作导致不同的交易状态，异步通知对交易状态的常见问题如下。</p><ul><li><a href="https://opendocs.alipay.com/support/01rawd">异步通知如何区分全额退款和部分退款</a></li><li><a href="https://opendocs.alipay.com/support/01rawe">异步通知如何区分全额退款和订单超时导致的交易关闭</a></li><li><a href="https://opendocs.alipay.com/support/01rawf">异步通知如何判断对应哪笔退款交易</a></li></ul><h4 id="关于异步通知的验签"><a href="#关于异步通知的验签" class="headerlink" title="关于异步通知的验签"></a>关于异步通知的验签</h4><p>收到异步通知后需要先验签，V3的SDK提供的验签方法与V2相比，换了方法。</p><pre><code class="java">// SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）  boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");</code></pre><p>当然也可以自定义方法验签。</p><h3 id="4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。"><a href="#4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。" class="headerlink" title="4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。"></a>4、完整代码：只是测试代码，接口都是get请求，正式接入还需完善。</h3><pre><code class="java">package com.zqg.pay.alipay.web;import com.alipay.v3.ApiClient;import com.alipay.v3.ApiException;import com.alipay.v3.Configuration;import com.alipay.v3.JSON;import com.alipay.v3.api.AlipayTradeApi;import com.alipay.v3.api.AlipayTradeFastpayRefundApi;import com.alipay.v3.model.*;import com.alipay.v3.util.AlipaySignature;import com.alipay.v3.util.GenericExecuteApi;import com.alipay.v3.util.model.AlipayConfig;import com.alipay.v3.util.model.CustomizedParams;import org.apache.commons.lang3.StringUtils;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.*;@RestController@RequestMapping("/pay")public class PayController {    /**     * https://opendocs.alipay.com/open-v3/2423fad5_alipay.trade.page.pay?scene=22&amp;pathHash=b20c762a     *     * @param response     * @return String     * @throws ApiException     * @throws IOException     */    @GetMapping(value = "/payOrder",produces = "text/html;charset=UTF-8")    public String pay(HttpServletResponse response) throws ApiException, IOException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        GenericExecuteApi api = new GenericExecuteApi();        // 构造请求参数以调用接口        Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;();        // 设置商户订单号        bizContent.put("out_trade_no", String.valueOf(System.currentTimeMillis()));        // 设置订单总金额        bizContent.put("total_amount", "6.88");        // 设置订单标题        bizContent.put("subject", "测试电脑网站支付");        // 设置产品码        bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");        // 设置订单附加信息       // bizContent.put("body", "http://localhost:8080/hello");        // 设置PC扫码支付的方式        bizContent.put("qr_pay_mode", "2");        // 设置商户自定义二维码宽度        //bizContent.put("qrcode_width", 100);        // 设置订单包含的商品列表信息        List&lt;Map&lt;String, Object&gt;&gt; goodsDetail = new ArrayList&lt;&gt;();        Map&lt;String, Object&gt; goodsDetail0 = new HashMap&lt;&gt;();        goodsDetail0.put("out_sku_id", "outSku_01");        goodsDetail0.put("goods_name", "ipad");        goodsDetail0.put("alipay_goods_id", "20010001");        goodsDetail0.put("quantity", 1);        goodsDetail0.put("price", 2000);        goodsDetail0.put("out_item_id", "outItem_01");        goodsDetail0.put("goods_id", "apple-01");        goodsDetail0.put("goods_category", "34543238");        goodsDetail0.put("categories_tree", "124868003|126232002|126252004");        goodsDetail0.put("show_url", "http://www.alipay.com/xxx.jpg");        goodsDetail.add(goodsDetail0);        //bizContent.put("goods_detail", goodsDetail);        // 设置订单绝对超时时间      //  bizContent.put("time_expire", "2024-12-31 10:05:01");        // 设置建议使用time_expire字段      //  bizContent.put("timeout_express", "90m");        // 设置描述分账信息        Map&lt;String, Object&gt; royaltyInfo = new HashMap&lt;&gt;();        royaltyInfo.put("royalty_type", "ROYALTY");        List&lt;Map&lt;String, Object&gt;&gt; royaltyDetailInfos = new ArrayList&lt;&gt;();        Map&lt;String, Object&gt; royaltyDetailInfos0 = new HashMap&lt;&gt;();        royaltyDetailInfos0.put("out_relation_id", "20131124001");        royaltyDetailInfos0.put("amount_percentage", "100");        royaltyDetailInfos0.put("amount", "0.1");        royaltyDetailInfos0.put("batch_no", "123");        royaltyDetailInfos0.put("trans_in", "2088101126708402");        royaltyDetailInfos0.put("trans_out_type", "userId");        royaltyDetailInfos0.put("trans_out", "2088101126765726");        royaltyDetailInfos0.put("serial_no", 1);        royaltyDetailInfos0.put("trans_in_type", "userId");        royaltyDetailInfos0.put("desc", "分账测试1");        royaltyDetailInfos.add(royaltyDetailInfos0);        royaltyInfo.put("royalty_detail_infos", royaltyDetailInfos);       // bizContent.put("royalty_info", royaltyInfo);        // 设置二级商户信息        Map&lt;String, Object&gt; subMerchantvxgvh = new HashMap&lt;&gt;();        subMerchantvxgvh.put("merchant_id", "2088000603999128");        subMerchantvxgvh.put("merchant_type", "alipay");        //bizContent.put("sub_merchant", subMerchantvxgvh);        // 设置描述结算信息        Map&lt;String, Object&gt; settleInfo = new HashMap&lt;&gt;();        settleInfo.put("settle_period_time", "7d");        List&lt;Map&lt;String, Object&gt;&gt; settleDetailInfos = new ArrayList&lt;&gt;();        Map&lt;String, Object&gt; settleDetailInfos0 = new HashMap&lt;&gt;();        settleDetailInfos0.put("amount", "0.1");        settleDetailInfos0.put("trans_in", "A0001");        settleDetailInfos0.put("settle_entity_type", "SecondMerchant");        settleDetailInfos0.put("summary_dimension", "A0001");        settleDetailInfos0.put("actual_amount", "0.1");        settleDetailInfos0.put("settle_entity_id", "2088xxxxx;ST_0001");        settleDetailInfos0.put("trans_in_type", "cardAliasNo");        settleDetailInfos.add(settleDetailInfos0);        settleInfo.put("settle_detail_infos", settleDetailInfos);       // bizContent.put("settle_info", settleInfo);        // 设置业务扩展参数        Map&lt;String, Object&gt; extendParams = new HashMap&lt;&gt;();        extendParams.put("sys_service_provider_id", "2088511833207846");        extendParams.put("hb_fq_seller_percent", "100");        extendParams.put("hb_fq_num", "3");        extendParams.put("tc_installment_order_id", "2015042321001004720200028594");        extendParams.put("industry_reflux_info", "{\"scene_code\":\"metro_tradeorder\",\"channel\":\"xxxx\",\"scene_data\":{\"asset_name\":\"ALIPAY\"}}");        extendParams.put("specified_seller_name", "XXX的跨境小铺");        extendParams.put("royalty_freeze", "true");        extendParams.put("card_type", "S0JP0000");        extendParams.put("credit_ext_info", "{\"category\":\"CHARGE_PILE_CAR\",\"serviceId\":\"2020042800000000000001450466\"}");        extendParams.put("trade_component_order_id", "2023060801502300000008810000005657");       // bizContent.put("extend_params", extendParams);        // 设置商户传入业务信息       // bizContent.put("business_params", "{\"mc_create_trade_ip\":\"127.0.0.1\"}");        // 设置优惠参数      //  bizContent.put("promo_params", "{\"storeIdType\":\"1\"}");        // 设置请求后页面的集成方式      //  bizContent.put("integration_type", "PCWEB");        // 设置请求来源地址       // bizContent.put("request_from_url", "https://");        // 设置签约参数        Map&lt;String, Object&gt; agreementSignParams = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; subMerchantRWfdn = new HashMap&lt;&gt;();        subMerchantRWfdn.put("sub_merchant_name", "滴滴出行");        subMerchantRWfdn.put("sub_merchant_service_name", "滴滴出行免密支付");        subMerchantRWfdn.put("sub_merchant_service_description", "免密付车费，单次最高500");        subMerchantRWfdn.put("sub_merchant_id", "2088123412341234");        agreementSignParams.put("sub_merchant", subMerchantRWfdn);        agreementSignParams.put("buckle_app_id", "1001164");        agreementSignParams.put("sign_validity_period", "2m");        agreementSignParams.put("buckle_merchant_id", "268820000000414397785");        agreementSignParams.put("external_logon_id", "138****8888");        agreementSignParams.put("third_party_type", "PARTNER");        agreementSignParams.put("personal_product_code", "GENERAL_WITHHOLDING_P");        agreementSignParams.put("external_agreement_no", "test");        agreementSignParams.put("promo_params", "{\"key\",\"value\"}");        agreementSignParams.put("sign_scene", "INDUSTRY|CARRENTAL");      //  bizContent.put("agreement_sign_params", agreementSignParams);        // 设置商户门店编号      //  bizContent.put("store_id", "NJ_001");        // 设置指定支付渠道       // bizContent.put("enable_pay_channels", "pcredit,moneyFund,debitCardExpress");        // 设置禁用渠道      //  bizContent.put("disable_pay_channels", "pcredit,moneyFund,debitCardExpress");        // 设置商户的原始订单号      //  bizContent.put("merchant_order_no", "20161008001");        // 设置外部指定买家        Map&lt;String, Object&gt; extUserInfo = new HashMap&lt;&gt;();        extUserInfo.put("cert_type", "IDENTITY_CARD");        extUserInfo.put("cert_no", "362334768769238881");        extUserInfo.put("name", "李明");        extUserInfo.put("mobile", "16587658765");        extUserInfo.put("min_age", "18");        extUserInfo.put("need_check_info", "F");        extUserInfo.put("identity_hash", "27bfcd1dee4f22c8fe8a2374af9b660419d1361b1c207e9b41a754a113f38fcc");       // bizContent.put("ext_user_info", extUserInfo);        // 设置开票信息        Map&lt;String, Object&gt; invoiceInfo = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; keyInfo = new HashMap&lt;&gt;();        keyInfo.put("tax_num", "1464888883494");        keyInfo.put("is_support_invoice", true);        keyInfo.put("invoice_merchant_name", "ABC|003");        invoiceInfo.put("key_info", keyInfo);        invoiceInfo.put("details", "[{\"code\":\"100294400\",\"name\":\"服饰\",\"num\":\"2\",\"sumPrice\":\"200.00\",\"taxRate\":\"6%\"}]");       // bizContent.put("invoice_info", invoiceInfo);        // 设置返回参数选项        List&lt;String&gt; queryOptions = new ArrayList&lt;&gt;();        queryOptions.add("hyb_amount");        queryOptions.add("enterprise_pay_info");       // bizContent.put("query_options", queryOptions);        bizParams.put("biz_content", bizContent);        //return_url 必须是 http 或 https 开头的完整的 url 地址。        //return_url 地址后不可带自定义参数。        //设置 return_url 时不要进行转义、urlencode 等数据处理。        //当面付和APP支付不支持 return_url 参数，即使设置了也没有任何效果。        //同步通知参数只可参考，不能作为判断是否支付成功的依据。        bizParams.put("return_url", "https://docs.open.alipay.com");        bizParams.put("notify_url", "http://lql5520.yunmv.cn/pay/pcNotify");        try {            //rpvexb4275@sandbox.com            System.out.println(JSON.serialize(bizParams));            System.out.println("==============================");            // 如果是第三方代调用模式，请设置app_auth_token（应用授权令牌）            String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "POST", bizParams);            // 如果需要返回GET请求，请使用            // String pageRedirectionData = api.pageExecute("alipay.trade.page.pay", "GET", bizParams);            System.out.println(pageRedirectionData);            return pageRedirectionData;         /*  //produces = "text/html"            response.setContentType("text/html;charset=UTF-8");            PrintWriter out = response.getWriter();            out.write(pageRedirectionData);            out.flush();            out.close();            */        } catch (ApiException e) {            System.out.println("调用失败");        }        return "";    }    /**     * https://opendocs.alipay.com/support/01rawc?pathHash=4ad70fe3     * App 支付   App 支付接口，详见 App 支付异步通知触发条件     * 默认 TRADE_SUCCESS（交易成功）、TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）三种状态均会触发异步通知。     * WAIT_BUYER_PAY（交易创建）不触发异步通知。     *     * 电脑网站支付   电脑网站支付接口，详见电脑网站支付异步通知触发条件     * 默认 TRADE_SUCCESS（交易成功）状态触发异步通知。     * TRADE_CLOSED（交易关闭）、TRADE_FINISHED（交易完成）、WAIT_BUYER_PAY（交易创建）不触发异步通知。     *     * 退款是否会收到异步     * 根据退款的行为可分为全额退款和部分退款。     * ● 全额退款，交易状态变为 TRADE_CLOSED（交易关闭）。只有 App 支付和手机网站支付交易状态变为 TRADE_CLOSED（交易关闭）会触发异步通知。     * ● 部分退款，交易状态仍为 TRADE_SUCCESS（交易成功）。当面付、电脑网站支付、App 支付和手机网站支付交易状态为 TRADE_SUCCESS（交易成功）都会触发异步通知。     * 如何区分部分退款和全额退款： https://opendocs.alipay.com/support/01rawd     *     * 25 小时以内完成 8 次通知（通知的间隔频率一般是 4m，10m，10m，1h，2h，6h，15h）     * @param request     * @return     * @throws ApiException     */    @PostMapping("/pcNotify")    public String notifyPay(HttpServletRequest request) throws ApiException {        System.out.println("电脑网站收到异步通知=====支付宝回调");        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        Map&lt;String, String[]&gt; requestParams = request.getParameterMap();        for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {            String name = iter.next();            String[] values = requestParams.get(name);            String valueStr = "";            for (int i = 0; i &lt; values.length; i++) {                valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";            }            params.put(name, valueStr);        }        //{"gmt_create":"2024-12-19 14:04:16","charset":"UTF-8","gmt_payment":"2024-12-19 14:04:31","notify_time":"2024-12-19 14:04:33","subject":"测试电脑网站支付","sign":"XAzGwc/dZ6ON1TwXvw92GnhF7X4PTZNJ6h6TfH/5T0sgfTtIRVgnny150B7Ip1xHgjpuNoz+T8XlMpMNgvkpxNlcWmlbDfs72Ls/OyyV7ttEKgRos4VWKIrojJ1Apy06H9kie6cCfmBC3mmW9Gh+QAh5oejdZDSq+NDgJIjBlz8S6x85GEQ0BprcVHDfPKubaOWl5nCri7YKxTPOLZcqwTgV9mWXzoIa9hSp32bqyTiLtDlM1h5Z7IJKuj9/EhKuOAz6PF/vws/lftp9gzG3bJVkwwP4z50neyJNWzENIHIKQoGDInZF+T2yNyJJ0YPg/x8LejPzyfdkHjM9bZjBEA\u003d\u003d","buyer_id":"2088722013720112","invoice_amount":"6.88","version":"1.0","notify_id":"2024121901222140432120110505059148","fund_bill_list":"[{\"amount\":\"6.88\",\"fundChannel\":\"ALIPAYACCOUNT\"}]","notify_type":"trade_status_sync","out_trade_no":"1734588234593","total_amount":"6.88","trade_status":"TRADE_SUCCESS","trade_no":"2024121922001420110504898164","auth_app_id":"9021000128652691","receipt_amount":"6.88","point_amount":"0.00","buyer_pay_amount":"6.88","app_id":"9021000128652691","sign_type":"RSA2","seller_id":"2088721013742803"}        System.out.println(JSON.serialize(params));        // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）        boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");        if (verified) {            //todo 参数验证，out_trade_no，total_amount等            //1. 商家需要验证该通知数据中的 out_trade_no 是否为商家系统中创建的订单号。            //2. 判断 total_amount 是否确实为该订单的实际金额（即商家订单创建时的金额）。            //3. 校验通知中的 seller_id（或者 seller_email ) 是否为 out_trade_no 这笔单据的对应的操作方（有的时候，一个商家可能有多个seller_id/seller_email）。            //4. 验证 app_id 是否为该商家本身。            System.out.println("支付异步验签成功");            String tradeStatus = params.get("trade_status");            //总退款金额            String refundFee = params.get("refund_fee");            //交易退款时间            String gmtRefund = params.get("gmt_refund");            if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){                //只有交易通知状态为 TRADE_SUCCESS 或 TRADE_FINISHED 时，支付宝才会认定为买家付款成功。                if ("TRADE_SUCCESS".equals(tradeStatus) || "TRADE_FINISHED".equals(tradeStatus)) {                    System.out.println("支付成功异步通知");                }            }else {                System.out.println("退款异步通知");                String gmtClose = params.get("gmt_close");                if ("TRADE_SUCCESS".equals(tradeStatus)) {                    //最后一次部分退款没有通知，因为状态已经变成TRADE_CLOSED                    System.out.println("部分退款异步通知");                }                //电脑网站支付应该不会有全额退款通知，因为TRADE_CLOSED不会触发异步通知                if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                    System.out.println("全额退款异步通知");                }            }            return "success";        }else {            System.out.println("验签失败，支付失败");            return "failure";        }    }    @PostMapping("/appNotify")    public String notifyAppPay(HttpServletRequest request) throws ApiException {        System.out.println("app收到异步通知=====支付宝回调");        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();        Map&lt;String, String[]&gt; requestParams = request.getParameterMap();        for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext(); ) {            String name = iter.next();            String[] values = requestParams.get(name);            String valueStr = "";            for (int i = 0; i &lt; values.length; i++) {                valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";            }            params.put(name, valueStr);        }        System.out.println(JSON.serialize(params));        // SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）        boolean verified = AlipaySignature.verifyV1(params, getAlipayConfig().getAlipayPublicKey(), "UTF-8", "RSA2");        if (verified) {            System.out.println("支付异步验签成功");            String tradeStatus = params.get("trade_status");            //总退款金额            String refundFee = params.get("refund_fee");            //交易退款时间            String gmtRefund = params.get("gmt_refund");            if (StringUtils.isEmpty(refundFee) &amp;&amp; StringUtils.isEmpty(gmtRefund)){                if ("TRADE_SUCCESS".equals(tradeStatus)) {                    System.out.println("支付成功异步通知");                }                if ("TRADE_CLOSED".equals(tradeStatus)) {                    System.out.println("交易关闭异步通知");                }                if ("TRADE_FINISHED".equals(tradeStatus)) {                    System.out.println("交易关闭异步通知");                }            }else {                System.out.println("退款异步通知");                String gmtClose = params.get("gmt_close");                if ("TRADE_SUCCESS".equals(tradeStatus)) {                    System.out.println("部分退款异步通知");                }                //全额退款，或者最后一次部分退款                if ("TRADE_CLOSED".equals(tradeStatus) &amp;&amp; StringUtils.isNotEmpty(gmtClose)){                    System.out.println("全额退款异步通知");                }            }            return "success";        }else {            System.out.println("支付异步验签失败，支付失败");            return "failure";        }    }    @GetMapping("/queryOrder")    public String queryPage(String orderNo) throws ApiException {        //1733990822574        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeQueryModel data = new AlipayTradeQueryModel();        // 设置订单支付时传入的商户订单号        data.setOutTradeNo(orderNo);        try {            AlipayTradeQueryResponseModel response = api.query(data);            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeQueryDefaultResponse errorObject = (AlipayTradeQueryDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    @GetMapping(value = "/payAppOrder")    public String payOrderApp() throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        GenericExecuteApi api = new GenericExecuteApi();        // 构造请求参数以调用接口        Map&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;();        Map&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;();        // 设置商户订单号        bizContent.put("out_trade_no", "70501111111S001111119");        // 设置订单总金额        bizContent.put("total_amount", "9.00");        // 设置订单标题        bizContent.put("subject", "大乐透");        // 设置产品码        bizContent.put("product_code", "QUICK_MSECURITY_PAY");        // 设置订单附加信息        bizContent.put("body", "Iphone6 16G");        // 设置订单绝对超时时间        bizContent.put("time_expire", "2024-12-31 10:05:00");        // 设置建议使用time_expire字段        bizContent.put("timeout_express", "90m");        bizParams.put("biz_content", bizContent);        // 同步回调指定的页面 app不需要       // bizParams.put("return_url", "https://docs.open.alipay.com");        bizParams.put("notify_url", "http://xxxx/pay/appNotify");        try {            String orderStr = api.sdkExecute("alipay.trade.app.pay", bizParams);            System.out.println(orderStr);            return orderStr;        } catch (ApiException e) {            System.out.println("调用失败");        }        return "";    }    /**     * 预下单（沙箱环境调用显示无权限；ACCESS_FORBIDDEN）     * @return     * @throws ApiException     */    @GetMapping(value = "/createPay")    public String getOrderPreCreatePay() throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi alipayTradeApi = new AlipayTradeApi();        AlipayTradePrecreateModel model = new AlipayTradePrecreateModel();        model.setOutTradeNo(String.valueOf(System.currentTimeMillis()));        model.setTotalAmount("9.00");        model.setSubject("扫码测试");        model.setProductCode("QR_CODE_OFFLINE");        model.setNotifyUrl("http://xxxx/pay/notify");        try {            AlipayTradePrecreateResponseModel responseModel = alipayTradeApi.precreate(model);            //{"code":"ACQ.ACCESS_FORBIDDEN","message":"ACCESS_FORBIDDEN"} 没有权限，沙箱环境没有alipay.trade.precreate权限            System.out.println("调用成功："+JSON.serialize(responseModel));            return responseModel.getQrCode();        } catch (ApiException e) {            System.out.println("调用失败:"+e);        }        return "";    }    @GetMapping(value = "/createPay2",produces = "text/html;charset=UTF-8")    public String getOrderPreCreatePay2() throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        GenericExecuteApi api = new GenericExecuteApi();        HashMap&lt;String, Object&gt; bizContent = new HashMap&lt;&gt;();        HashMap&lt;String, Object&gt; bizParams = new HashMap&lt;&gt;();        bizContent.put("out_trade_no", String.valueOf(System.currentTimeMillis()));        bizContent.put("total_amount", "9.00");        bizContent.put("subject", "扫码测试");        bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");        /**         * 支持前置模式和跳转模式。         * 前置模式是将二维码前置到商户的订单确认页的模式。需要商户在自己的页面中以 iframe 方式请求支付宝页面。具体支持的枚举值有以下几种：         * 0：订单码-简约前置模式，对应 iframe 宽度不能小于600px，高度不能小于300px；         * 1：订单码-前置模式，对应iframe 宽度不能小于 300px，高度不能小于600px；         * 3：订单码-迷你前置模式，对应 iframe 宽度不能小于 75px，高度不能小于75px；         * 4：订单码-可定义宽度的嵌入式二维码，商户可根据需要设定二维码的大小。         * 跳转模式下，用户的扫码界面是由支付宝生成的，不在商户的域名下。支持传入的枚举值有：         * 2：订单码-跳转模式         */        bizContent.put("qr_pay_mode", "4");        bizContent.put("qrcode_width", 100);        bizParams.put("notify_url", "http://lql5520.yunmv.cn/pay/pcNotify");        bizParams.put("return_url", "https://docs.open.alipay.com");        bizParams.put("biz_content", bizContent);        try {            String form = api.pageExecute("alipay.trade.page.pay", "POST", bizParams);            System.out.println("调用成功："+JSON.serialize(form));            return form;        } catch (ApiException e) {            System.out.println("调用失败:"+e);        }        return "";    }    /**     * https://opendocs.alipay.com/open-v3/01073208_alipay.trade.refund     * 退款时根据异步的返回信息可进行判断，但部分接口存在全额退款时不进行触发异步（电脑网站支付，全额退款时，TRADE_CLOSED,没有异步通知），     * 因此建议根据退款同步响应参数以及退款查询接口进行判断。     *     * 部分退款：     * 检查是否设置out_request_no参数，该参数是标识一次退款请求，同一笔交易多次退款需要保证唯一，且 部分退款，则此参数必传。     * @param orderNo     * @param amount     * @return     * @throws ApiException     */    @GetMapping ("/refundPay")    public String refundPay(String orderNo,String amount) throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        // 构造请求参数以调用接口        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeRefundModel data = new AlipayTradeRefundModel();        // 部分退款时,outRequestNo必传,同一笔交易多次退款需要保证唯一        data.outRequestNo(String.valueOf(System.currentTimeMillis()));        data.setOutTradeNo(orderNo);        data.setRefundAmount(amount);        data.setRefundReason("测试退款");        // 第三方代调用模式下请设置app_auth_token        CustomizedParams params = new CustomizedParams();        params.setAppAuthToken("&lt;-- 请填写应用授权令牌 --&gt;");        try {            AlipayTradeRefundResponseModel response = api.refund(data);            //{"buyer_logon_id":"rpv***@sandbox.com","buyer_user_id":"2088722013720112","fund_change":"Y","gmt_refund_pay":"2024-12-19 14:16:39","out_trade_no":"1734423455786","refund_fee":"15.88","send_back_fee":"0.00","trade_no":"2024121722001420110504891744"}            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeRefundDefaultResponse errorObject = (AlipayTradeRefundDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    /**     * 退款查询接口返回 refund_status=REFUND_SUCCESS 表示退款处理成功，否则表示退款没有执行成功。     * @param orderNo     * @return     * @throws ApiException     */    @GetMapping ("/refundPayQuery")    public String refundPayQuery(String orderNo,String outRequestNo) throws ApiException {        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        // 构造请求参数以调用接口        AlipayTradeFastpayRefundApi api = new AlipayTradeFastpayRefundApi();        AlipayTradeFastpayRefundQueryModel data = new AlipayTradeFastpayRefundQueryModel();        data.setOutTradeNo(orderNo);        //部分退款需要传入，哪次退款的outRequestNo        data.setOutRequestNo(outRequestNo);        // 第三方代调用模式下请设置app_auth_token        CustomizedParams params = new CustomizedParams();        params.setAppAuthToken("&lt;-- 请填写应用授权令牌 --&gt;");        try {            AlipayTradeFastpayRefundQueryResponseModel response = api.query(data);            //{"out_request_no":"1734575090879","out_trade_no":"1734575090879","refund_amount":"5.88","refund_status":"REFUND_SUCCESS","total_amount":"5.88","trade_no":"2024121922001420110504904489"}            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeFastpayRefundQueryDefaultResponse errorObject = (AlipayTradeFastpayRefundQueryDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    @GetMapping("/closeOrder")    public String close(String orderNo) throws ApiException {        //1733990822574        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeCloseModel data = new AlipayTradeCloseModel();        // 设置订单支付时传入的商户订单号        data.setOutTradeNo(orderNo);        try {            AlipayTradeCloseResponseModel response = api.close(data);            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeCloseDefaultResponse errorObject = (AlipayTradeCloseDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject);        }        return "";    }    @GetMapping("/cancelOrder")    public String cancel(String orderNo) throws ApiException {        //1733990822574        ApiClient defaultClient = Configuration.getDefaultApiClient();        // 初始化alipay参数（全局设置一次）        defaultClient.setAlipayConfig(getAlipayConfig());        AlipayTradeApi api = new AlipayTradeApi();        AlipayTradeCancelModel data = new AlipayTradeCancelModel();        // 设置订单支付时传入的商户订单号        data.setOutTradeNo(orderNo);        try {            AlipayTradeCancelResponseModel response = api.cancel(data);            System.out.println("调用成功:" + JSON.serialize(response));            return JSON.serialize(response);        } catch (ApiException e) {            AlipayTradeCancelDefaultResponse errorObject = (AlipayTradeCancelDefaultResponse) e.getErrorObject();            System.out.println("调用失败:" + errorObject.getAlipayTradeCancelErrorResponseModel());        }        return "";    }    private AlipayConfig getAlipayConfig() {        AlipayConfig alipayConfig = new AlipayConfig();        //alipayConfig.setServerUrl("https://openapi.alipay.com");        alipayConfig.setServerUrl("https://openapi-sandbox.dl.alipaydev.com");        alipayConfig.setAppId("902xxxxxxx");        alipayConfig.setPrivateKey("MIIEvAIBADAxxxxx");        alipayConfig.setAlipayPublicKey("MIIBIjANxxxxxx");        return alipayConfig;    }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot项目接入支付宝v3接口&quot;&gt;&lt;a href=&quot;#SpringBoot项目接入支付宝v3接口&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot项目接入支付宝v3接口&quot;&gt;&lt;/a&gt;SpringBoot项目接入支付宝v3接口&lt;/</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/category/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Alipay" scheme="http://example.com/tags/Alipay/"/>
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/06/05/hello-world/"/>
    <id>http://example.com/2024/06/05/hello-world/</id>
    <published>2024-06-05T12:06:14.656Z</published>
    <updated>2024-06-05T12:06:14.656Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="test" scheme="http://example.com/category/test/"/>
    
    
    <category term="Interview" scheme="http://example.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的专属博客</title>
    <link href="http://example.com/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-04-30T04:14:20.000Z</published>
    <updated>2024-06-05T12:06:14.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="教程-Hexo-Github-搭建自己的专属博客"><a href="#教程-Hexo-Github-搭建自己的专属博客" class="headerlink" title="[教程]Hexo + Github 搭建自己的专属博客"></a><strong>[教程]Hexo + Github 搭建自己的专属博客</strong></h1><p>教程来自<a href="https://blog.csdn.net/2301_76761656/article/details/137087231">【Hexo + Github 搭建自己的专属博客】_wudreamer.github-CSDN博客</a>，自己实操并修改了一些内容。</p><h2 id="1-安装Git和NodeJS"><a href="#1-安装Git和NodeJS" class="headerlink" title="1. 安装Git和NodeJS"></a><strong>1. 安装Git和NodeJS</strong></h2><p>在Windows上使用Git，可以从Git官网直接 <a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>在Git中绑定Github账号，打开“Git Bash”，在命令框中依次输入两行命令：</p><pre><code class="bash">git config --global user.name "Your Name"git config --global user.email "email@example.com"# 其中Your Name和email@example.com替换成上面注册时的账户名和邮箱</code></pre><p>由于 Hexo 是基于 Node.js 驱动的一款博客框架，所以安装NodeJS <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 并配置环境变量。安装之后可以输入以下命令查看是否安装成功：</p><pre><code class="bash">git versionnode -vnpm -v</code></pre><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a><strong>2. 安装Hexo</strong></h2><p>以上环境准备好了就可使用 npm 开始安装 Hexo 了，在命令行输入执行如下命令：</p><pre><code class="bash">npm install -g hexo-cli</code></pre><p>安装 Hexo 完成后，在指定文件夹下打开“Git Bash”，再执行下列命令，Hexo 将会在指定文件夹中新建所须要的文件：</p><pre><code class="bash">hexo init myBlogcd myBlognpm install</code></pre><p>若是上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a><a href="http://localhost:4000/"> </a>回车就能够预览效果了。</p><h2 id="3-加载主题"><a href="#3-加载主题" class="headerlink" title="3. 加载主题"></a><strong>3. 加载主题</strong></h2><p>大家可以去官网上找自己喜欢的主题下载<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><a href="https://hexo.io/themes/"> </a>，自己采用的主题是<a href="https://github.com/Siricee/hexo-theme-Chic">https://github.com/Siricee/hexo-theme-Chic</a> ，这款有明暗两种颜色。</p><p>基本大家用的最多的是NEXT主题：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a>随后将下载的主题文件夹放在 myblog/themes中，在 _config.yml文件中修改theme 为hexo-theme-Chic(注意和主题文件名一致)</p><p>本人用的是<a href="https://gitee.com/tencent_m/hexo-theme-Claudia">hexo-theme-Claudia</a>。</p><p>修改好之后在“Git Bash”中执行 hexo g 命令，然后再 hexo s，在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 回车就能够预览修改主题后的效果了。</p><h2 id="4-修改主题配置"><a href="#4-修改主题配置" class="headerlink" title="4. 修改主题配置"></a><strong>4. 修改主题配置</strong></h2><p>修改在主题文件夹下的 _config.yml文件，完成自己个人的配置。</p><pre><code class="yaml"># Headernavname: Bentham's Blog# navigatior itemsnav:  Posts: /archives  Categories: /category  Tags: /tag  About: /about# faviconfavicon: /favicon.ico# Profilenickname: Jeremy Bentham### this variable is MarkDown form.description: Lorem ipsum dolor sit amet, **consectetur adipiscing elit.** &lt;br&gt;Fusce eget urna vitae velit *eleifend interdum at ac* nisi.avatar: /image/avatar.jpeg# main menu navigation## links key words should not be changed.## Complete url after key words.## Unused key can be commented out.links:  Blog: /archives  # Category:  # Tags:   # Link:  # Resume:  # Publish:  # Trophy:  # Gallery:  # RSS:  # AliPay:  ZhiHu: https://www.zhihu.com/people/sirice  # LinkedIn:  # FaceBook:  # Twitter:  # Skype:  # CodeSandBox:  # CodePen:  # Sketch:  # Gitlab:  # Dribbble:  Instagram:  Reddit:  # YouTube:  # QQ:  # Weibo:  # WeChat:  Github: https://github.com/Siricee# how links show: you have 2 choice--text or icon.links_text_enable: falselinks_icon_enable: true# Post page## Post_metapost_meta_enable: truepost_author_enable: truepost_date_enable: truepost_category_enable: true## Post copyrightpost_copyright_enable: truepost_copyright_author_enable: truepost_copyright_permalink_enable: truepost_copyright_license_enable: truepost_copyright_license_text: Copyright (c) 2019 &lt;a href="http://creativecommons.org/licenses/by-nc/4.0/"&gt;CC-BY-NC-4.0&lt;/a&gt; LICENSEpost_copyright_slogan_enable: truepost_copyright_slogan_text: Do you believe in &lt;strong&gt;DESTINY&lt;/strong&gt;?## tocpost_toc_enable: true# Pagepage_title_enable: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMMM D, YYYYtime_format: H:mm:ss# stylesheets loaded in the &lt;head&gt;stylesheets:  - /css/style.css# scripts loaded in the end of the bodyscripts:  - /js/script.js  - /js/tocbot.min.js    # tscanlin/tocbot: Build a table of contents from headings in an HTML document.    # https://github.com/tscanlin/tocbot# plugin functions## Mathjax: Math Formula Support## https://www.mathjax.orgmathjax:  enable: true  import: demand # global or demand  ## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong.  ## demand: Recommend option,if your post need fomula, you can declare 'mathjax: true' in Front-matter</code></pre><p>hexo-theme-Claudia的_config.yml文件如下：</p><pre><code class="yaml"># main menu navigationmenu:  Home: /  About: /about  Archive: /archiveswidgets:  - tag  - archive  - recent_posts  - category  - profile# social configsocial:  zhihu:  twitter: /  facebook: /  linkedin:  instagram: /  github: haojenuser:  name: Haojen  avatar: /images/avatar.jpg  location: In the dust  description: May the Force be with you  footnotes: #footnotes# documents: https://github.com/utterance/utterances# API config: https://utteranc.es/comment_utteranc:  enable: true  repo: Haojen/Claudia-theme-blog # your blog repo# documents: https://valine.js.org/quickstart.htmlcomment_valine:  enable: false  appId:  appKey:# dark# light# user-can-setappearance: auto # Default value is auto# Miscellaneousfavicon: /images/favicon.png# Google Analyticsga_track_id:ga_domain:# Baidu Analyticsba_track_id:</code></pre><h2 id="5-将博客部署在GitHub上"><a href="#5-将博客部署在GitHub上" class="headerlink" title="5. 将博客部署在GitHub上"></a><strong>5. 将博客部署在GitHub上</strong></h2><p>点击 Start project 或者下面的 new repository 建立一个新的仓库，注意<strong>Github 仅能使用一个同名仓库的代码托管一个静态站点</strong>，这里注意仓库名一定要是： 用户名.github.io</p><p>配置 SSH key ，要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 作准备。</p><pre><code class="bash">git config --global user.name "用户名"git config --global user.email "邮箱地址"ssh-keygen -t rsa -C '上面的邮箱'</code></pre><p>按照提示完成三次回车，便可生成 ssh key，采用以下指令也可以查看自己的ssh：</p><pre><code class="bash">cat ~/.ssh/id\_rsa.pub</code></pre><p>首次使用还须要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功。</p><p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p><p>登陆 Github 上添加刚刚生成的SSH key，按如下步骤添加，右上角点击头像-&gt; settings -&gt; SSH and GPG keys，建立一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认建立，这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p>此时，本地和Github的工做作得差不了，是时候把它们两个链接起来了。你也能够查看官网的部署教程。先不着急，部署以前还须要修改配置和安装部署插件。第一：打开项目根目录下的_config.yml 配置文件配置参数。拉到文件末尾，填上以下配置。</p><pre><code class="yaml">deploy:  type: git  #仓库地址，username是你的github用户名  repo: https://github.com/username/username.github.io.git   branch: master #代码分支</code></pre><p>第二要安装一个部署插件 hexo-deployer-git，打开“Git Bash”，输如以下指令：</p><pre><code class="bash"> npm install hexo-deployer-git --save </code></pre><p>最后执行如下两条命令就能够部署上传啦，如下 g 是 generate 缩写，d 是 deploy 缩写，hexo help 可以查看相关命令。 </p><pre><code class="bash">hexo g # 先生成hexo d # 部署到Github上</code></pre><p>这时用浏览器输入 用户名.github.io就可以访问刚才的网站啦。</p><h2 id="6-写文章并上传"><a href="#6-写文章并上传" class="headerlink" title="6. 写文章并上传"></a><strong>6. 写文章并上传</strong></h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档能够看 hexo 官网。新建文章，输入如下命令便可</p><pre><code class="bash">hexo new '文章标题'</code></pre><p>执行完成后能够在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdow格式的文件，具体用法能够在网上找一下，语法仍是比较简单的。同时会生成一个同名文件夹，可以把文章需要的图片放在里面。</p><pre><code class="markdown">---title: blogTestdate: 2021-08-20 18:07:21tags: Testcategories: blog1---### 1. This is a blog Test* First* Second---### 2. Show Text* **这是加粗**&gt; *这是斜体*</code></pre><p>之后依次输入以下命令：</p><pre><code class="bash">hexo g # 生成文件hexo s # 本地服务器查看网站hexo d # 部署到Github 上</code></pre><h2 id="7-配置一些特效"><a href="#7-配置一些特效" class="headerlink" title="7. 配置一些特效"></a><strong>7. 配置一些特效</strong></h2><p>雪花特效： themes\hexo-theme-Chic\layout\index.ejs中添加如下代码：</p><pre><code class="html">&lt;!-- 雪花特效 --&gt;&lt;script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="https://libs.baidu.com/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/snow.js"&gt;&lt;/script&gt;</code></pre><p>蜘蛛网特效： themes\hexo-theme-Chic\layout\layout.ejs中添加如下代码：</p><pre><code class="javascript">&lt;script&gt;!function() {function n(n, e, t) {return n.getAttribute(e) || t}function e(n) {return document.getElementsByTagName(n)}function t() {var t = e("script"),o = t.length,i = t[o - 1];return {l: o,z: n(i, "zIndex", -1), //置于主页面背后o: n(i, "opacity", .5), //线条透明度c: n(i, "color", "0,0,0"), //线条颜色n: n(i, "count", 100) //线条数量}}function o() {a = m.width = window.innerWidth ||document.documentElement.clientWidth || document.body.clientWidth,c = m.height = window.innerHeight ||document.documentElement.clientHeight || document.body.clientHeight}function i() {r.clearRect(0, 0, a, c);var n, e, t, o, m, l;s.forEach(function(i, x) {for (i.x += i.xa, i.y += i.ya, i.xa *= i.x &gt; a || i.x &lt; 0 ? -1 :1, i.ya *= i.y &gt; c || i.y &lt; 0 ? -1 : 1, r.fillRect(i.x - .5, i.y - .5, 1,1), e = x + 1; e &lt; u.length; e++) n = u[e],null !== n.x &amp;&amp; null !== n.y &amp;&amp; (o = i.x - n.x, m = i.y - n.y, l= o * o + m * m, l &lt; n.max &amp;&amp; (n === y &amp;&amp; l &gt;= n.max / 2 &amp;&amp; (i.x -= .03 * o,i.y -= .03 * m), t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t /2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) + ")", r.moveTo(i.x, i.y),r.lineTo(n.x, n.y), r.stroke()))}),x(i)}var a, c, u, m = document.createElement("canvas"),d = t(),l = "c_n" + d.l,r = m.getContext("2d"),x = window.requestAnimationFrame || window.webkitRequestAnimationFrame|| window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function(n) {window.setTimeout(n, 1e3 / 45)},w = Math.random,y = {x: null,y: null,max: 2e4};m.id = l,m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z +";opacity:" + d.o,e("body")[0].appendChild(m),o(),window.onresize = o,window.onmousemove = function(n) {n = n || window.event,y.x = n.clientX,y.y = n.clientY// 评论区采用的时Valine https://valine.js.org/ 和LeanCloud},window.onmouseout = function() {y.x = null,y.y = null};for (var s = [], f = 0; d.n &gt; f; f++) {var h = w() * a,g = w() * c,v = 2 * w() - 1,p = 2 * w() - 1;s.push({x: h,y: g,xa: v,ya: p,max: 6e3})}u = s.concat([y]),setTimeout(function() {i()},100)} ();&lt;/script&gt;</code></pre><p>hexo-theme-Claudia主题加雪花特效：</p><p>在<strong>themes\hexo-theme-Claudia\source\js</strong>目录下，添加snow.js,代码如下：</p><pre><code class="javascript">/* 控制下雪 */function snowFall(snow) {    /* 可配置属性 */    snow = snow || {};    this.maxFlake = snow.maxFlake || 200;   /* 最多片数 */    this.flakeSize = snow.flakeSize || 10;  /* 雪花形状 */    this.fallSpeed = snow.fallSpeed || 1;   /* 坠落速度 */}/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame ||    window.oRequestAnimationFrame ||    function(callback) { setTimeout(callback, 1000 / 60); }; cancelAnimationFrame = window.cancelAnimationFrame ||    window.mozCancelAnimationFrame ||    window.webkitCancelAnimationFrame ||    window.msCancelAnimationFrame ||    window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function(){    /* 创建画布 */    snowCanvas.apply(this);    /* 创建雪花形状 */    createFlakes.apply(this);    /* 画雪 */    drawSnow.apply(this)}/* 创建画布 */function snowCanvas() {    /* 添加Dom结点 */    var snowcanvas = document.createElement("canvas");    snowcanvas.id = "snowfall";    snowcanvas.width = document.body.offsetWidth;    snowcanvas.height = window.innerHeight;    snowcanvas.setAttribute("style", "position:fixed; top: 0; left: 0; z-index: -1; pointer-events: none;");    document.getElementsByTagName("body")[0].appendChild(snowcanvas);    this.canvas = snowcanvas;    this.ctx = snowcanvas.getContext("2d");    /* 窗口大小改变的处理 */    window.onresize = function() {        // snowcanvas.width = document.body.offsetWidth;        /* snowcanvas.height = window.innerHeight */    }}/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) {    this.x = Math.floor(Math.random() * canvasWidth);   /* x坐标 */    this.y = Math.floor(Math.random() * canvasHeight);  /* y坐标 */    this.size = Math.random() * flakeSize + 2;          /* 形状 */    this.maxSize = flakeSize;                           /* 最大形状 */    this.speed = Math.random() * 1 + fallSpeed;         /* 坠落速度 */    this.fallSpeed = fallSpeed;                         /* 坠落速度 */    this.velY = this.speed;                             /* Y方向速度 */    this.velX = 0;                                      /* X方向速度 */    this.stepSize = Math.random() / 30;                 /* 步长 */    this.step = 0                                       /* 步数 */}flakeMove.prototype.update = function() {    var x = this.x,        y = this.y;    /* 左右摆动(余弦) */    this.velX *= 0.98;    if (this.velY &lt;= this.speed) {        this.velY = this.speed    }    this.velX += Math.cos(this.step += .05) * this.stepSize;     this.y += this.velY;    this.x += this.velX;    /* 飞出边界的处理 */    if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) {        this.reset(canvas.width, canvas.height)    }};/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) {    this.x = Math.floor(Math.random() * width);    this.y = 0;    this.size = Math.random() * this.maxSize + 2;    this.speed = Math.random() * 1 + this.fallSpeed;    this.velY = this.speed;    this.velX = 0;};// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) {    var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);    snowFlake.addColorStop(0, "rgba(255, 255, 255, 0.9)");  /* 此处是雪花颜色，默认是白色 */    snowFlake.addColorStop(.5, "rgba(255, 255, 255, 0.5)"); /* 若要改为其他颜色，请自行查 */    snowFlake.addColorStop(1, "rgba(255, 255, 255, 0)");    /* 找16进制的RGB 颜色代码。 */    ctx.save();    ctx.fillStyle = snowFlake;    ctx.beginPath();    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);    ctx.fill();    ctx.restore();};/* 创建雪花-定义形状 */function createFlakes() {    var maxFlake = this.maxFlake,        flakes = this.flakes = [],        canvas = this.canvas;    for (var i = 0; i &lt; maxFlake; i++) {        flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed))    }}/* 画雪 */function drawSnow() {    var maxFlake = this.maxFlake,        flakes = this.flakes;    ctx = this.ctx, canvas = this.canvas, that = this;    /* 清空雪花 */    ctx.clearRect(0, 0, canvas.width, canvas.height);    for (var e = 0; e &lt; maxFlake; e++) {        flakes[e].update();        flakes[e].render(ctx);    }    /*  一帧一帧的画 */    this.loop = requestAnimationFrame(function() {        drawSnow.apply(that);    });}/* 调用及控制方法 */window.onload = function() {      var element = document.body;      var width = element.offsetWidth;      var height = element.offsetHeight;      console.log("Width: " + width + "px");      console.log("Height: " + height + "px");            var snow = new snowFall({maxFlake:200});    snow.start();};</code></pre><p>然后可以在themes\hexo-theme-Claudia\layout目录下的index.pug引入这个js</p><pre><code class="pug">extends widget/baseblock append head    link(rel='stylesheet', href= url_for("/style/widget-post-list.css"))    script(src= url_for("/js/snow.js"))block content    include widget/widget-post-list        block sidebar            include widget/widget-search            if theme.widgets.includes('profile')                include widget/widget-profile            if theme.widgets.includes('recent_posts')                include widget/widget-recent            if theme.widgets.includes('category') &amp;&amp; site.categories.length &gt; 0                include widget/widget-categories            if theme.widgets.includes('archive')                include widget/widget-archives            if theme.widgets.includes('tag') &amp;&amp; site.tags.length &gt; 0                include widget/widget-tag            if theme.friend_links &amp;&amp; theme.friend_links.length &gt; 0                main.aside-card-container.friend-widget                    h3= _p('friends')                    section                        each link in theme.friend_links                            a(href= link.link)                                span.tag.post-item-tag(style="margin-bottom: 5px;")= link.title</code></pre><h2 id="8-代码高亮处理，以及增加复制、折叠功能"><a href="#8-代码高亮处理，以及增加复制、折叠功能" class="headerlink" title="8.代码高亮处理，以及增加复制、折叠功能"></a>8.代码高亮处理，以及增加复制、折叠功能</h2><p>hexo默认可以使用<a href="https://github.com/highlightjs/highlight.js">highlight.js</a> 或者<a href="https://github.com/PrismJS/prism">prismjs</a> 高亮库，开启相关配置见：<a href="https://hexo.io/zh-cn/docs/syntax-highlight">代码高亮 | Hexo</a>。</p><p>hexo-theme-Claudia主题自带代码高亮，但是不支持行号，只要把hexo默认的的高亮配置关闭就行：</p><pre><code class="yaml">syntax_highlighter:highlight:  enable: false  line_number: true  auto_detect: false  tab_replace: ''  wrap: false  hljs: trueprismjs:  enable: false  preprocess: true  line_number: true  tab_replace: ''</code></pre><p>或者可以自定义代码高亮配置，可以从网上找教程。</p><p>代码块增加复制、折叠功能参考：<a href="https://zhuanlan.zhihu.com/p/124888459">Hexo 博客代码块样式美化 - 知乎 (zhihu.com)</a>。</p><p>我在hexo-theme-Claudia主题的**/themes/hexo-theme-Claudia/layout/post.pug**文件引入了codeBlockFuction.js、codeBLang.js、codeCopy.js、codeShrink.js、自定义了custom.css(使用默认的高亮样式就不需要),注意font-awesome、highlightjs-line-numbers.min.js和clipboard.min.js我用cdn引入了。</p><p>hexo-theme-Claudia主题的代码分词和高亮是<strong>highlight.pack.js、highlight-theme-light.css</strong>实现的。</p><p>想要自己实现可以从官网<a href="https://highlightjs.org/download">Download a Custom Build - highlight.js (highlightjs.org)</a>下载的最新的highlight.min.js，同时可以修改highlight-theme-light.css，行号的一些样式我加在了这个css中，然后在post.js中<strong>hljs &amp;&amp; hljs.initLineNumbersOnLoad();</strong> 使用。</p><p>或者不使用highlight-theme-light.css，直接从网上找其他的<a href="https://github.com/highlightjs/highlight.js/tree/main/src/styles">highlight.js/src/styles at main · highlightjs/highlight.js (github.com)</a>，比如monokai-sublime.min.css，直接引入就可以了。post.pug代码如下：</p><pre><code class="pug">extends widget/baseblock append head  link(rel='stylesheet', href= url_for('/style/post.css'))  link(rel='stylesheet', href= url_for('/style/themes/highlight-theme-light.css'))  link(rel='stylesheet' href= url_for('https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.css'))  //link(rel='stylesheet', href= url_for('/style/themes/monokai-sublime.min.css'))  link(rel='stylesheet', href= url_for('/style/common/jquery.fancybox.min.css'))  //script(src= url_for("/js/highlight.pack.js"))    script(src= url_for("/js/highlight.min.js"))  style(type="text/css") code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }  script(src= url_for("https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"))    script(src= url_for("https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"))  script(src= url_for("https://cdn.bootcdn.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"))  script(src= url_for("/js/hightlight/codeBLang.js"))    script(src= url_for("/js/hightlight/codeBlockFuction.js"))    script(src= url_for("/js/hightlight/codeCopy.js"))    script(src= url_for("/js/hightlight/codeShrink.js"))    meta(name="description", content=truncate( strip_html(page.content), {length: 360, omission: '..'} ))  if theme.comment_valine &amp;&amp; theme.comment_valine.enable      script(src="//unpkg.com/valine/dist/Valine.min.js")block topic    div#postTopic.is-full-height        - var title = truncate( page.title, {length: 65, omission: '..'} ) || ''        p.is-full-height.is-flex-shrink-0.is-flex.is-align-items-center.is-justify-content-center= title        p.is-full-height.is-flex-shrink-0.is-flex.is-align-items-center.is-justify-content-center= __('click_back_to_the_top')block content    - var tocContent = toc(page.content, {list_number: false})    main.container.is-max-widescreen.content.section.post-page.pt-4.px-4        .columns.is-flex-desktop.is-justify-content-center.is-flex-direction-row-reverse            .column.is-3.is-hidden-mobile(class= tocContent.length &lt; 1 &amp;&amp; 'is-hidden')!= tocContent            .column.is-9                header.my-4                    if page.tags &amp;&amp; page.tags.length &gt; 0                        each tag in page.tags.toArray()                            a(href= url_for(`/tags/${tag.name}`))                                i.tag.post-item-tag= tag.name                h1.mt-0.mb-1.is-family-serif#postTitle= page.title                if page.date                    time.has-text-grey(datetime=page.date.toJSON())= date(page.date, date_format)                article.mt-2.post-content!= page.content                section.jump-container.is-flex.is-justify-content-space-between.my-6                    // em is empty placeholder                    if page.prev                        - var preContent= `${ __('prev') }: ${ page.prev.title }`                        a.button.is-default(href= url_for(page.prev.path) title= page.prev.title)                            i.iconfont.icon-prev.mr-2.has-text-grey                            span.has-text-weight-semibold= preContent                    else                        em                    if page.next                        - var nextContent= `${ __('next') }: ${ page.next.title }`                        a.button.is-default(href= url_for(page.next.path) title= page.next.title)                            span.has-text-weight-semibold= nextContent                            i.iconfont.icon-next.ml-2.has-text-grey                if theme.comment_utteranc &amp;&amp; theme.comment_utteranc.enable                    article.mt-6.comment-container                        script(                            async                            repo= theme.comment_utteranc.repo                            src= "https://utteranc.es/client.js"                            label= theme.comment_utteranc.label                            issue-term= theme.comment_utteranc.issue_term || "pathname"                            theme= theme.comment_utteranc.theme || "preferred-color-scheme"                        )                if theme.comment_valine &amp;&amp; theme.comment_valine.enable                    article.mt-6.comment-container#vcomments(                        data-comment_valine_id= theme.comment_valine.appId                        data-comment_valine_key= theme.comment_valine.appKey                    )                if theme.comment_disqus &amp;&amp; theme.comment_disqus.enable                    div#disqus_thread                    article.mt-6.comment-container#disqus                        script="var disqus_config = function () {this.page.url = '"+theme.comment_disqus.url+url_for(page.path)+"';this.page.identifier = '"+theme.comment_disqus.name+"';};"                        script="(function() {var d = document, s = d.createElement('script');s.src = 'https://"+theme.comment_disqus.name+".disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();"                        script(id="dsq-count-scr", src="//blog-pubgj2togw.disqus.com/count.js", async)block script    if theme.image_zoom &amp;&amp; theme.image_zoom.enable        script(src= url_for("/js/jquery-3.6.1.min.js"))        script(src= url_for("/js/jquery-fancybox.min.js"))        script(src= url_for("/js/img_zoom.js"))    script(src= url_for("/js/post.js"))  </code></pre><h2 id="9-图片显示及相关问题"><a href="#9-图片显示及相关问题" class="headerlink" title="9.图片显示及相关问题"></a>9.图片显示及相关问题</h2><p>图片可以使用网络图片或者图床，直接把url复制粘贴就可以显示了。如果使用本地图片，可以把图片放入同名文章的文件夹里，直接用相对路径引用，如：<strong>pic.jpg</strong>，注意不要用**/pic.jpg**，不然会被识别成绝对路径。<img src="/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/1.PNG"></p><p>因为md生成的html和图片在同一个文件夹里 。</p><p><img src="/2024/04/30/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2/2.PNG"></p><p>如果要在Typora中预览本地图片，在<strong>格式-&gt;图像-&gt;设置图片根目录</strong>，选择同名文件夹就可以了。详细操作参考：</p><p><a href="https://zhuanlan.zhihu.com/p/265077468">参考：hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p><h2 id="10-评论区"><a href="#10-评论区" class="headerlink" title="10.评论区"></a>10.评论区</h2><p>评论区采用的时Valine <a href="https://valine.js.org/">https://valine.js.org/</a><a href="https://valine.js.org/"> </a>和LeanCloud</p><h2 id="11-其他美化功能"><a href="#11-其他美化功能" class="headerlink" title="11.其他美化功能"></a>11.其他美化功能</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/69211731">Hexo 博客美化合集（不断更新） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;教程-Hexo-Github-搭建自己的专属博客&quot;&gt;&lt;a href=&quot;#教程-Hexo-Github-搭建自己的专属博客&quot; class=&quot;headerlink&quot; title=&quot;[教程]Hexo + Github 搭建自己的专属博客&quot;&gt;&lt;/a&gt;&lt;strong&gt;[教程</summary>
      
    
    
    
    <category term="教程" scheme="http://example.com/category/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
    <category term="GitHub" scheme="http://example.com/tags/GitHub/"/>
    
  </entry>
  
</feed>
