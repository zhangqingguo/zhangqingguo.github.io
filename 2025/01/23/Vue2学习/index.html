<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Vue2学习</title><meta name="description" content="666"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- 解决403图片防盗链的问题 -->    <meta content="no-referrer" name="referrer"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><link rel="stylesheet" href="/style/custom.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.css"><!--link(rel='stylesheet', href= url_for('/style/themes/monokai-sublime.min.css'))--><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><!--script(src= url_for("/js/highlight.pack.js"))--><script src="/js/highlight.min.js"></script><style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"> </script><script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script><script src="/js/hightlight/codeBLang.js"> </script><script src="/js/hightlight/codeBlockFuction.js"> </script><script src="/js/hightlight/codeCopy.js"> </script><script src="/js/hightlight/fullScreen.js"> </script><script src="/js/hightlight/codeShrink.js"> </script><meta name="description" content="Vue2学习视频教程来自尚硅谷：尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通_哔哩哔哩_bilibili,vue2文档：介绍 — Vue.js
1. vue基础知识和原理1.1 初识vue
想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象

app容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法

app容器里的代码被称为【Vue模板】

Vue实例和容器是一一对应的,不能一对多和多对一

真实开发中只有一个Vue实例，并且会配合着组件一起使用

是Vue的语法：插值表达式，可以读取到data中的所有属性
一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新(Vue实现的响应式)代码：这里是直接引入开发版本的vue.js,可以去官网下载

.."><meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="ZQG的博客" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">ZQG's blog  </a><iframe frameborder="0" height="20" hspace="0" scrolling="no" src="https://i.tianqi.com/?c=code&amp;a=getcode&amp;id=1&amp;icon=1" width="550"></iframe><iframe clocktype="html5" frameborder="no" scrolling="no" style="overflow:hidden;border:0;margin:0;padding:0;width:140px;height:25px;" src="https://www.clocklink.com/html5embed.php?clock=047&amp;timezone=CCT&amp;color=black&amp;size=140&amp;Title=&amp;Message=&amp;Target=&amp;From=2024,1,1,0,0,0&amp;Color=black"></iframe></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Vue2学习</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2%E5%AD%A6%E4%B9%A0"><span class="toc-text">Vue2学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">1. vue基础知识和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%88%9D%E8%AF%86vue"><span class="toc-text">1.1 初识vue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">1.2 模板语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">1.3 数据绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-text">1.4 el与data的两种写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-MVVM%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.5 MVVM模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="toc-text">1.6 数据代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">1.7 事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">1.8 键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-text">1.9 计算属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7"><span class="toc-text">1.10 监视属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11 绑定样式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E6%A0%B7%E5%BC%8F"><span class="toc-text">class样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#style%E6%A0%B7%E5%BC%8F"><span class="toc-text">style样式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">1.12 条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if"><span class="toc-text">v-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show"><span class="toc-text">v-show</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">1.13 列表渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-for%E6%8C%87%E4%BB%A4"><span class="toc-text">v-for指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">key的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-%E5%88%97%E8%A1%A8%E8%BF%87%E6%BB%A4"><span class="toc-text">1.14 列表过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">1.15 列表排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-16-Vue%E7%9B%91%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.16 Vue监测数据的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%B5%8B%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-text">监测对象数据：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-text">监测数组：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-text">1.17 收集表单数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">1.18 过滤器使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">1.19 内置指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">1.20 自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-21-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.21 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-21-%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">1.21 非单文件组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-22-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">1.22 单文件组件</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Vue"><i class="tag post-item-tag">Vue</i></a><a href="/tags/Vue2"><i class="tag post-item-tag">Vue2</i></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%89%8D%E7%AB%AF"><i class="tag post-item-tag">学习笔记，前端</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Vue2学习</h1><time class="has-text-grey" datetime="2025-01-23T01:20:56.000Z">2025-01-23</time><article class="mt-2 post-content"><h1 id="Vue2学习"><a href="#Vue2学习" class="headerlink" title="Vue2学习"></a>Vue2学习</h1><p>视频教程来自尚硅谷：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zy4y1K7SH/?vd_source=51c1f9b29ad3cdfa95187e2976f09cef">尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通_哔哩哔哩_bilibili</a>,vue2文档：<a target="_blank" rel="noopener" href="https://v2.cn.vuejs.org/v2/guide/">介绍 — Vue.js</a></p>
<h2 id="1-vue基础知识和原理"><a href="#1-vue基础知识和原理" class="headerlink" title="1. vue基础知识和原理"></a>1. vue基础知识和原理</h2><h3 id="1-1-初识vue"><a href="#1-1-初识vue" class="headerlink" title="1.1 初识vue"></a>1.1 初识vue</h3><ul>
<li><p>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象</p>
</li>
<li><p>app容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法</p>
</li>
<li><p>app容器里的代码被称为【Vue模板】</p>
</li>
<li><p>Vue实例和容器是一一对应的,不能一对多和多对一</p>
</li>
<li><p>真实开发中只有一个Vue实例，并且会配合着组件一起使用</p>
</li>
<li>是Vue的语法：插值表达式，可以读取到data中的所有属性</li>
<li><p>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新(Vue实现的响应式)<br>代码：这里是直接引入开发版本的vue.js,可以去官网下载</p>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;01&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
容器和vue实例是一对一的，不能一对多和多对一
--&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;Hello,{{name}} {{op}} {{wifu}}&lt;/h1&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--关闭生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            name: 'ZQG',
            op: 'BC',
            wifu: 'YM'
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-2-模板语法"><a href="#1-2-模板语法" class="headerlink" title="1.2 模板语法"></a>1.2 模板语法</h3><p>Vue模板语法有2大类:</p>
<ul>
<li>插值语法：</li>
</ul>
<p>​    功能：用于解析<strong>标签体</strong>内容</p>
<p>​    写法：，xxx是js表达式，且可以直接读取到data中的所有属性</p>
<ul>
<li>指令语法:</li>
</ul>
<p>​    功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）</p>
<p>​    举例：v-bind:href=“xxx” 或 简写为 :href=“xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;模板语法&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;插值语法&lt;/h1&gt;
    &lt;h2&gt;Hello,{{name}}&lt;/h2&gt;
    &lt;hr/&gt;
    &lt;h1&gt;指令语法&lt;/h1&gt;
    &lt;a v-bind:href="link.url"&gt;去{{link.title}}&lt;/a&gt;
    &lt;!-- v-bind简写 --&gt;
    &lt;br/&gt;
    &lt;a :href="link.url"&gt;去{{link.title}}2&lt;/a&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            name: 'ZQG',
            link:{
                title: '百度',
                url: 'https://www.baidu.com'
            }

        }
    });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-3-数据绑定"><a href="#1-3-数据绑定" class="headerlink" title="1.3 数据绑定"></a>1.3 数据绑定</h3><p>Vue中有2种数据绑定的方式：</p>
<ul>
<li>单向绑定(v-bind)：数据只能从data流向页面</li>
<li>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data</li>
</ul>
<p>注意：</p>
<p>1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;模板语法&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    单向数据绑定：&lt;input type="text" v-bind:value="name"&gt;&lt;br/&gt;
    双向数据绑定：&lt;input type="text" v-model:value="name"&gt;&lt;br/&gt;

    &lt;!--    简写--&gt;
    单向数据绑定2：&lt;input type="text" :value="name"&gt;&lt;br/&gt;
    &lt;!-- 简写 v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值--&gt;
    双向数据绑定2：&lt;input type="text" v-model="name"&gt;&lt;br/&gt;
    
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            name: 'ZQG'
        }
    });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-4-el与data的两种写法"><a href="#1-4-el与data的两种写法" class="headerlink" title="1.4 el与data的两种写法"></a>1.4 el与data的两种写法</h3><p>el有2种写法</p>
<ul>
<li>new Vue时候配置el属性</li>
<li>先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值</li>
</ul>
<p>data有2种写法</p>
<ul>
<li><p>对象式</p>
</li>
<li><p>函数式</p>
<p>注意：在组件中，data必须使用函数式。一个重要原则：由Vue管理的函数不能是箭头函数，因为这样写this就不再是Vue实例了。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;el和data的两种写法&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;Hello,{{name}} &lt;/h1&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    //el的两种写法
    /*
    const vm = new Vue({
       // el: '#app',//第一种写法
        data: { //数据,给el 容器中的元素提供数据
            name: 'ZQG'
        }
    });
    console.log(vm);
    vm.$mount('#app') //第二种写法,挂载容器
*/
    // data的两种写法
    const vm2 = new Vue({
        el: '#app',
        // data: { //第一种写法，对象
        //     name: 'ZQG'
        // }

        // 第二种写法，函数式
        // data: function () {}
        data() {
            console.log(this)
            return {
                name: 'ZQG'
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
<h3 id="1-5-MVVM模型"><a href="#1-5-MVVM模型" class="headerlink" title="1.5 MVVM模型"></a>1.5 MVVM模型</h3><ul>
<li><p>M：模型(Model) ：data中的数据</p>
</li>
<li><p>V：视图(View) ：模板代码</p>
</li>
</ul>
<ul>
<li>VM：视图模型(ViewModel)：Vue实例</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/02f5aad7bfc440789dfa852b370f740d.webp" alt="mvvm"></p>
<p>data中的所有属性都在vm中。</p>
<p>vm的所有属性，包括Vue原型上所有属性，Vue模板都可以直接使用。</p>
<h3 id="1-6-数据代理"><a href="#1-6-数据代理" class="headerlink" title="1.6 数据代理"></a>1.6 数据代理</h3><p>通过一个对象代理对另一个对象中的属性的操作(读/写)。</p>
<p>主要通过js方法：Object.defineProperty()实现的，需要先去了解Object.defineProperty()相关知识，属性标志，属性描述符，getter，setter.</p>
<p>简单介绍一下：</p>
<p>属性标志:</p>
<p>对象属性（properties），除 value 外，还有三个特殊的特性（attributes），也就是所谓的“标志”</p>
<p>writable — 如果为 true，则值可以被修改，否则它是只可读的，默认为false<br>enumerable — 如果为 true，则表示是可以遍历的，可以在for… .in Object.keys()中遍历出来，默认为false<br>configurable — 如果为 true，则此属性可以被删除，这些特性也可以被修改，否则不可以，默认为false</p>
<pre><code class="javascript">&lt;script type="text/javascript"&gt;
    let num = 18;
    let person = {
        name: 'ZQG',
        //age: 18,
        sex: '男'
    };
    Object.defineProperty(person, 'age',{
         value: num,
        // enumerable: true, // 是否可枚举，默认为false
        // configurable: true,// 是否可以删除,默认为false
        // writable: true// 能否修改,默认为false
    })
  console.log(person);
&lt;/script&gt;
</code></pre>
<p>如图：</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123165409650.png" alt="image-20250123165409650"></p>
<p>如果不将相应的配置设置为true，修改不起作用，删除也返回false，也无法枚举。</p>
<p>使用getter和setter时：</p>
<pre><code class="javascript">&lt;script type="text/javascript"&gt;
    let num = 18;
    let person = {
        name: 'ZQG',
        //age: 18,
        sex: '男'
    };
    Object.defineProperty(person, 'age',{
         //value: num,
        // enumerable: true, // 是否可枚举，默认为false
        // configurable: true,// 是否可以删除,默认为false
        // writable: true// 能否修改,默认为false
        get() {
            console.log('读取age属性');//person.age 起作用
            return num;
        },
        set(value) {
            console.log('设置age属性,值是：', value);//person.age = 20 起作用
            num = value;
        }
    })
  console.log(person);
&lt;/script&gt;
</code></pre>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123170003588.png" alt="image-20250123170003588"></p>
<p>每次访问person.age时，会触发getter函数，返回num值；当设置person.age = xx值时，会把值设置给num，这样再次读取会返回最新的num值，（直接设置num值，获取age值也是返回设置后的num值）这样就实现了数据代理。</p>
<p><strong>Vue中的数据代理</strong></p>
<p>Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写）<br>Vue中数据代理的好处：更加方便的操作data中的数据<br>基本原理：<br>通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>为每一个添加到vm上的属性，都指定一个getter/setter。<br>在getter/setter内部去操作（读/写）data中对应的属性。</p>
<p>我们代码中的data实际和Vue实例中的_data是相等的，所以取值，Vue为了代码写的方便，通过数据代理将_data的属性值，直接放在vm中，所以直接取值用就可以了。</p>
<p>验证代码：为了验证data和我们代码中的数据（person）是一样的，所以把person定义在外面，这样可以直接可以_data==person作比较</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;数据代理&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;Hello,{{name}},{{age}},{{sex}}&lt;/h1&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    let person = {
        name: 'ZQG',
        age: 18,
        sex: '男'
    };
  const vm = new Vue({
      el: '#app',
      data: person
  });
  console.log(vm)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123175247017.png" alt="image-20250123175247017"></p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123175508777.png" alt="image-20250123175508777"></p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250123175744591.png" alt="image-20250123175744591"></p>
<h3 id="1-7-事件处理"><a href="#1-7-事件处理" class="headerlink" title="1.7 事件处理"></a>1.7 事件处理</h3><p>事件的基本使用：</p>
<ul>
<li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名</li>
<li>事件的回调需要配置在methods对象中，最终会在vm上</li>
<li>methods中配置的函数不要用箭头函数，这会导致this不再是vm了</li>
<li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象</li>
<li>@click=”show” 和@click=”show($event)”，效果一致，但是后者可以传参</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;事件处理&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;Hello,{{name}}，欢迎来到{{address}}&lt;/h1&gt;
    &lt;button v-on:click="showInfo"&gt;点我&lt;/button&gt;
    &lt;button @click="showInfo"&gt;点我2（不传参）&lt;/button&gt;
    &lt;button @click="showInfo3($event,666)"&gt;点我3（传参）&lt;/button&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',
        data: {
            name: 'ZQG',
            address: '支配剧场'
        },
        methods: {
            showInfo: function (event) {
                alert('Hello,Vue!');
                console.log(event);// event对象
                console.log(this);// this指向当前Vue实例
            },
            showInfo3(event, num) {
                console.log(event.target.innerText);// event对象
                //console.log(this);// this指向当前Vue实例
                alert(num)
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Vue中的事件修饰符</p>
<ul>
<li>prevent：阻止默认事件（常用）</li>
<li>stop：阻止事件冒泡（常用）</li>
<li>once：事件只触发一次（常用）</li>
<li>capture: 使用事件的捕获模式</li>
<li>self: 只有event.target是当前的操作元素时才触发事件</li>
<li>passive: 事件的默认行为立即执行，无需等待事件回调完毕</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;事件处理&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
    &lt;style type="text/css"&gt;
        * {
            margin-top: 10px;
        }
        .dd{
            width: 100px;
            height: 80px;
            background-color: red;
        }
        .aa{
            width: 100px;
            height: 60px;
            background-color: skyblue;
        }
        .bb{
            width: 100px;
            height: 20px;
            background-color: green;
        }
        .ll{
            width: 150px;
            height: 100px;
            background-color: orange;
            overflow: auto;
        }
        li{
            height: 50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;Hello,{{name}}，欢迎来到{{address}}&lt;/h1&gt;
    &lt;!--    阻止事件--&gt;
    &lt;a href="https://www.baidu.com" @click.prevent="showInfo"&gt;点我跳转&lt;/a&gt;

    &lt;div class="dd" @click="showInfo"&gt;
        &lt;!--   阻止事件冒泡     --&gt;
       &lt;button @click.stop="showInfo"&gt;点我&lt;/button&gt;
         &lt;!--   修饰符可以连续写--&gt;
        &lt;a href="https://www.baidu.com" @click.prevent.stop="showInfo"&gt;点我跳转&lt;/a&gt;
    &lt;/div&gt;
    &lt;!--    事件只触发一次--&gt;
    &lt;button @click.once="showInfo"&gt;点我&lt;/button&gt;
    &lt;!-- 原本： 事件捕获=》事件冒泡（调用）,所以打印2再打印1. 使用capture后：在捕获的时候就会调用，此时先打印1后打印2 --&gt;
    &lt;div class="aa" @click.capture="showMsg(1)"&gt;
        div1
        &lt;div class="bb" @click="showMsg(2)"&gt;
            div2
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="dd" @click.self="showInfo"&gt;
        &lt;!--   只有event.target是当前的操作元素时才触发事件     --&gt;
        &lt;button @click="showInfo"&gt;点我&lt;/button&gt;
    &lt;/div&gt;

&lt;!--    @scroll 滚动条,@wheel 鼠标滚轮--&gt;
    &lt;ul @wheel.passive="work" class="ll"&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        &lt;li&gt;4&lt;/li&gt;
    &lt;/ul&gt;

&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',
        data: {
            name: 'ZQG',
            address: '支配剧场'
        },
        methods: {
            showInfo: function (event) {
                alert('Hello,Vue!');
                console.log(event);// event对象
                console.log(this);// this指向当前Vue实例
            },
            showMsg: function (msg) {
                alert(msg);
            },
            work: function (event) {
                for (let i = 0; i &lt; 10000; i++) {
                    console.log('#');
                }
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-8-键盘事件"><a href="#1-8-键盘事件" class="headerlink" title="1.8 键盘事件"></a>1.8 键盘事件</h3><p>键盘事件语法糖：@keydown，@keyup</p>
<p>1.Vue中常用的按键别名：</p>
<ul>
<li>回车 =&gt; enter</li>
<li>删除 =&gt; delete(捕获删除和退格键)</li>
<li>退出 =&gt; esc</li>
<li>空格 =&gt; space</li>
<li>换行 =&gt; tab (特殊，必须配合keydown去使用)</li>
<li>上 =&gt; up</li>
<li>下 =&gt;down</li>
<li>左 =&gt;left</li>
<li>右 =&gt;right</li>
</ul>
<p>2.Vue未提供别名的键，可以使用按键的原始key值去绑定,但是要注意转为kebab-case（短横线命名）</p>
<p>3.系统修饰键(用法特殊):ctrl,alt,shift,meta</p>
<p>​	3.1配合keyup使用：按下修饰键的同时，再按下其他键，随后释放，事件才会触发</p>
<p>​	3.2配合keydown使用：正常触发</p>
<p>4.可以使用keyCode去指定具体的按键（不推荐）</p>
<p>5.Vue.config.keyCode.自定义键名=键码，可以定制按键别名</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;键盘事件&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h1&gt;Hello,{{name}}&lt;/h1&gt;
    &lt;input type="text" placeholder="按下回车提示输入" @keyup="showInfo"&gt;
    &lt;input type="text" placeholder="按下tab提示输入" @keydown.tab="showInfo"&gt;
        &lt;!--  连写 ctrl + y --&gt;
    &lt;input type="text" placeholder="按下ctrl提示输入" @keyup.ctrl.y="showInfo"&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    Vue.config.keyCodes.dsb = 13;//自定义按键,dsb替换成enter @keyup.dsb="",不推荐使用
    let person = {
        name: 'ZQG'
    };
  new Vue({
      el: '#app',
      data: person,
      methods: {
          showInfo(e) {
              console.log(e.key,e.keyCode,e.target.value)
          }
      }
  });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9 计算属性"></a>1.9 计算属性</h3><p>定义：要用的属性不存在，要通过已有属性计算得来。<br>原理：底层借助了Objcet.defineProperty方法提供的getter和setter<br>get函数什么时候执行？<br>(1).初次读取时会执行一次<br>(2).当依赖的数据发生改变时会被再次调用<br>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便<br>备注：<br>计算属性最终会出现在vm上，直接读取使用即可<br>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;姓名案例&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    姓: &lt;input type="text" v-model="firstName"/&gt;&lt;br&gt;
    名：&lt;input type="text" v-model="lastName"/&gt;&lt;br&gt;
    全名：&lt;span&gt;{{fullName}}&lt;/span&gt;&lt;br&gt;
    全名：&lt;span&gt;{{fullName2}}&lt;/span&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            firstName: 'ZQG',
            lastName: 'YM'
        },
        computed:{
            fullName:{
                //初次读取fullName时，get方法会调用一次
                // 所依赖的数据发生变化时，get方法会调用一次
                //其他情况，会读取缓存的数据
                get(){
                    console.log('get调用');
                    console.log(this);
                    return this.firstName + '-' + this.lastName;
                },
                //set方法不是必须写的，如果计算属性确定没有修改的场景，可以不写set
                // 当fullName被修改时，set方法会调用一次
                set(value){
                    const names = value.split('-');
                    this.firstName = names[0];
                    this.lastName = names[1];
                }
            },
            //简写，不包含set方法
            fullName2() {
                return this.firstName + '-' + this.lastName;
            }
        }


    });

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-10-监视属性"><a href="#1-10-监视属性" class="headerlink" title="1.10 监视属性"></a>1.10 监视属性</h3><p>监视属性watch：</p>
<ul>
<li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li>
<li>监视的属性必须存在，才能进行监视</li>
<li>监视的两种写法：<ul>
<li>(1).new Vue时传入watch配置</li>
<li>(2).通过vm.$watch监视</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;天气案例&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
容器和vue实例是一对一的，不能一对多和多对一
--&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
    &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            isHot: true,
        },
        computed: {
            info() {
                return this.isHot ? '炎热' : '凉爽';
            }
        },
        methods: {
            changeWeather() {
                this.isHot = !this.isHot;
            }

        },
        watch: {
            isHot: {
                // 监听isHot属性的变化
                handler(newValue, oldValue) {
                    console.log('isHot', newValue, oldValue);
                },
                immediate: true, //初始化时执行handler,默认false
                deep: true //深度监听
            },
            //简写，不需要immediate，deep时
            // 监听isHot属性的变化
            isHot(newValue, oldValue) {
                console.log('isHot', newValue, oldValue);
            }

            //info，计算属性也可以被监听
            // info: {
            //     // 监听info属性的变化
            //     handler(newValue, oldValue) {
            //         console.log('info', newValue, oldValue);
            //     },
            //     immediate: true, //初始化时执行handler,默认false
            //     deep: true //深度监听
            // }
        }
    });
    // 监听isHot属性的变化
   /* vm.$watch('isHot', {
        handler(newValue, oldValue) {
            console.log('isHot', newValue, oldValue);
        },
        immediate: true, //初始化时执行handler,默认false
        deep: true //深度监听
    });
  */
    //简写，不需要配置immediate，deep时
    vm.$watch('isHot',function (newValue, oldValue) {
        console.log('isHot改变了', newValue, oldValue);
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>(1).Vue中的watch默认不监测对象内部值的改变（一层）<br>(2).配置deep:true可以监测对象内部值改变（多层）<br>备注：</p>
<p>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以</p>
<p>(2).使用watch时根据数据的具体结构，决定是否采用深度监视</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;天气案例-深度监视&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
容器和vue实例是一对一的，不能一对多和多对一
--&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
    &lt;button @click="changeWeather"&gt;切换天气&lt;/button&gt;
    &lt;hr&gt;
    &lt;h2&gt;a的值是{{num.a}}&lt;/h2&gt;
    &lt;button @click="num.a++"&gt;点我a+1&lt;/button&gt;
    &lt;hr&gt;
    &lt;h2&gt;b的值是{{num.b}}&lt;/h2&gt;
    &lt;button @click="num.b++"&gt;点我b+1&lt;/button&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            isHot: true,
            num:{
                a:1,
                b:2
            }
        },
        computed: {
            info() {
                return this.isHot ? '炎热' : '凉爽';
            }
        },
        methods: {
            changeWeather() {
                this.isHot = !this.isHot;
            }

        },
        watch: {
            isHot: {
                // 监听isHot属性的变化
                handler(newValue, oldValue) {
                    console.log('isHot', newValue, oldValue);
                },
                immediate: true, //初始化时执行handler,默认false
                deep: true //深度监听
            },
            // 监听多级结构中某个属性，num.a属性的变化
            'num.a':{
                handler(newValue, oldValue) {
                    console.log('num.a改变了', newValue, oldValue);
                },
            },
            // 监听多级结构中所有属性的变化
            num:{
                handler(newValue, oldValue) {
                    console.log("num改变了");
                },
                deep: true//深度监听
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>computed和watch之间的区别：</p>
<p>computed能完成的功能，watch都可以完成<br>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作<br>两个重要的小原则：</p>
<p>1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象</p>
<p>2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;姓名案例-watch写法&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    姓: &lt;input type="text" v-model="firstName"/&gt;&lt;br&gt;
    名：&lt;input type="text" v-model="lastName"/&gt;&lt;br&gt;
    全名：&lt;span&gt;{{fullName}}&lt;/span&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            firstName: 'ZQG',
            lastName: 'YM',
            fullName: 'ZQG-YM'
        },
       watch:{
            firstName(newValue,oldValue){
                setTimeout(()=&gt;{
                    this.fullName = newValue +'-'+ this.lastName;
                },1000)
            },
            lastName(newValue,oldValue){
                this.fullName = this.firstName +'-'+ newValue;
            }
       }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-11-绑定样式"><a href="#1-11-绑定样式" class="headerlink" title="1.11 绑定样式"></a>1.11 绑定样式</h3><h4 id="class样式"><a href="#class样式" class="headerlink" title="class样式"></a><strong>class样式</strong></h4><p>写法：:class=“xxx” xxx可以是字符串、对象、数。</p>
<p>所以分为三种写法，字符串写法，数组写法，对象写法</p>
<p><strong>字符串写法</strong></p>
<p>字符串写法适用于：类名不确定，要动态获取。</p>
<p><strong>数组写法</strong></p>
<p>数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<p><strong>对象写法</strong></p>
<p>对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<h4 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a><strong>style样式</strong></h4><p>有两种写法，对象写法，数组写法.</p>
<p>:style = “{forntSize:xxx}” ,xxx时动态值</p>
<p>:style=”[a,b]”  a,b是样式对象</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;绑定样式&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        .basic{
            text-align: center;
            width: 400px;
            height: 100px;
            border: 1px solid black;
        }
        .happy{
            background-color: yellow;
            border: 4px solid red;
        }
        .sad{
            border: 4px solid blue;
            background-color: gray;
        }
        .normal{
            background-color: skyblue;
        }
        .zqg1{
            background-color: yellowgreen;
        }
        .zqg2{
            font-size: 30px;
            text-shadow:2px 2px 10px red;
        }
        .zqg3{
            border-radius: 20px;
        }

    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
&lt;!--    字符串写法，适用于：类名不确定，要动态获取--&gt;
    &lt;div class="basic" :class="mood" @click="changeMood"&gt;{{name}}&lt;/div&gt;
    &lt;br/&gt;
&lt;!--   数组写法，适用于：要绑定多个样式，个数不确定，名字也不确定--&gt;
    &lt;div class="basic" :class="arr"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;
&lt;!--    对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用--&gt;
    &lt;div class="basic" :class="classObj"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;

    &lt;div class="basic" :style="styleObj"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;

    &lt;div class="basic" :style="styleArr"&gt;{{name}}&lt;/div&gt;&lt;br/&gt;

&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            name: 'ZQG',
            mood:'normal',
            arr:['zqg1','zqg2','zqg3'],
            classObj:{
                zqg1:true,
                zqg2:false,
                zqg3:true
            },
            styleObj:{
                color:'red',
                fontSize:'35px',
                backgroundColor:'orange'
            },
            styleArr:[{color:'blue', fontSize: '45px'},{backgroundColor:'gray'}]
        },
        methods: {
            changeMood: function () {
                const arr = ['happy', 'sad','normal'];
                this.mood = arr[Math.floor(Math.random() * arr.length)];
            }
        }

    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-12-条件渲染"><a href="#1-12-条件渲染" class="headerlink" title="1.12 条件渲染"></a>1.12 条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>写法：</p>
<p>(1).v-if=“表达式”</p>
<p>(2).v-else-if=“表达式”</p>
<p>(3).v-else=“表达式”</p>
<p>适用于：切换频率较低的场景</p>
<p>特点：不展示的DOM元素直接被移除</p>
<p>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”</p>
<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><strong>v-show</strong></h4><ul>
<li>写法：v-show=“表达式”</li>
<li>适用于：切换频率较高的场景</li>
<li>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉(display:none)</li>
</ul>
<p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到;v-if 是实打实地改变dom元素，v-show 是隐藏或显示dom元素</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;条件渲染&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2 v-show="condition"&gt;你好，{{name}}&lt;/h2&gt;
    &lt;br/&gt;
    &lt;h2 v-show="1===1"&gt;你好，{{name}}&lt;/h2&gt;
    &lt;hr&gt;
    &lt;h2 v-if="1===1"&gt;你好，{{name}}&lt;/h2&gt;

    &lt;hr&gt;
    &lt;h2&gt;当前i的值是：{{i}}&lt;/h2&gt;
    &lt;button @click="i++"&gt;点我++&lt;/button&gt;
    &lt;div v-if ="i === 1"&gt;Angular&lt;/div&gt;
    &lt;div v-else-if ="i === 2 "&gt;React&lt;/div&gt;
    &lt;div v-else-if="i === 3"&gt;Vue&lt;/div&gt;
    &lt;div v-else&gt;666&lt;/div&gt;

&lt;!--  template只能和v-if配合使用  --&gt;
    &lt;template v-if="i === 4"&gt;
        &lt;h2&gt;zqg&lt;/h2&gt;
        &lt;h2&gt;bc&lt;/h2&gt;
        &lt;h2&gt;ym&lt;/h2&gt;
    &lt;/template&gt;

&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
            name: 'ZQG',
            condition: true,
            i: 0
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-13-列表渲染"><a href="#1-13-列表渲染" class="headerlink" title="1.13 列表渲染"></a>1.13 列表渲染</h3><h4 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h4><ul>
<li>用于展示列表数据</li>
<li>语法：v-for=“(item, index) in xxx” :key=“yyy”</li>
<li>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;列表渲染&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
 &lt;ul&gt;
     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;
     &lt;hr/&gt;
     &lt;li v-for="(p,index) in persons" :key="index"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;
 &lt;/ul&gt;
    &lt;hr/&gt;
    &lt;h2&gt;汽车信息&lt;/h2&gt;
    &lt;li v-for="(value,key,index) in car" :key="key"&gt;
        {{index}}-{{key}}-{{value}}
    &lt;/li&gt;
    &lt;hr/&gt;
    &lt;h2&gt;字符串信息&lt;/h2&gt;
    &lt;li v-for="(value,index) in str" :key="index"&gt;
        {{index}}--{{value}}
    &lt;/li&gt;
    &lt;hr&gt;
    &lt;h2&gt;遍历次数&lt;/h2&gt;
    &lt;li v-for="(value,index) in 5" :key="index"&gt;
        {{index}} -- {{value}}
    &lt;/li&gt;

&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
           persons: [
               {id: '001', name: 'zqg', age: 18},
               {id: '002', name: 'bc',age: 19},
               {id: '003', name: 'ym',age: 20},
           ],
            car: {
                name: '奔驰',
                price: '1000000',
                color: '黑色'
            },
            str: 'hello world'
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="key的原理"><a href="#key的原理" class="headerlink" title="key的原理"></a>key的原理</h4><p>可以先了解一下虚拟DOM和真实DOM，以及它们之间的差异：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903895467032589">深入剖析：Vue核心之虚拟DOM使用 Vue 做项目也有两年时间了，对 Vue 的 api也用的比较得心应手了，虽然对 - 掘金</a></p>
<p><strong>虚拟DOM中key的作用</strong></p>
<p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<ol>
<li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p>
<p>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
</li>
<li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key:</p>
<p>创建新的真实DOM，随后渲染到到页面。</p>
</li>
</ol>
<p>	</p>
<p><strong>用index作为key可能会引发的问题：</strong></p>
<ol>
<li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作：</p>
<p>会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p>
</li>
<li><p>如果结构中还包含输入类的DOM：</p>
<p>会产生错误DOM更新==&gt;界面有问题。</p>
</li>
</ol>
<p><strong>开发中如何选择key：</strong></p>
<ol>
<li>最好使用每条数据的唯一标识作为key，如id，身份证号，手机号，学号等。</li>
<li>如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表展示，可以使用index作为key。</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;列表渲染-key的原理&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;button @click.once="add"&gt;添加一个老张&lt;/button&gt;
 &lt;ul&gt;
     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}} &lt;input type="text"&gt;&lt;/li&gt;
     &lt;hr/&gt;
     &lt;li v-for="(p,index) in persons" :key="index"&gt;{{p.name}}-{{p.age}} &lt;input type="text"&gt;&lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
           persons: [
               {id: '001', name: 'zqg', age: 18},
               {id: '002', name: 'bc',age: 19},
               {id: '003', name: 'ym',age: 20},
           ]
        },
        methods: {
            add() {
                const p = {id: '004', name: '老张', age: 30};
                this.persons.unshift(p);
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Vue中key原理图：</p>
<p>index作为key时：注意，如果不指定key，Vue会默认用index作为key。</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250210160230853.png" alt="image-20250210160230853"></p>
<p>因为老刘被插到第一个，重刷了 key 的值，vue Diff 算法根据 key 的值判断虚拟DOM 全部发生了改变，然后全部重新生成新的真实 DOM（key所对应的input输入框，算法比对是一样的，所以直接复用了，这导致页面上输入框对不上）。实际上，张三，李四，王五并没有发生更改，是可以直接复用之前的真实 DOM，而因为 key 的错乱，导致要全部重新生成，造成了性能的浪费。</p>
<p>使用唯一标识作为key时：</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250210160037121.png" alt="image-20250210160037121"></p>
<h3 id="1-14-列表过滤"><a href="#1-14-列表过滤" class="headerlink" title="1.14 列表过滤"></a>1.14 列表过滤</h3><p>watch和computed都可以实现，computed更简单方便</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;列表过滤&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type="text" v-model="keyword" placeholder="请输入名字"&gt;
 &lt;ul&gt;
     &lt;li v-for="p in filterPersons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
           persons: [
               {id: '001', name: '马冬梅', age: 18},
               {id: '002', name: '周冬雨',age: 19},
               {id: '003', name: '周杰伦',age: 20},
               {id: '004', name: '温兆伦',age: 25}
           ],
            //filterPersons:[],
            keyword: ''
        },
        computed: {
            filterPersons() {
                return this.persons.filter(p =&gt; p.name.indexOf(this.keyword) !== -1);
            }
        },
        /*
        watch: {
            keyword:{
                immediate: true,
                handler(newValue, oldValue) {
                    this.filterPersons = this.persons.filter(p =&gt; p.name.indexOf(newValue) !== -1);
                }
            }
        }
        */
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-15-列表排序"><a href="#1-15-列表排序" class="headerlink" title="1.15 列表排序"></a>1.15 列表排序</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;列表排序&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type="text" v-model="keyword" placeholder="请输入名字"&gt;
    &lt;button @click="sortType=1"&gt;年龄升序&lt;/button&gt;
    &lt;button @click="sortType=2"&gt;年龄降序&lt;/button&gt;
    &lt;button @click="sortType=0"&gt;原顺序&lt;/button&gt;
 &lt;ul&gt;
     &lt;li v-for="p in filterPersons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;
     &lt;hr/&gt;
 &lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
           persons: [
               {id: '001', name: '马冬梅', age: 28},
               {id: '002', name: '周冬雨',age: 19},
               {id: '003', name: '周杰伦',age: 20},
               {id: '004', name: '温兆伦',age: 25}
           ],
            keyword: '',
            sortType:0 //0:原顺序，1：升序，2：降序
        },
        computed: {
            filterPersons() {
                return this.persons.filter(p =&gt; p.name.indexOf(this.keyword) !== -1).sort(
                    (p1, p2) =&gt; {
                        if (this.sortType === 1) {
                            return p1.age - p2.age;
                        } else if (this.sortType === 2) {
                            return p2.age - p1.age;
                        } else {
                            return 0;
                        }
                    }
                );
            }
        },

    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-16-Vue监测数据的原理"><a href="#1-16-Vue监测数据的原理" class="headerlink" title="1.16 Vue监测数据的原理"></a>1.16 Vue监测数据的原理</h3><h4 id="监测对象数据："><a href="#监测对象数据：" class="headerlink" title="监测对象数据："></a>监测对象数据：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;更新时的问题&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--准备好一个容器--&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;button @click="updateYm"&gt;更新ym&lt;/button&gt;
 &lt;ul&gt;
     &lt;li v-for="p in persons" :key="p.id"&gt;{{p.name}}-{{p.age}}&lt;/li&gt;
 &lt;/ul&gt;
    &lt;button @click="addGender"&gt;添加性别&lt;/button&gt;
    &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt;
    &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt;
    &lt;h3&gt;性别：{{student.gender}}&lt;/h3&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    &lt;!--生产环境提示--&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el: '#app',//挂载点，指定当前vue示例为哪个容器服务，值通常为css选择器字符串
        data: { //数据,给el 容器中的元素提供数据
           persons: [
               {id: '001', name: 'zqg', age: 18},
               {id: '002', name: 'bc',age: 19},
               {id: '003', name: 'ym',age: 20},
           ],
            student:{
                name:'lyf',
                age:18
            }
        },
        methods:{
            updateYm(){
                //this.persons[2].name = 'lyf' //成功，生效
                this.persons[0]={id: '001', name: 'zzz', age: 10}//失效，因为vue对数组的变更进行了监听，如果直接修改数组中的某一个对象，vue是无法知道这个数组发生了变化，所以需要使用数组的方法进行操作，如：push、pop、shift、unshift、splice等
            },
            addGender(){
                //Vue.set(this.student,'gender','男')
                this.$set(this.student,'gender','女')
            }
        }
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>现象：直接修改person数组中某个对象的某个属性值室，Vue可以监测到并解析模板重新渲染，但是把某个对象改了（替换），代码是执行了，内存中的数据夜修改成功了，但是页面没有变化，说明Vue没有监测到。</p>
<p>Vue 监测数据变化的原理：</p>
<p>加工data中的数据（主要是添加响应式的getter和setter方法，用的是Object.defineProperty()方法）==&gt;把加工后的对象传给_data,也就是vm._data = data  ==&gt; 属性值改变会调用set方法，在set方法中去解析模板，生成虚拟DOM，新旧DOM比较，更新页面。</p>
<p>简单模拟实现一下：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;模拟数据监测&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript" &gt;
    let data = {
        name:'zqg',
        address:'bj',
    }
    //创建一个监视的实例对象，用于监视data中属性的变化，（Vue实际做的更多，更完善）
    const obs = new Observer(data)
    console.log(obs)
    //准备一个vm实例对象
    let vm = {}
    vm._data = data = obs
    
    function Observer(obj){
        //汇总对象中所有的属性形成一个数组
        const keys = Object.keys(obj)
        //遍历
        keys.forEach((k) =&gt; {
            Object.defineProperty(this, k, {
                get() {
                    return obj[k]
                },
                set(val) {
                    console.log(`${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)
                    obj[k] = val
                }
            })
        })
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.set 的使用</strong></p>
<p>Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index，value)</p>
<p>用法：</p>
<p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式<strong>对象</strong>上添加新 property，因为 Vue 无法探测普通的新增 property (比如 vm.myObject.newProperty = ‘xx’)</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250212180852337.png" alt="image-20250212180852337"></p>
<h4 id="监测数组："><a href="#监测数组：" class="headerlink" title="监测数组："></a>监测数组：</h4><p>vue 没有为数组中的元素生成 getter 和 setter，所以监测不到数据的更改（根据index替换元素的值），也不会引起页面的更新。</p>
<p>想要Vue监测到数据变化，需要使用数组的方法进行操作，如：push、pop、shift、unshift、splice等。（这些方法已经被Vue包装了）</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250213112714047.png" alt="image-20250213112714047"></p>
<p>除了用数组方法，当然还可以用Vue.set()或者vm.$set()来修改数组元素。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>Vue监视数据的原理：</strong></p>
<p>vue会监视data中所有层次的数据。</p>
<p><strong>如何监测对象中的数据？</strong></p>
<p>通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<p>对象中后追加的属性，Vue默认不做响应式处理，如需给后添加的属性做响应式，请使用如下API：</p>
<p>Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index，value)</p>
<p><strong>如何监测数组中的数据？</strong></p>
<p>通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<p>1、调用原生对应的方法对数组进行更新<br>2、重新解析模板，进而更新页面<br><strong>在Vue修改数组中的某个元素一定要用如下方法：</strong></p>
<p>1、使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>2、Vue.set() 或 vm.$set()</p>
<p><strong>注意：Vue.set() 或 vm.$set() 不能给vm对象和根数据对象_data，添加响应式的属性。</strong></p>
<h3 id="1-17-收集表单数据"><a href="#1-17-收集表单数据" class="headerlink" title="1.17 收集表单数据"></a>1.17 收集表单数据</h3><p>若：&lt;input type=”text”/&gt;，则v-model收集的是value值，用户输入的就是value值。</p>
<p>若：&lt;input type=”radio”/&gt;，则v-model收集的是value值，且要给标签配置value值。</p>
<p>若：&lt;input type=”checkbox”/&gt;</p>
<p>没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>配置input的value属性:<br>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>v-model的初始值是数组，那么收集的的就是value组成的数组。</p>
<p>备注：v-model的三个修饰符：</p>
<p>lazy：失去焦点再收集数据</p>
<p>number：输入字符串转为有效的数字</p>
<p>trim：输入首尾空格过滤</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type="text/javascript" src="js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;form @submit="submitForm"&gt;
        &lt;label for = "userName"&gt;账号：&lt;/label&gt;
        &lt;input type="text" id="userName" v-model.trim="userInfo.userName"&gt;&lt;br&gt;
        &lt;label for="password"&gt;密码：&lt;/label&gt;
        &lt;input type="password" id="password" v-model="userInfo.password"&gt;&lt;/input&gt;&lt;br&gt;
        &lt;br&gt;
        性别：
        男&lt;input type="radio" name="sex" value="1" v-model="userInfo.sex"&gt;
        女&lt;input type="radio" name="sex" value="0" v-model="userInfo.sex"&gt;&lt;br&gt;
        &lt;br&gt;
        年龄: &lt;input type="number" v-model.number="userInfo.age"&gt;&lt;br&gt;&lt;br&gt;
        爱好：
        打游戏&lt;input type="checkbox" name="hobby" value="game" v-model="userInfo.hobby"&gt;
        看电影&lt;input type="checkbox" name="hobby" value="movie" v-model="userInfo.hobby"&gt;
        跑步&lt;input type="checkbox" name="hobby" value="run" v-model="userInfo.hobby"&gt;
        &lt;br&gt;
        &lt;br&gt;
        学历：
        &lt;select name="userInfo.education" &gt;
            &lt;option value="大专"&gt;大专&lt;/option&gt;
            &lt;option value="本科"&gt;本科&lt;/option&gt;
            &lt;option value="硕士"&gt;硕士&lt;/option&gt;
            &lt;option value="博士"&gt;博士&lt;/option&gt;
        &lt;/select&gt;
        &lt;br&gt;
        &lt;br&gt;
        &lt;label for="birthday"&gt;出生日期：&lt;/label&gt;
        &lt;input type="date" id="birthday" v-model="userInfo.birthday"&gt;&lt;br&gt;&lt;/input&gt;
        &lt;br&gt;
        其他信息：
        &lt;textarea name="otherInfo" cols="30" rows="10" v-model.lazy="userInfo.otherInfo"&gt;&lt;/textarea&gt;
        &lt;br&gt;
        &lt;br&gt;
        &lt;input type="checkbox" name="agree" value="agree" v-model="userInfo.agree"&gt;&lt;/input&gt;
        阅读并接受&lt;a href="https://zhangqingguo.github.io/"&gt;《用户协议》&lt;/a&gt;
        &lt;br&gt;
        &lt;br&gt;
        &lt;button type="submit"&gt;提交&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    const vm = new Vue({
        el: '#app',
        data: {
            userInfo: {
                userName: '',
                password: '',
                sex: '',
                age: null,
                hobby: [],
                education: '',
                birthday: '',
                otherInfo: '',
                agree: false
            }
        },
        methods: {
            submitForm(e) {
                e.preventDefault();
                console.log(this.userInfo.userName);
                console.log(JSON.stringify(this.userInfo))
            }
        }
    })

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-18-过滤器使用"><a href="#1-18-过滤器使用" class="headerlink" title="1.18 过滤器使用"></a>1.18 过滤器使用</h3><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p>
<p><strong>语法：</strong></p>
<ul>
<li>注册过滤器：<strong>Vue.filter(name,callback)</strong>   ==》全局过滤器  或 <strong>new Vue{filters:{}}</strong>  ==》局部过滤器</li>
<li>使用过滤器：{ { xxx | 过滤器名} } 或 v-bind:属性 = “xxx | 过滤器名”</li>
</ul>
<p>备注：</p>
<p>1.过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>2.并没有改变原本的数据, 是产生新的对应的数据。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="./js/dayjs.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;显示格式化时间&lt;/h2&gt;
    现在是：{{time}}&lt;br&gt;
    &lt;!--计算属性--&gt;
    现在是：{{formatTime}}&lt;br&gt;
    &lt;!-- 方法--&gt;
    现在是：{{getTime()}}&lt;br&gt;
    &lt;!--过滤器--&gt;
    现在是：{{time | timeFormater}}&lt;br&gt;
    &lt;!--过滤器传参--&gt;
    现在是：{{time | timeFormater('YYYY年MM月DD日 HH:mm:ss')}}&lt;br&gt;
    &lt;!--多个过滤器串联使用--&gt;
    现在是：{{time | timeFormater('YYYY年MM月DD日 HH:mm:ss') | strSplice(0,11)}}&lt;br&gt;
    &lt;!--v-bind使用--&gt;
    &lt;h3 :x="mag | strSplice(0,5)"&gt;zzz&lt;/h3&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    // 全局 过滤器
    Vue.filter('timeFormater', function (value, str = 'YYYY-MM-DD HH:mm:ss') {
        return dayjs(value).format(str)
    })
    const vm = new Vue({
        el: '#app',
        data: {
            time: Date.now(),
            mag: 'hello world'
        },
        // 计算属性
        computed: {
            formatTime() {
                return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        // 方法
        methods: {
            getTime() {
                return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        // 局部的 过滤器
        filters: {
            timeFormater(value, str = 'YYYY-MM-DD HH:mm:ss') {
                console.log('value=', value)
                return dayjs(value).format(str)
            },
            strSplice(value, start, end) {
                return value.substring(start, end)
            }
        }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-19-内置指令"><a href="#1-19-内置指令" class="headerlink" title="1.19 内置指令"></a>1.19 内置指令</h3><p>已经学过的指令：</p>
<pre><code>v-bind:属性绑定,单向数据绑定，简写为 :xxx
v-model:双向数据绑定
v-on:事件绑定,监听，简写为 @
v-if:条件渲染，动态控制节点是否存在
v-else:条件渲染，动态控制节点是否存在
v-show:条件渲染，动态控制节点是否显示
v-for:循环渲染，遍历数组/对象/字符串
</code></pre>
<p><strong>v-text指令：</strong></p>
<p>1.作用：向其所在的节点中渲染文本内容。</p>
<p>2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。</p>
<p><strong>v-html指令：</strong></p>
<p>1.作用：向指定节点中渲染包含html结构的内容。</p>
<p>2.与插值语法的区别：</p>
<p>v-html会替换掉节点中所有的内容，则不会。<br>v-html可以识别html结构。<br>3.严重注意：v-html有安全性问题！！！！</p>
<p>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p>
<p><strong>v-cloak指令：</strong></p>
<ul>
<li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li>
<li>使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题(未解析的模板，直接展示影响用户体验)。</li>
</ul>
<p><strong>v-once指令：</strong></p>
<ul>
<li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li>
<li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li>
</ul>
<p><strong>v-pre指令：</strong></p>
<ul>
<li>跳过其所在节点的编译过程</li>
<li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src="./js/vue.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        [v-cloak]{
            display: none;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
v-bind:属性绑定,单向数据绑定，简写为 :xxx
v-model:双向数据绑定
v-on:事件绑定,监听，简写为 @
v-if:条件渲染，动态控制节点是否存在
v-else:条件渲染，动态控制节点是否存在
v-show:条件渲染，动态控制节点是否显示
v-for:循环渲染，遍历数组/对象/字符串
v-text:文本绑定，
v-html:html绑定，
    1.作用：向指定节点中渲染包含html结构的内容。
    2.与插值语法的区别：
    v-html会替换掉节点中所有的内容，{{xx}}则不会。
    v-html可以识别html结构。
    3.严重注意：v-html有安全性问题！！！！
    在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
    一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！
--&gt;
&lt;div id="app"&gt;
    &lt;div&gt;hello, {{name}}&lt;/div&gt;
    &lt;div v-text="name"&gt;&lt;/div&gt;
    &lt;div v-html="msg"&gt;&lt;/div&gt;
    &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt;
&lt;hr&gt;
    &lt;h2 v-once&gt;初始化数值num：{{num}}&lt;/h2&gt;
    &lt;h2&gt;当前数值num：{{num}}&lt;/h2&gt;
    &lt;button @click="num++"&gt;点我num++&lt;/button&gt;
    &lt;hr&gt;
    &lt;h2 v-pre&gt; 这是一个普通标签&lt;/h2&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script&gt;
    const vm = new Vue({
        el: '#app',
        data: {
            msg: '&lt;h3&gt;hello vue&lt;/h3&gt;',
            name: 'zhangsan',
            num: 100
        }
    })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-20-自定义指令"><a href="#1-20-自定义指令" class="headerlink" title="1.20 自定义指令"></a>1.20 自定义指令</h3><p>需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。</p>
<p>需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。</p>
<p>语法：</p>
<p><strong>局部指令：</strong></p>
<p>new Vue({</p>
<p>​	directives:{指名:配置对象}             </p>
<p>})</p>
<p>或者</p>
<p>new Vue({</p>
<p>​	directives:{指令名:回调函数}             </p>
<p>})</p>
<p><strong>全局指令：</strong>Vue.directive(指令名,配置对象) 或者 Vue.directive(指令名,回调函数)</p>
<p>配置对象中常用的3个回调：</p>
<ul>
<li>bind：指令与元素成功绑定时调用。</li>
<li>inserted：指令所在元素被插入页面时调用。</li>
<li>update：指令所在模板结构被重新解析时调用。</li>
</ul>
<p>备注：</p>
<ul>
<li><p>指令定义时不加v-，但使用时要加v-。</p>
</li>
<li><p>指令名如果是多个单词，要使用kebab-case命名方式，不要使用驼峰命名。</p>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。

需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。
--&gt;
&lt;div id="app"&gt;
    &lt;h3&gt;当前值：&lt;span v-text="num"&gt;&lt;/span&gt;&lt;/h3&gt;
    &lt;h3 &gt;放大10倍：&lt;span v-big="num"&gt;&lt;/span&gt;&lt;/h3&gt;
    &lt;h3 &gt;放大15倍：&lt;span v-big-number="num"&gt;&lt;/span&gt;&lt;/h3&gt;
    &lt;button @click="num++"&gt;点我num++&lt;/button&gt;
    &lt;br&gt;
    &lt;input type="text" v-fbind:value="num"&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script type="text/javascript"&gt;
Vue.config.productionTip = false;
// 全局自定义指令
    Vue.directive('big', {
        bind(el, binding){
            el.innerText = binding.value * 10
        }
    })
    Vue.directive('fbind', {
        // 指令与元素成功绑定时（一上来）
        bind(el, binding){
            el.value = binding.value
        },
        // 指令所在元素被插入页面时
        inserted(el){
            el.focus()
        },
        // 指令所在的模板被重新解析时
        update(el, binding){
            el.value = binding.value
        }
    })
    new Vue({
        el: '#app',
        data: {
            num: 1
        },
        // 局部自定义指令
        directives: {
            //big函数什么时候调用：1.指令与元素成功绑定时（一上来）2.指令所在的模板被重新解析时
            big(el, binding){
                //this 是window
                console.log('big',this);
                // el是绑定指令的元素,真实的dom
                console.log(el)
                console.log(el instanceof HTMLElement)
                el.innerText = binding.value * 10
            },
            'big-number'(el, binding){
                el.innerText = binding.value * 15
            },
            fbind:{
                bind(el, binding){
                    el.value = binding.value
                },
                // 指令所在元素被插入页面时
                inserted(el){
                    el.focus()
                },
                update(el, binding){
                    el.value = binding.value
                }
            }
        }
    })

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-21-生命周期"><a href="#1-21-生命周期" class="headerlink" title="1.21 生命周期"></a>1.21 生命周期</h3><p>先上图</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="life"></p>
<p><strong>beforeCreate（创建前）</strong>：数据监测(getter和setter)和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。<br><strong>created（创建后）</strong>：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el属性。<br><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。此阶段Vue开始解析模板，生成虚拟DOM存在内存中，还没有把虚拟DOM转换成真实DOM，插入页面中。所以网页不能显示解析好的内容。<br><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el（就是真实DOM的拷贝）替换，并挂载到实例上去之后调用（将内存中的虚拟DOM转为真实DOM，真实DOM插入页面）。此时页面中呈现的是经过Vue编译的DOM，这时在这个钩子函数中对DOM的操作可以有效，但要尽量避免。一般在这个阶段进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等等<br><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染（数据是新的，但页面是旧的，页面和数据没保持同步呢）。<br><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。在这个阶段一般进行关闭定时器，取消订阅消息，解绑自定义事件。<br><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</p>
<p>created之后：</p>
<p>先判断有没有 <strong>el</strong> 这个配置项，没有就调用 vm.$mount(el)，如果两个都没有就一直卡着，显示的界面就是最原始的容器的界面。有 <strong>el</strong> 这个配置项，就进行判断有没有 template 这个配置项，没有 template 就将 el 绑定的容器编译为 vue 模板。</p>
<p><strong>第一种情况，有 template：</strong></p>
<p>如果 el 绑定的容器没有任何内容，就一个空壳子，但在 Vue 实例中写了 template，就会编译解析这个 template 里的内容，生成虚拟 DOM，最后将 虚拟 DOM 转为 真实 DOM 插入页面（其实就可以理解为 template 替代了 el 绑定的容器的内容）。</p>
<p><img src="/2025/01/23/Vue2%E5%AD%A6%E4%B9%A0/image-20250415151131396.png" alt="image-20250415151131396"></p>
<p><strong>第二种情况，没有 template：</strong></p>
<p>没有 template，就编译解析 el 绑定的容器，生成虚拟 DOM，后面就顺着生命周期执行下去。</p>
<h3 id="1-21-非单文件组件"><a href="#1-21-非单文件组件" class="headerlink" title="1.21 非单文件组件"></a>1.21 非单文件组件</h3><p><strong>基本使用</strong><br>Vue中使用组件的三大步骤：</p>
<p>定义组件(创建组件)<br>注册组件<br>使用组件(写组件标签)</p>
<p><strong>定义组件</strong></p>
<p>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p>
<p>区别如下：</p>
<p>el不要写，为什么？ ———&gt; 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。<br>data必须写成函数，为什么？ ————&gt; 避免组件被复用时，数据存在引用关系。</p>
<p>举例说明 data为什么要写成函数？</p>
<p>这是因为js底层设计的原因：</p>
<p>对象形式：</p>
<pre><code class="javascript">let data = {
    a: 99,
    b: 100
}

let x = data;
let y = data;
// x 和 y 引用的都是同一个对象，修改 x 的值， y 的值也会改变
x.a = 66;
console.log(x); // a:66 b:100
console.log(y); // a:66 b:100
</code></pre>
<p>函数形式：</p>
<pre><code class="javascript">function data() {
    return {
        a: 99,
        b: 100
    }
}
let x = data();
let y = data();
console.log(x === y); // false
</code></pre>
<p>备注：使用template可以配置组件结构。</p>
<p><strong>注册组件</strong></p>
<ul>
<li>局部注册：靠new Vue的时候传入components选项</li>
<li>全局注册：靠Vue.component(‘组件名’,组件)</li>
</ul>
<p>几个注意点：<br>关于组件名：</p>
<p>一个单词组成：</p>
<p>第一种写法(首字母小写)：school<br>第二种写法(首字母大写)：School<br>多个单词组成：</p>
<p>第一种写法(kebab-case命名)：my-school<br>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</p>
<p>备注：</p>
<p>(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p>
<p>(2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p>
<p>一个简写方式：</p>
<p>const school = Vue.extend(options) 可简写为：const school = options</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
    &lt;h2&gt;{{msg}}&lt;/h2&gt;
    &lt;hr&gt;
    &lt;school&gt;&lt;/school&gt;
    &lt;hr&gt;
    &lt;person&gt;&lt;/person&gt;
    &lt;hr&gt;
    &lt;student&gt;&lt;/student&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    // 简写 组件
    const student = {
        template: `
            &lt;div&gt;
                &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
                &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
                &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
                &lt;button @click="showInfo"&gt;点我提示学生姓名&lt;/button&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                name: '李四',
                age: 19,
                sex: '女'
            }
        },
        methods: {
            showInfo(){
                alert(this.name)
            }
        }
    }
    const school = Vue.extend({
        template: `
            &lt;div&gt;
                &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
                &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
                &lt;button @click="showSchool"&gt;点我提示学校名称&lt;/button&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                name: '圣芙蕾雅',
                address: '极东'
            }
        },
        methods: {
            showSchool() {
                alert(this.name)
            }
        }
    })
    const person = Vue.extend({
        template: `
            &lt;div&gt;
                &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;
                &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;
                &lt;h2&gt;性别：{{sex}}&lt;/h2&gt;
                &lt;button @click="showInfo"&gt;点我提示姓名&lt;/button&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                name: '张三',
                age: 18,
                sex: '男'
            }
        },
        methods: {
            showInfo(){
                alert(this.name)
            }
        }
    })

    // 全局注册组件
    Vue.component('student', student)
    Vue.component('school', school)
    Vue.component('person', person)
    new Vue({
        el: '#app',
        data: {
            msg: '你好啊'
        },
        // 局部 注册组件
        // components: {
        //    school: school,
        //    person: person
        //   // ES6简写形式
        //   school,
        //   student
        // }
    })




&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>组件嵌套：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type="text/javascript" src="./js/vue.js"&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;script type="text/javascript"&gt;
    Vue.config.productionTip = false;
    // 简写 组件
    const student = {
        template: `
            &lt;div&gt;
                &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
                &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
                &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
                &lt;button @click="showInfo"&gt;点我提示学生姓名&lt;/button&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                name: '李四',
                age: 19,
                sex: '女'
            }
        },
        methods: {
            showInfo(){
                alert(this.name)
            }
        }
    }
    const school = Vue.extend({
        template: `
            &lt;div&gt;
                &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
                &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
                &lt;student&gt;&lt;/student&gt;
                &lt;button @click="showSchool"&gt;点我提示学校名称&lt;/button&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                name: '圣芙蕾雅',
                address: '极东'
            }
        },
        components:{
            student
        },
        methods: {
            showSchool() {
                alert(this.name)
            }
        }
    })
    const myAddress = Vue.extend({
        template: `
            &lt;div&gt;
                &lt;h2&gt;地址：{{address}}&lt;/h2&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                address: '神州'
            }
        }
    })
    const person = Vue.extend({
        template: `
            &lt;div&gt;
                &lt;h2&gt;姓名：{{name}}&lt;/h2&gt;
                &lt;h2&gt;年龄：{{age}}&lt;/h2&gt;
                &lt;h2&gt;性别：{{sex}}&lt;/h2&gt;

                &lt;my-address&gt;&lt;/my-address&gt;
                &lt;button @click="showInfo"&gt;点我提示姓名&lt;/button&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                name: '张三',
                age: 18,
                sex: '男'
            }
        },
        components: {
            'my-address': myAddress
        },
        methods: {
            showInfo(){
                alert(this.name)
            }
        }
    })

    const app = {
        template: `
            &lt;div&gt;
                &lt;h2&gt;{{msg}}&lt;/h2&gt;
                &lt;hr&gt;
                &lt;school&gt;&lt;/school&gt;
                &lt;hr&gt;
                &lt;person&gt;
                &lt;/person&gt;
                &lt;hr&gt;
            &lt;/div&gt;
        `,
        data() {
            return {
                msg: '你好啊'
            }
        },
        components: {
            school,
            person
        },
    }
    const vm = new Vue({
        el: '#app',
        template: '&lt;app&gt;&lt;/app&gt;',
        components: {
            app
        }
    })
    
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>VueComponent</strong><br>school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。<br>我们只需要写或，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。<br>特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！(这个VueComponent可不是实例对象)<br>关于this指向：<br>组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。<br>new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。<br>VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。</p>
<p><strong>一个重要的内置关系</strong></p>
<ul>
<li>一个重要的内置关系：VueComponent.prototype._proto_=== Vue.prototype</li>
<li>为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</li>
</ul>
<h3 id="1-22-单文件组件"><a href="#1-22-单文件组件" class="headerlink" title="1.22 单文件组件"></a>1.22 单文件组件</h3><p>单文件组件就是将一个组件的代码写在 .vue 这种格式的文件中，webpack 会将 .vue 文件解析成 html,css,js这些形式。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2025/02/27/SpringBoot%E6%8E%A5%E5%85%A5itext5%E7%94%9F%E6%88%90pdf/" title="SpringBoot接入itext5生成pdf"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: SpringBoot接入itext5生成pdf</span></a><a class="button is-default" href="/2024/12/25/%E6%94%AF%E4%BB%98%E5%AE%9DV3%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%85%A5/" title="支付宝V3接口接入"><span class="has-text-weight-semibold">Next: 支付宝V3接口接入</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="zhangqingguo/zhangqingguo.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/zhangqingguo"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> ZQG 2025</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"> </script><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2d_models/assets/Bronya.model.json"},"display":{"position":"right","width":240,"height":360,"right":"-80px","hOffset":0,"vOffset":-20},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>